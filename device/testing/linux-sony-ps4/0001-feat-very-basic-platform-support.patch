From a39f0b4736da33e9bee30fa890232892e73a0000 Mon Sep 17 00:00:00 2001
From: codedwrench <rick.04.1996@gmail.com>
Date: Sun, 19 Dec 2021 18:23:28 +0100
Subject: [PATCH 01/22] feat: very basic platform support

---
 arch/x86/Kconfig                      |  10 +-
 arch/x86/include/asm/ps4.h            |  60 +++
 arch/x86/include/asm/setup.h          |   6 +
 arch/x86/include/uapi/asm/bootparam.h |   1 +
 arch/x86/kernel/amd_nb.c              |   2 +
 arch/x86/kernel/head64.c              |   3 +
 arch/x86/platform/Makefile            |   1 +
 arch/x86/platform/ps4/Makefile        |   1 +
 arch/x86/platform/ps4/calibrate.c     | 116 +++++
 arch/x86/platform/ps4/ps4.c           |  74 ++++
 drivers/Makefile                      |   1 +
 drivers/iommu/amd/init.c              |   4 +
 drivers/pci/probe.c                   |  12 +
 drivers/ps4/Makefile                  |   9 +
 drivers/ps4/aeolia.h                  | 172 ++++++++
 drivers/ps4/icc/i2c.c                 | 156 +++++++
 drivers/ps4/ps4-apcie-icc.c           | 602 ++++++++++++++++++++++++++
 drivers/ps4/ps4-apcie-pwrbutton.c     |  69 +++
 drivers/ps4/ps4-apcie-uart.c          |  67 +++
 drivers/ps4/ps4-apcie.c               | 560 ++++++++++++++++++++++++
 include/linux/pci_ids.h               |  26 ++
 21 files changed, 1951 insertions(+), 1 deletion(-)
 create mode 100644 arch/x86/include/asm/ps4.h
 create mode 100644 arch/x86/platform/ps4/Makefile
 create mode 100644 arch/x86/platform/ps4/calibrate.c
 create mode 100644 arch/x86/platform/ps4/ps4.c
 create mode 100644 drivers/ps4/Makefile
 create mode 100644 drivers/ps4/aeolia.h
 create mode 100644 drivers/ps4/icc/i2c.c
 create mode 100644 drivers/ps4/ps4-apcie-icc.c
 create mode 100644 drivers/ps4/ps4-apcie-pwrbutton.c
 create mode 100644 drivers/ps4/ps4-apcie-uart.c
 create mode 100644 drivers/ps4/ps4-apcie.c

diff --git a/arch/x86/Kconfig b/arch/x86/Kconfig
index a08ce6360382..c510ff611adc 100644
--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -541,7 +541,15 @@ config X86_NUMACHIP
 	  Adds support for Numascale NumaChip large-SMP systems. Needed to
 	  enable more than ~168 cores.
 	  If you don't have one of these, you should say N here.
-
+		
+config X86_PS4
+	bool "Sony PlayStation 4"
+	depends on X86_64
+	depends on X86_EXTENDED_PLATFORM
+	depends on PCI
+	help
+	  Select to include support for the Sony PlayStation 4 game console.
+ 
 config X86_VSMP
 	bool "ScaleMP vSMP"
 	select HYPERVISOR_GUEST
diff --git a/arch/x86/include/asm/ps4.h b/arch/x86/include/asm/ps4.h
new file mode 100644
index 000000000000..60ee1c4f4f18
--- /dev/null
+++ b/arch/x86/include/asm/ps4.h
@@ -0,0 +1,60 @@
+/*
+ * ps4.h: Sony PS4 platform setup code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+#ifndef _ASM_X86_PS4_H
+#define _ASM_X86_PS4_H
+
+#ifdef CONFIG_X86_PS4
+
+#include <linux/irqdomain.h>
+
+#define PS4_DEFAULT_TSC_FREQ 1594000000
+
+#define EMC_TIMER_BASE 0xd0281000
+#define EMC_TIMER_VALUE 0x28
+
+extern unsigned long ps4_calibrate_tsc(void);
+
+/*
+ * The PS4 Aeolia southbridge device is a composite device containing some
+ * standard-ish, some not-so-standard, and some completely custom functions,
+ * all using special MSI handling. This function does the equivalent of
+ * pci_enable_msi_range and friends, for those devices. Only works after the
+ * Aeolia MSR routing function device (function 4) has been probed.
+ * Returns 1 or count, depending on IRQ allocation constraints, or negative on
+ * error. Assigned IRQ(s) start at dev->irq.
+ */
+extern int apcie_assign_irqs(struct pci_dev *dev, int nvec);
+extern void apcie_free_irqs(unsigned int virq, unsigned int nr_irqs);
+
+extern int apcie_status(void);
+extern int apcie_icc_cmd(u8 major, u16 minor, const void *data,
+			 u16 length, void *reply, u16 reply_length);
+
+
+#else
+
+static inline int apcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+	return -ENODEV;
+}
+static inline void apcie_free_irqs(unsigned int virq, unsigned int nvec)
+{
+}
+static inline int apcie_status(void)
+{
+	return -ENODEV;
+}
+static inline int apcie_icc_cmd(u8 major, u16 minor, const void *data,
+				u16 length, void *reply, u16 reply_length)
+{
+	return -ENODEV;
+}
+
+#endif
+#endif
diff --git a/arch/x86/include/asm/setup.h b/arch/x86/include/asm/setup.h
index a12458a7a8d4..074de91f3762 100644
--- a/arch/x86/include/asm/setup.h
+++ b/arch/x86/include/asm/setup.h
@@ -66,6 +66,12 @@ extern void x86_ce4100_early_setup(void);
 static inline void x86_ce4100_early_setup(void) { }
 #endif
 
+#ifdef CONFIG_X86_PS4
+extern void x86_ps4_early_setup(void);
+#else
+static inline void x86_ps4_early_setup(void) { }
+#endif
+
 #ifndef _SETUP
 
 #include <asm/espfix.h>
diff --git a/arch/x86/include/uapi/asm/bootparam.h b/arch/x86/include/uapi/asm/bootparam.h
index b25d3f82c2f3..6666ca2f100c 100644
--- a/arch/x86/include/uapi/asm/bootparam.h
+++ b/arch/x86/include/uapi/asm/bootparam.h
@@ -265,6 +265,7 @@ enum x86_hardware_subarch {
 	X86_SUBARCH_XEN,
 	X86_SUBARCH_INTEL_MID,
 	X86_SUBARCH_CE4100,
+	X86_SUBARCH_PS4,
 	X86_NR_SUBARCHS,
 };
 
diff --git a/arch/x86/kernel/amd_nb.c b/arch/x86/kernel/amd_nb.c
index c92c9c774c0e..d1fb4f09d727 100644
--- a/arch/x86/kernel/amd_nb.c
+++ b/arch/x86/kernel/amd_nb.c
@@ -54,6 +54,7 @@ static const struct pci_device_id amd_nb_misc_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_NB_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F3) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M41H_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_DF_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M10H_DF_F3) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M30H_DF_F3) },
@@ -72,6 +73,7 @@ static const struct pci_device_id amd_nb_link_ids[] = {
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_15H_M60H_NB_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_NB_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M30H_NB_F4) },
+	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_16H_M41H_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_DF_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M10H_DF_F4) },
 	{ PCI_DEVICE(PCI_VENDOR_ID_AMD, PCI_DEVICE_ID_AMD_17H_M30H_DF_F4) },
diff --git a/arch/x86/kernel/head64.c b/arch/x86/kernel/head64.c
index 5036104d5470..ca800a2f28b3 100644
--- a/arch/x86/kernel/head64.c
+++ b/arch/x86/kernel/head64.c
@@ -520,6 +520,9 @@ void __init x86_64_start_reservations(char *real_mode_data)
 	case X86_SUBARCH_INTEL_MID:
 		x86_intel_mid_early_setup();
 		break;
+	case X86_SUBARCH_PS4:
+		x86_ps4_early_setup();
+		break;
 	default:
 		break;
 	}
diff --git a/arch/x86/platform/Makefile b/arch/x86/platform/Makefile
index 3ed03a2552d0..fd92ee69b37c 100644
--- a/arch/x86/platform/Makefile
+++ b/arch/x86/platform/Makefile
@@ -9,6 +9,7 @@ obj-y	+= intel/
 obj-y	+= intel-mid/
 obj-y	+= intel-quark/
 obj-y	+= olpc/
+obj-y   += ps4/
 obj-y	+= scx200/
 obj-y	+= ts5500/
 obj-y	+= uv/
diff --git a/arch/x86/platform/ps4/Makefile b/arch/x86/platform/ps4/Makefile
new file mode 100644
index 000000000000..4d5fcde3a080
--- /dev/null
+++ b/arch/x86/platform/ps4/Makefile
@@ -0,0 +1 @@
+obj-$(CONFIG_X86_PS4) += ps4.o calibrate.o
diff --git a/arch/x86/platform/ps4/calibrate.c b/arch/x86/platform/ps4/calibrate.c
new file mode 100644
index 000000000000..232866816512
--- /dev/null
+++ b/arch/x86/platform/ps4/calibrate.c
@@ -0,0 +1,116 @@
+/*
+ * calibrate.c: Sony PS4 TSC/LAPIC calibration
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define pr_fmt(fmt) "ps4: " fmt
+
+#include <linux/jiffies.h>
+#include <asm/io.h>
+#include <asm/msr.h>
+#include <asm/ps4.h>
+#include <asm/delay.h>
+#include <asm/apic.h>
+
+/* The PS4 southbridge (Aeolia) has an EMC timer that ticks at 32.768kHz,
+ * which seems to be an appropriate clock reference for calibration. Both TSC
+ * and the LAPIC timer are based on the core clock frequency and thus can be
+ * calibrated together. */
+static void __iomem *emc_timer = NULL;
+
+static __init inline u32 emctimer_read32(unsigned int reg)
+{
+	return ioread32(emc_timer + reg);
+}
+
+static __init inline void emctimer_write32(unsigned int reg, u32 val)
+{
+	iowrite32(val, emc_timer + reg);
+}
+
+static __init inline u32 emctimer_read(void)
+{
+	u32 t1, t2;
+	t1 = emctimer_read32(EMC_TIMER_VALUE);
+	while (1) {
+		t2 = emctimer_read32(EMC_TIMER_VALUE);
+		if (t1 == t2)
+			return t1;
+		t1 = t2;
+	}
+}
+
+static __init unsigned long ps4_measure_tsc_freq(void)
+{
+	unsigned long ret = 0;
+	u32 t1, t2;
+	u64 tsc1, tsc2;
+
+	// This is part of the Aeolia pcie device, but it's too early to
+	// do this in a driver.
+	emc_timer = ioremap(EMC_TIMER_BASE, 0x100);
+	if (!emc_timer)
+		goto fail;
+
+	// reset/start the timer
+	emctimer_write32(0x84, emctimer_read32(0x84) & (~0x01));
+	// udelay is not calibrated yet, so this is likely wildly off, but good
+	// enough to work.
+	udelay(300);
+	emctimer_write32(0x00, emctimer_read32(0x00) | 0x01);
+	emctimer_write32(0x84, emctimer_read32(0x84) | 0x01);
+
+	t1 = emctimer_read();
+	tsc1 = tsc2 = rdtsc();
+
+	while (emctimer_read() == t1) {
+		// 0.1s timeout should be enough
+		tsc2 = rdtsc();
+		if ((tsc2 - tsc1) > (PS4_DEFAULT_TSC_FREQ/10)) {
+			pr_warn("EMC timer is broken.\n");
+			goto fail;
+		}
+	}
+	pr_info("EMC timer started in %lld TSC ticks\n", tsc2 - tsc1);
+
+	// Wait for a tick boundary
+	t1 = emctimer_read();
+	while ((t2 = emctimer_read()) == t1);
+	tsc1 = rdtsc();
+
+	// Wait for 1024 ticks to elapse (31.25ms)
+	// We don't need to wait very long, as we are looking for transitions.
+	// At this value, a TSC uncertainty of ~50 ticks corresponds to 1ppm of
+	// clock accuracy.
+	while ((emctimer_read() - t2) < 1024);
+	tsc2 = rdtsc();
+
+	// TSC rate is 32 times the elapsed time
+	ret = (tsc2 - tsc1) * 32;
+
+	pr_info("Calibrated TSC frequency: %ld kHz\n", ret);
+fail:
+	if (emc_timer) {
+		iounmap(emc_timer);
+		emc_timer = NULL;
+	}
+	return ret;
+}
+
+unsigned long __init ps4_calibrate_tsc(void)
+{
+	unsigned long tsc_freq = ps4_measure_tsc_freq();
+
+	if (!tsc_freq) {
+		pr_warn("Unable to measure TSC frequency, assuming default.\n");
+		tsc_freq = PS4_DEFAULT_TSC_FREQ;
+	}
+
+	lapic_timer_period = (tsc_freq + 8 * HZ) / (16 * HZ);
+
+	return (tsc_freq + 500) / 1000;
+}
diff --git a/arch/x86/platform/ps4/ps4.c b/arch/x86/platform/ps4/ps4.c
new file mode 100644
index 000000000000..8a3a11263724
--- /dev/null
+++ b/arch/x86/platform/ps4/ps4.c
@@ -0,0 +1,74 @@
+/*
+ * ps4.c: Sony PS4 platform setup code
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; version 2
+ * of the License.
+ */
+
+#define pr_fmt(fmt) "ps4: " fmt
+
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/interrupt.h>
+#include <linux/scatterlist.h>
+#include <linux/irq.h>
+#include <linux/module.h>
+#include <linux/notifier.h>
+
+#include <asm/setup.h>
+#include <asm/mpspec_def.h>
+#include <asm/hw_irq.h>
+#include <asm/apic.h>
+#include <asm/io_apic.h>
+#include <asm/io.h>
+#include <asm/i8259.h>
+#include <asm/reboot.h>
+#include <asm/msr.h>
+#include <asm/ps4.h>
+
+static bool is_ps4;
+bool apcie_initialized;
+
+/*
+ * The RTC is part of the Aeolia PCI device and will be implemented there as
+ * an RTC class device; stub these out.
+ */
+static void dummy_get_wallclock(struct timespec64 *now)
+{
+	now->tv_sec = now->tv_nsec = 0;
+}
+static int dummy_set_wallclock(const struct timespec64 *now)
+{
+	return -ENODEV;
+}
+
+/*
+ * Provide a way for generic drivers to query for the availability of the
+ * PS4 apcie driver/device, which is a dependency for them.
+ */
+int apcie_status(void)
+{
+	if (!is_ps4)
+		return -ENODEV;
+	return apcie_initialized;
+}
+EXPORT_SYMBOL_GPL(apcie_status);
+
+void icc_reboot(void);
+
+/*
+ * PS4 specific x86_init function overrides and early setup calls.
+ */
+void __init x86_ps4_early_setup(void)
+{
+	pr_info("x86_ps4_early_setup: PS4 early setup\n");
+	is_ps4 = true;
+	x86_platform.calibrate_tsc = ps4_calibrate_tsc;
+	x86_platform.get_wallclock = dummy_get_wallclock;
+	x86_platform.set_wallclock = dummy_set_wallclock;
+
+	legacy_pic = &null_legacy_pic;
+	machine_ops.emergency_restart = icc_reboot;
+}
diff --git a/drivers/Makefile b/drivers/Makefile
index a110338c860c..6d866a189d6a 100644
--- a/drivers/Makefile
+++ b/drivers/Makefile
@@ -85,6 +85,7 @@ obj-$(CONFIG_SPI)		+= spi/
 obj-$(CONFIG_SPMI)		+= spmi/
 obj-$(CONFIG_HSI)		+= hsi/
 obj-$(CONFIG_SLIMBUS)		+= slimbus/
+obj-$(CONFIG_X86_PS4)		+= ps4/
 obj-y				+= net/
 obj-$(CONFIG_ATM)		+= atm/
 obj-$(CONFIG_FUSION)		+= message/
diff --git a/drivers/iommu/amd/init.c b/drivers/iommu/amd/init.c
index 50ea582be591..ea0e5dc8d88d 100644
--- a/drivers/iommu/amd/init.c
+++ b/drivers/iommu/amd/init.c
@@ -2603,6 +2603,7 @@ static void __init free_iommu_resources(void)
 	free_iommu_all();
 }
 
+#ifndef CONFIG_X86_PS4 // TODO this should detect ps4-ness at runtime
 /* SB IOAPIC is always on this device in AMD systems */
 #define IOAPIC_SB_DEVID		((0x00 << 8) | PCI_DEVFN(0x14, 0))
 
@@ -2654,6 +2655,7 @@ static bool __init check_ioapic_information(void)
 
 	return ret;
 }
+#endif
 
 static void __init free_dma_resources(void)
 {
@@ -2794,8 +2796,10 @@ static int __init early_amd_iommu_init(void)
 	if (!is_kdump_kernel() || amd_iommu_disabled)
 		disable_iommus();
 
+	#ifndef CONFIG_X86_PS4
 	if (amd_iommu_irq_remap)
 		amd_iommu_irq_remap = check_ioapic_information();
+	#endif
 
 	if (amd_iommu_irq_remap) {
 		/*
diff --git a/drivers/pci/probe.c b/drivers/pci/probe.c
index d9fc02a71baa..5fe5e84fab40 100644
--- a/drivers/pci/probe.c
+++ b/drivers/pci/probe.c
@@ -2600,6 +2600,9 @@ static int only_one_child(struct pci_bus *bus)
 	return 0;
 }
 
+// It can be arbitrary (above 2). Freebsd uses 20, so use that too.
+#define AEOLIA_SLOT_NUM 20
+
 /**
  * pci_scan_slot - Scan a PCI slot on a bus for devices
  * @bus: PCI bus to scan
@@ -2616,9 +2619,18 @@ int pci_scan_slot(struct pci_bus *bus, int devfn)
 	unsigned fn, nr = 0;
 	struct pci_dev *dev;
 
+	u32 l;
+
 	if (only_one_child(bus) && (devfn > 0))
 		return 0; /* Already scanned the entire slot */
 
+	// skip phantom Aeolia devices that bleed through the PCI space
+	if (PCI_SLOT(devfn) != AEOLIA_SLOT_NUM &&
+	    pci_bus_read_dev_vendor_id(bus, devfn, &l, 60*1000) &&
+	    (l & 0xffff) == PCI_VENDOR_ID_SONY) {
+		return 0;
+	}
+
 	dev = pci_scan_single_device(bus, devfn);
 	if (!dev)
 		return 0;
diff --git a/drivers/ps4/Makefile b/drivers/ps4/Makefile
new file mode 100644
index 000000000000..4f7d50363f50
--- /dev/null
+++ b/drivers/ps4/Makefile
@@ -0,0 +1,9 @@
+# Aeolia PCI devices
+# LISTED IN INIT ORDER \o/ ...  ._.
+# N.B. this driver must be init'd before pretty much everything, but actual dependants are:
+# drivers/net/ethernet/marvell/sky2 (implements ps4-gbe)
+obj-y += ps4-apcie.o \
+	ps4-apcie-uart.o \
+	ps4-apcie-icc.o \
+	ps4-apcie-pwrbutton.o \
+	icc/i2c.o \
diff --git a/drivers/ps4/aeolia.h b/drivers/ps4/aeolia.h
new file mode 100644
index 000000000000..13df4b9a4fef
--- /dev/null
+++ b/drivers/ps4/aeolia.h
@@ -0,0 +1,172 @@
+#ifndef _AEOLIA_H
+#define _AEOLIA_H
+
+#include <linux/io.h>
+#include <linux/pci.h>
+#include <linux/i2c.h>
+
+enum aeolia_func_id {
+	AEOLIA_FUNC_ID_ACPI = 0,
+	AEOLIA_FUNC_ID_GBE,
+	AEOLIA_FUNC_ID_AHCI,
+	AEOLIA_FUNC_ID_SDHCI,
+	AEOLIA_FUNC_ID_PCIE,
+	AEOLIA_FUNC_ID_DMAC,
+	AEOLIA_FUNC_ID_MEM,
+	AEOLIA_FUNC_ID_XHCI,
+
+	AEOLIA_NUM_FUNCS
+};
+
+/* MSI registers for up to 31, but only 23 known. */
+#define APCIE_NUM_SUBFUNC		23
+
+/* Sub-functions, aka MSI vectors */
+enum apcie_subfunc {
+	APCIE_SUBFUNC_GLUE	= 0,
+	APCIE_SUBFUNC_ICC	= 3,
+	APCIE_SUBFUNC_HPET	= 5,
+	APCIE_SUBFUNC_SFLASH	= 11,
+	APCIE_SUBFUNC_RTC	= 13,
+	APCIE_SUBFUNC_UART0	= 19,
+	APCIE_SUBFUNC_UART1	= 20,
+	APCIE_SUBFUNC_TWSI	= 21,
+
+	APCIE_NUM_SUBFUNCS	= 23
+};
+
+#define APCIE_NR_UARTS 2
+
+/* Relative to BAR2 */
+#define APCIE_RGN_RTC_BASE		0x0
+#define APCIE_RGN_RTC_SIZE		0x1000
+
+#define APCIE_RGN_CHIPID_BASE		0x1000
+#define APCIE_RGN_CHIPID_SIZE		0x1000
+
+#define APCIE_REG_CHIPID_0		0x1104
+#define APCIE_REG_CHIPID_1		0x1108
+#define APCIE_REG_CHIPREV		0x110c
+
+/* Relative to BAR4 */
+#define APCIE_RGN_UART_BASE		0x140000
+#define APCIE_RGN_UART_SIZE		0x1000
+
+#define APCIE_RGN_PCIE_BASE		0x1c8000
+#define APCIE_RGN_PCIE_SIZE		0x1000
+
+#define APCIE_RGN_ICC_BASE		0x184000
+#define APCIE_RGN_ICC_SIZE		0x1000
+
+#define APCIE_REG_BAR(x)		(APCIE_RGN_PCIE_BASE + (x))
+#define APCIE_REG_BAR_MASK(func, bar)	APCIE_REG_BAR(((func) * 0x30) + \
+						((bar) << 3))
+#define APCIE_REG_BAR_ADDR(func, bar)	APCIE_REG_BAR(((func) * 0x30) + \
+						((bar) << 3) + 0x4)
+
+#define APCIE_REG_MSI(x)		(APCIE_RGN_PCIE_BASE + 0x400 + (x))
+#define APCIE_REG_MSI_CONTROL		APCIE_REG_MSI(0x0)
+#define APCIE_REG_MSI_MASK(func)	APCIE_REG_MSI(0x4c + ((func) << 2))
+#define APCIE_REG_MSI_DATA_HI(func)	APCIE_REG_MSI(0x8c + ((func) << 2))
+#define APCIE_REG_MSI_ADDR(func)	APCIE_REG_MSI(0xac + ((func) << 2))
+/* This register has non-uniform structure per function, dealt with in code */
+#define APCIE_REG_MSI_DATA_LO(off)	APCIE_REG_MSI(0x100 + (off))
+
+/* Not sure what the two individual bits do */
+#define APCIE_REG_MSI_CONTROL_ENABLE	0x05
+
+/* Enable for the entire function, 4 is special */
+#define APCIE_REG_MSI_MASK_FUNC		0x01000000
+#define APCIE_REG_MSI_MASK_FUNC4	0x80000000
+
+#define APCIE_REG_ICC(x)		(APCIE_RGN_ICC_BASE + (x))
+#define APCIE_REG_ICC_DOORBELL		APCIE_REG_ICC(0x804)
+#define APCIE_REG_ICC_STATUS		APCIE_REG_ICC(0x814)
+#define APCIE_REG_ICC_IRQ_MASK		APCIE_REG_ICC(0x824)
+
+/* Apply to both DOORBELL and STATUS */
+#define APCIE_ICC_SEND			0x01
+#define APCIE_ICC_ACK			0x02
+
+/* Relative to func6 BAR5 */
+#define APCIE_SPM_ICC_BASE		0x2c000
+#define APCIE_SPM_ICC_SIZE		0x1000
+
+/* Boot params passed from southbridge */
+#define APCIE_SPM_BP_BASE		0x2f000
+#define APCIE_SPM_BP_SIZE		0x20
+
+#define APCIE_SPM_ICC_REQUEST		0x0
+#define APCIE_SPM_ICC_REPLY		0x800
+
+#define ICC_REPLY 0x4000
+#define ICC_EVENT 0x8000
+
+#define ICC_MAGIC 0x42
+#define ICC_EVENT_MAGIC 0x24
+
+struct icc_message_hdr {
+	u8 magic;// not magic: it's ID of sender. 0x32=EAP,0x42=SoC(x86/fbsd)
+ 	u8 major;// service id (destination)
+ 	u16 minor;// message id (command)
+	u16 unknown;
+	u16 cookie; //normally monotonic xfer counter, can be set to special values
+	u16 length;
+	u16 checksum;
+} __packed;
+
+#define ICC_HDR_SIZE sizeof(struct icc_message_hdr)
+#define ICC_MIN_SIZE 0x20
+#define ICC_MAX_SIZE 0x7f0
+#define ICC_MIN_PAYLOAD (ICC_MIN_SIZE - ICC_HDR_SIZE)
+#define ICC_MAX_PAYLOAD (ICC_MAX_SIZE - ICC_HDR_SIZE)
+
+struct apcie_icc_dev {
+	phys_addr_t spm_base;
+	void __iomem *spm;
+
+	spinlock_t reply_lock;
+	bool reply_pending;
+
+	struct icc_message_hdr request;
+	struct icc_message_hdr reply;
+	u16 reply_extra_checksum;
+	void *reply_buffer;
+	int reply_length;
+	wait_queue_head_t wq;
+
+	struct i2c_adapter i2c;
+	struct input_dev *pwrbutton_dev;
+};
+
+struct apcie_dev {
+	struct pci_dev *pdev;
+	struct irq_domain *irqdomain;
+	void __iomem *bar0;
+	void __iomem *bar2;
+	void __iomem *bar4;
+
+	int nvec;
+	int serial_line[2];
+	struct apcie_icc_dev icc;
+};
+
+#define sc_err(...) dev_err(&sc->pdev->dev, __VA_ARGS__)
+#define sc_warn(...) dev_warn(&sc->pdev->dev, __VA_ARGS__)
+#define sc_notice(...) dev_notice(&sc->pdev->dev, __VA_ARGS__)
+#define sc_info(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
+#define sc_dbg(...) dev_dbg(&sc->pdev->dev, __VA_ARGS__)
+
+static inline int apcie_irqnum(struct apcie_dev *sc, int index)
+{
+	if (sc->nvec > 1) {
+		return sc->pdev->irq + index;
+	} else {
+		return sc->pdev->irq;
+	}
+}
+
+int apcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
+	    void *reply, u16 reply_length);
+
+#endif
diff --git a/drivers/ps4/icc/i2c.c b/drivers/ps4/icc/i2c.c
new file mode 100644
index 000000000000..647c26a5cdd4
--- /dev/null
+++ b/drivers/ps4/icc/i2c.c
@@ -0,0 +1,156 @@
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#include "../aeolia.h"
+
+#define ICC_MAX_READ_DATA 0xff
+#define ICC_MAX_WRITE_DATA 0xf8
+
+/* This is actually multiple nested variable length structures, but since we
+ * currently only support one op per transaction, we hardcode it. */
+struct icc_i2c_msg {
+	/* Header */
+	u8 code;
+	u16 length;
+	u8 count;
+	struct {
+		u8 major;
+		u8 length;
+		u8 minor;
+		u8 count;
+		struct {
+			u8 length;
+			u8 slave_addr;
+			u8 reg_addr;
+			u8 data[ICC_MAX_WRITE_DATA];
+		} xfer;
+	} cmd;
+} __packed;
+
+static int icc_i2c_smbus_xfer(struct i2c_adapter *adapter, u16 addr,
+			  unsigned short flags,
+			  char read_write, u8 command, int size,
+			  union i2c_smbus_data *data)
+{
+	struct apcie_dev *sc = i2c_get_adapdata(adapter);
+	int ret;
+	struct icc_i2c_msg msg;
+	u8 resultbuf[8 + ICC_MAX_READ_DATA];
+
+	msg.code = 4; /* Don't really know what this is */
+	msg.count = 1;
+	msg.cmd.count = 1;
+	msg.cmd.xfer.slave_addr = addr << 1;
+	msg.cmd.xfer.reg_addr = command;
+	if (read_write == I2C_SMBUS_READ) {
+		msg.cmd.major = 1;
+		msg.cmd.minor = 1;
+		msg.cmd.length = 8;
+		msg.cmd.xfer.data[0] = 0; /* unknown */
+	} else {
+		msg.cmd.major = 2;
+		msg.cmd.minor = 2;
+	}
+
+	switch (size) {
+	case I2C_SMBUS_BYTE_DATA:
+		msg.cmd.xfer.length = 1;
+		if (read_write == I2C_SMBUS_WRITE) {
+			msg.cmd.length = 8;
+			msg.cmd.xfer.data[0] = data->byte;
+		}
+		break;
+	case I2C_SMBUS_WORD_DATA:
+		msg.cmd.xfer.length = 2;
+		if (read_write == I2C_SMBUS_WRITE) {
+			msg.cmd.length = 9;
+			msg.cmd.xfer.data[0] = data->word & 0xff;
+			msg.cmd.xfer.data[1] = data->word >> 8;
+		}
+		break;
+	case I2C_SMBUS_I2C_BLOCK_DATA:
+		msg.cmd.xfer.length = data->block[0];
+		if (read_write == I2C_SMBUS_WRITE) {
+			if (data->block[0] > ICC_MAX_WRITE_DATA) {
+				sc_err("icc-i2c: transaction too large: %d\n",
+				       data->block[0]);
+				return -E2BIG;
+			}
+			msg.cmd.length = 7 + data->block[0];
+			memcpy(msg.cmd.xfer.data, &data->block[1],
+			       data->block[0]);
+		}
+		break;
+	default:
+		sc_err("icc-i2c: unsupported transaction %d\n", size);
+		return -ENOTSUPP;
+	}
+
+	msg.length = msg.cmd.length + 4;
+	ret = apcie_icc_cmd(0x10, 0x0, &msg, msg.length, resultbuf,
+		      sizeof(resultbuf));
+	if (ret < 2 || ret > sizeof(resultbuf)) {
+		sc_err("icc-i2c: icc command failed: %d\n", ret);
+		return -EIO;
+	}
+	if (resultbuf[0] != 0 || resultbuf[1] != 0) {
+		sc_err("icc-i2c: i2c command failed: %d, %d\n",
+		       resultbuf[0], resultbuf[1]);
+		return -EIO;
+	}
+
+	if (read_write == I2C_SMBUS_READ)
+		switch (size) {
+		case I2C_SMBUS_BYTE_DATA:
+			data->byte = resultbuf[8];
+			break;
+		case I2C_SMBUS_WORD_DATA:
+			data->word = resultbuf[8] | (resultbuf[9] << 8);
+			break;
+		case I2C_SMBUS_I2C_BLOCK_DATA:
+			memcpy(&data->block[1], &resultbuf[8],
+			       data->block[0]);
+			break;
+		}
+
+	return 0;
+}
+
+u32 icc_i2c_functionality(struct i2c_adapter *adap)
+{
+	return I2C_FUNC_SMBUS_BYTE_DATA |
+		I2C_FUNC_SMBUS_WORD_DATA |
+		I2C_FUNC_SMBUS_I2C_BLOCK;
+}
+
+static const struct i2c_algorithm icc_i2c_algo = {
+	.smbus_xfer   = &icc_i2c_smbus_xfer,
+	.functionality = &icc_i2c_functionality,
+};
+
+
+int icc_i2c_init(struct apcie_dev *sc)
+{
+	struct i2c_adapter *i2c;
+	int ret;
+
+	i2c = &sc->icc.i2c;
+	i2c->owner = THIS_MODULE;
+	i2c->algo = &icc_i2c_algo;
+	i2c->algo_data = NULL;
+	i2c->dev.parent = &sc->pdev->dev;
+	strlcpy(i2c->name, "icc", sizeof(i2c->name));
+	i2c_set_adapdata(i2c, sc);
+	ret = i2c_add_adapter(i2c);
+	if (ret < 0) {
+		sc_err("failed to add i2c adapter\n");
+		return ret;
+	}
+	return 0;
+}
+
+void icc_i2c_remove(struct apcie_dev *sc)
+{
+	i2c_del_adapter(&sc->icc.i2c);
+}
diff --git a/drivers/ps4/ps4-apcie-icc.c b/drivers/ps4/ps4-apcie-icc.c
new file mode 100644
index 000000000000..2ee9885d7a1c
--- /dev/null
+++ b/drivers/ps4/ps4-apcie-icc.c
@@ -0,0 +1,602 @@
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/sched.h>
+#include <linux/wait.h>
+#include <linux/pci.h>
+#include <linux/interrupt.h>
+#include <linux/delay.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <asm/ps4.h>
+#include "aeolia.h"
+
+/* There should normally be only one Aeolia device in a system. This allows
+ * other kernel code in unrelated subsystems to issue icc requests without
+ * having to get a reference to the device. */
+static struct apcie_dev *icc_sc;
+DEFINE_MUTEX(icc_mutex);
+
+/* The ICC message passing interface seems to be potentially designed to
+ * support multiple outstanding requests at once, but the original PS4 OS never
+ * does this, so we don't either. */
+
+#define BUF_FULL 0x7f0
+#define BUF_EMPTY 0x7f4
+#define HDR(x) (offsetof(struct icc_message_hdr, x))
+#define REQUEST (sc->icc.spm + APCIE_SPM_ICC_REQUEST)
+#define REPLY (sc->icc.spm + APCIE_SPM_ICC_REPLY)
+
+/* Seconds. Yes, some ICC requests can be slow. */
+int icc_timeout = 15;
+
+int icc_i2c_init(struct apcie_dev *sc);
+void icc_i2c_remove(struct apcie_dev *sc);
+int icc_pwrbutton_init(struct apcie_dev *sc);
+void icc_pwrbutton_remove(struct apcie_dev *sc);
+void icc_pwrbutton_trigger(struct apcie_dev *sc, int state);
+
+#define ICC_MAJOR	'I'
+
+ struct icc_cmd {
+ 	u8 major;
+ 	u16 minor;
+ 	void __user *data;
+ 	u16 length;
+ 	void __user *reply;
+ 	u16 reply_length;
+ };
+
+#define ICC_IOCTL_CMD _IOWR(ICC_MAJOR, 1, struct icc_cmd)
+
+static u16 checksum(const void *p, int length)
+{
+	const u8 *pp = p;
+	u16 sum = 0;
+	while (length--)
+		sum += *pp++;
+	return sum;
+}
+
+static void dump_message(struct apcie_dev *sc, int offset)
+{
+	int len;
+	struct icc_message_hdr hdr;
+	memcpy_fromio(&hdr, sc->icc.spm + offset, ICC_HDR_SIZE);
+
+	sc_err("icc: hdr: [%02x] %02x:%04x unk %x #%d len %d cksum 0x%x\n",
+	       hdr.magic, hdr.major, hdr.minor, hdr.unknown, hdr.cookie,
+	       hdr.length, hdr.checksum);
+	len = min(hdr.length - ICC_HDR_SIZE, ICC_MAX_PAYLOAD);
+	if (len > 0) {
+		sc_err("icc: data:");
+		while (len--)
+			printk(" %02x", ioread8(sc->icc.spm + (offset++) +
+			                         ICC_HDR_SIZE));
+		printk("\n");
+	}
+}
+
+static void handle_event(struct apcie_dev *sc, struct icc_message_hdr *msg)
+{
+	switch ((msg->major << 16) | msg->minor) {
+		case 0x088010:
+			icc_pwrbutton_trigger(sc, 1);
+			break;
+		case 0x088011:
+			icc_pwrbutton_trigger(sc, 0);
+			break;
+		default:
+			sc_err("icc: event arrived, not yet supported.\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			break;
+	}
+}
+
+static void handle_message(struct apcie_dev *sc)
+{
+	u32 rep_empty, rep_full;
+	int off, copy_size;
+	struct icc_message_hdr msg;
+
+	rep_empty = ioread32(REPLY + BUF_EMPTY);
+	rep_full = ioread32(REPLY + BUF_FULL);
+
+	if (rep_empty != 0 || rep_full != 1) {
+		sc_err("icc: reply buffer in bad state (%d, %d)\n",
+			rep_empty, rep_full);
+		return;
+	}
+
+	memcpy_fromio(&msg, REPLY, ICC_HDR_SIZE);
+
+	if (msg.minor & ICC_EVENT) {
+		if (msg.magic != ICC_EVENT_MAGIC) {
+			sc_err("icc: event has bad magic\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		handle_event(sc, &msg);
+	} else if (msg.minor & ICC_REPLY) {
+		if (msg.magic != ICC_MAGIC) {
+			sc_err("icc: reply has bad magic\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		spin_lock(&sc->icc.reply_lock);
+		if (!sc->icc.reply_pending) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: unexpected reply\n");
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		if (msg.cookie != sc->icc.request.cookie) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: reply has bad cookie %d\n", msg.cookie);
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		if (msg.length < ICC_HDR_SIZE || msg.length > ICC_MAX_SIZE) {
+			spin_unlock(&sc->icc.reply_lock);
+			sc_err("icc: reply has bad length %d\n", msg.length);
+			dump_message(sc, APCIE_SPM_ICC_REPLY);
+			return;
+		}
+		off = ICC_HDR_SIZE;
+		copy_size = min(sc->icc.reply_length,
+				(int)(msg.length - off));
+		memcpy_fromio(sc->icc.reply_buffer, REPLY + off, copy_size);
+		off += copy_size;
+		sc->icc.reply_extra_checksum = 0;
+		while (off < msg.length)
+			sc->icc.reply_extra_checksum += ioread8(REPLY + off++);
+		sc->icc.reply_pending = false;
+		sc->icc.reply_length = copy_size;
+		sc->icc.reply = msg;
+		spin_unlock(&sc->icc.reply_lock);
+		wake_up(&sc->icc.wq);
+	} else {
+		sc_err("icc: unknown message arrived\n");
+		dump_message(sc, APCIE_SPM_ICC_REPLY);
+	}
+}
+
+static irqreturn_t icc_interrupt(int irq, void *arg)
+{
+	struct apcie_dev *sc = arg;
+	u32 status;
+	u32 ret = IRQ_NONE;
+
+	do {
+		status = ioread32(sc->bar4 + APCIE_REG_ICC_STATUS);
+
+		if (status & APCIE_ICC_ACK) {
+			iowrite32(APCIE_ICC_ACK,
+				  sc->bar4 + APCIE_REG_ICC_STATUS);
+			ret = IRQ_HANDLED;
+		}
+
+		if (status & APCIE_ICC_SEND) {
+			iowrite32(APCIE_ICC_SEND,
+				  sc->bar4 + APCIE_REG_ICC_STATUS);
+			handle_message(sc);
+			iowrite32(0, REPLY + BUF_FULL);
+			iowrite32(1, REPLY + BUF_EMPTY);
+			iowrite32(APCIE_ICC_ACK,
+				  sc->bar4 + APCIE_REG_ICC_DOORBELL);
+			ret = IRQ_HANDLED;
+		}
+	} while (status);
+
+	return ret;
+}
+
+static int _apcie_icc_cmd(struct apcie_dev *sc, u8 major, u16 minor, const void *data,
+		    u16 length, void *reply, u16 reply_length, bool intr)
+{
+	int ret;
+	u32 req_empty, req_full;
+	u16 rep_checksum;
+
+	if (length > ICC_MAX_PAYLOAD)
+		return -E2BIG;
+
+	sc->icc.request.magic = ICC_MAGIC;
+	sc->icc.request.major = major;
+	sc->icc.request.minor = minor;
+	sc->icc.request.cookie++;
+	sc->icc.request.length = ICC_HDR_SIZE + length;
+	sc->icc.request.checksum = 0;
+	if (sc->icc.request.length < ICC_MIN_SIZE)
+		sc->icc.request.length = ICC_MIN_SIZE;
+
+	sc->icc.request.checksum = checksum(&sc->icc.request, ICC_HDR_SIZE);
+	sc->icc.request.checksum += checksum(data, length);
+	sc->icc.reply_buffer = reply;
+	sc->icc.reply_length = reply_length;
+
+	req_empty = ioread32(REQUEST + BUF_EMPTY);
+	req_full = ioread32(REQUEST + BUF_FULL);
+
+	if (req_empty != 1 || req_full != 0) {
+		sc_err("icc: request buffer is busy: empty=%d full=%d\n",
+		       req_empty, req_full);
+		return -EIO;
+	}
+
+	iowrite32(0, REQUEST + BUF_EMPTY);
+
+	memcpy_toio(REQUEST, &sc->icc.request, ICC_HDR_SIZE);
+	memcpy_toio(REQUEST + ICC_HDR_SIZE, data, length);
+	if (length < ICC_MIN_PAYLOAD)
+		memset_io(REQUEST + ICC_HDR_SIZE + length, 0,
+			  ICC_MIN_PAYLOAD - length);
+
+	iowrite32(1, REQUEST + BUF_FULL);
+
+	spin_lock_irq(&sc->icc.reply_lock);
+	sc->icc.reply_pending = true;
+	spin_unlock_irq(&sc->icc.reply_lock);
+
+	iowrite32(APCIE_ICC_SEND, sc->bar4 + APCIE_REG_ICC_DOORBELL);
+
+	if (intr)
+		ret = wait_event_interruptible_timeout(sc->icc.wq,
+				!sc->icc.reply_pending, HZ * icc_timeout);
+	else
+		ret = wait_event_timeout(sc->icc.wq,
+				!sc->icc.reply_pending, HZ * icc_timeout);
+
+	spin_lock_irq(&sc->icc.reply_lock);
+	sc->icc.reply_buffer = NULL;
+	if (ret < 0 || sc->icc.reply_pending) { /* interrupted or timed out */
+		sc->icc.reply_pending = false;
+		spin_unlock_irq(&sc->icc.reply_lock);
+		sc_err("icc: interrupted or timeout: ret = %d\n", ret);
+		return ret < 0 ? -EINTR : -ETIMEDOUT;
+	}
+	spin_unlock_irq(&sc->icc.reply_lock);
+
+	rep_checksum = sc->icc.reply.checksum;
+	sc->icc.reply.checksum = 0;
+	rep_checksum -= checksum(&sc->icc.reply, ICC_HDR_SIZE);
+	rep_checksum -= checksum(reply, sc->icc.reply_length);
+	rep_checksum -= sc->icc.reply_extra_checksum;
+
+	if (rep_checksum) {
+		sc_err("icc: checksum mismatch (diff: %x)\n", rep_checksum);
+		return -EIO;
+	}
+
+	if (sc->icc.reply.major != major ) {
+		sc_err("icc: major mismatch\n");
+		return -EIO;
+	}
+	if (sc->icc.reply.minor != (minor | ICC_REPLY) ) {
+		sc_err("icc: minor mismatch\n");
+		return -EIO;
+	}
+
+	return sc->icc.reply.length - ICC_HDR_SIZE;
+}
+
+int apcie_icc_cmd(u8 major, u16 minor, const void *data, u16 length,
+		   void *reply, u16 reply_length)
+{
+	int ret;
+
+	mutex_lock(&icc_mutex);
+	if (!icc_sc) {
+		pr_err("icc: not ready\n");
+		return -EAGAIN;
+	}
+	ret = _apcie_icc_cmd(icc_sc, major, minor, data, length, reply, reply_length,
+		       false);
+	mutex_unlock(&icc_mutex);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(apcie_icc_cmd);
+
+void resetUsbPort(void)
+{
+	u8 off = 0, on = 1;
+	u8 resp[20];
+	int ret;
+	
+	//Turn OFF Usb
+	ret = apcie_icc_cmd(5, 0x10, &off, sizeof(off), resp, 20);
+	printk("Turn OFF USB: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn off USB failed!");
+		return;
+	}
+	
+	//Turn ON Usb
+	ret = apcie_icc_cmd(5, 0x10, &on, sizeof(on), resp, 20);
+	printk("Turn ON USB: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn on USB failed");
+		return;
+	}
+}
+
+void resetBtWlan(void)
+{
+	u8 off = 2, on = 3;
+	u8 resp[20];
+	int ret;
+	
+
+	/* Get bt/wlan status */
+//	ret = apcie_icc_cmd(5, 1, NULL, 0, resp, 20);
+//	printk("BT/WLAN status: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+
+	/** Turn off is done from linux-loader actually, if you want you can remove it from linux-loader and done it here **/
+	
+	//Turn OFF bt/wlan
+/*	ret = apcie_icc_cmd(5, 0, &off, sizeof(off), resp, 20);
+	printk("Turn OFF BT/WLAN: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn off bt/wlan failed!");
+		return;
+	}
+*/
+
+	//Turn ON bt/wlan
+	ret = apcie_icc_cmd(5, 0, &on, sizeof(on), resp, 20);
+	printk("Turn ON BT/WLAN: ret=%d, reply %02x %02x %02x %02x", ret, resp[0], resp[1], resp[2], resp[3]);
+	if(ret < 0)
+	{
+		printk("Turn on bt/wlan failed");
+		return;
+	}
+}
+
+void do_icc_init(void) {
+	u8 svc = 0x10;
+	u8 reply[0x30];
+	static const u8 led_config[] = {
+		3, 1, 0, 0,
+			0x10, 1, /* Blue: on */
+				2, 0xff, 2, 1, 0x00,
+			0x11, 1, /* White: off */
+				2, 0x00, 2, 1, 0x00,
+			0x02, 3, /* Orange: delay and pulse, loop forever */
+				1, 0x00, 4, 1, 0xbf,
+				2, 0xff, 5, 1, 0xff,
+				2, 0x00, 5, 1, 0xff,
+	};
+	int ret;
+	// test: get FW version
+	ret = apcie_icc_cmd(2, 6, NULL, 0, reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+	ret = apcie_icc_cmd(1, 0, &svc, 1, reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+
+	/* Set the LED to something nice */
+	ret = apcie_icc_cmd(9, 0x20, led_config, ARRAY_SIZE(led_config), reply, 0x30);
+	printk("ret=%d, reply %02x %02x %02x %02x %02x %02x %02x %02x\n", ret,
+		reply[0], reply[1], reply[2], reply[3],
+		reply[4], reply[5], reply[6], reply[7]);
+}
+
+static void icc_shutdown(void)
+{
+	uint8_t command[] = {
+		0, 0, 2, 0, 1, 0
+	};
+	if (apcie_status() != 1)
+		return;
+	apcie_icc_cmd(4, 1, command, sizeof(command), NULL, 0);
+	mdelay(3000);
+	WARN_ON(1);
+}
+
+void icc_reboot(void)
+{
+	uint8_t command[] = {
+		0, 1, 2, 0, 1, 0
+	};
+	if (apcie_status() != 1)
+		return;
+	apcie_icc_cmd(4, 1, command, sizeof(command), NULL, 0);
+	mdelay(3000);
+	WARN_ON(1);
+}
+
+static void *ioctl_tmp_buf = NULL;
+
+ static long icc_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
+ {
+ 	int ret;
+ 	void __user *uap = (void __user *)arg;
+ 	switch (cmd) {
+ 	case ICC_IOCTL_CMD: {
+ 		struct icc_cmd cmd;
+ 		int reply_len;
+ 		ret = copy_from_user(&cmd, uap, sizeof(cmd));
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		ret = copy_from_user(ioctl_tmp_buf, cmd.data, cmd.length);
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		reply_len = apcie_icc_cmd(cmd.major, cmd.minor, ioctl_tmp_buf,
+ 			cmd.length, ioctl_tmp_buf, cmd.reply_length);
+ 		if (reply_len < 0) {
+ 			ret = reply_len;
+ 			break;
+ 		}
+ 		ret = copy_to_user(cmd.reply, ioctl_tmp_buf, cmd.reply_length);
+ 		if (ret) {
+ 			ret = -EFAULT;
+ 			break;
+ 		}
+ 		ret = reply_len;
+ 		} break;
+ 	default:
+ 		ret = -ENOENT;
+ 		break;
+ 	}
+ 	return ret;
+ }
+
+ static const struct file_operations icc_fops = {
+ 	.owner = THIS_MODULE,
+ 	.unlocked_ioctl = icc_ioctl,
+ };
+
+
+int apcie_icc_init(struct apcie_dev *sc)
+{
+	int ret;
+	unsigned int mem_devfn = PCI_DEVFN(PCI_SLOT(sc->pdev->devfn), AEOLIA_FUNC_ID_MEM);
+	struct pci_dev *mem_dev;
+	u32 req_empty, req_full;
+
+	/* ICC makes use of a segment of SPM memory, available via a different
+	 * PCI function in Aeolia, so we need to get a handle to it. */
+	mem_dev = pci_get_slot(sc->pdev->bus, mem_devfn);
+	if (!mem_dev) {
+		sc_err("icc: could not get handle to mem device\n");
+		return -ENODEV;
+	}
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 4) +
+				APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE,
+				"apcie.icc")) {
+		sc_err("icc: failed to request ICC register region\n");
+		return -EBUSY;
+	}
+
+	sc->icc.spm_base = pci_resource_start(mem_dev, 5) + APCIE_SPM_ICC_BASE;
+	if (!request_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE,
+				"spm.icc")) {
+		sc_err("icc: failed to request ICC SPM region\n");
+		ret = -EBUSY;
+		goto release_icc;
+	}
+
+	sc->icc.spm = ioremap(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+	if (!sc->icc.spm) {
+		sc_err("icc: failed to map ICC portion of SPM\n");
+		ret = -EIO;
+		goto release_spm;
+	}
+
+	spin_lock_init(&sc->icc.reply_lock);
+	init_waitqueue_head(&sc->icc.wq);
+
+	/* Clear flags */
+	iowrite32(APCIE_ICC_SEND | APCIE_ICC_ACK,
+		  sc->bar4 + APCIE_REG_ICC_STATUS);
+
+	ret = request_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC),
+			  icc_interrupt, IRQF_SHARED, "icc", sc);
+	if (ret) {
+		sc_err("icc: could not request IRQ: %d\n", ret);
+		goto iounmap;
+	}
+
+	req_empty = ioread32(REQUEST + BUF_EMPTY);
+	req_full = ioread32(REQUEST + BUF_FULL);
+
+	if (req_empty != 1 || req_full != 0) {
+		sc_err("icc: request buffer is busy: empty=%d full=%d\n",
+		       req_empty, req_full);
+		ret = -EIO;
+		goto free_irq;
+	}
+
+	mutex_lock(&icc_mutex);
+	icc_sc = sc;
+
+	/* Enable IRQs */
+	iowrite32(APCIE_ICC_SEND | APCIE_ICC_ACK,
+		  sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	mutex_unlock(&icc_mutex);
+
+	ret = icc_i2c_init(sc);
+	if (ret) {
+		sc_err("icc: i2c init failed: %d\n", ret);
+		goto unassign_global;
+	}
+	
+	resetBtWlan();
+//	resetUsbPort();
+	
+	ret = icc_pwrbutton_init(sc);
+	/* Not fatal */
+	if (ret)
+		sc_err("icc: pwrbutton init failed: %d\n", ret);
+
+	do_icc_init();
+	pm_power_off = &icc_shutdown;
+
+	ioctl_tmp_buf = kzalloc(1 << 16, GFP_KERNEL);
+ 	if (!ioctl_tmp_buf) {
+ 		sc_err("icc: alloc ioctl_tmp_buf failed\n");
+ 		goto done;
+ 	}
+ 	ret = register_chrdev(ICC_MAJOR, "icc", &icc_fops);
+ 	if (ret) {
+ 		sc_err("icc: register_chrdev failed: %d\n", ret);
+ 		goto done;
+ 	}
+ done:
+
+	return 0;
+
+unassign_global:
+	mutex_lock(&icc_mutex);
+	iowrite32(0, sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	icc_sc = NULL;
+	mutex_unlock(&icc_mutex);
+free_irq:
+	free_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC), sc);
+iounmap:
+	iounmap(sc->icc.spm);
+release_spm:
+	release_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+release_icc:
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE);
+	return ret;
+}
+
+void apcie_icc_remove(struct apcie_dev *sc)
+{
+	sc_err("apcie_icc_remove: shouldn't normally be called\n");
+	pm_power_off = NULL;
+	icc_pwrbutton_remove(sc);
+	icc_i2c_remove(sc);
+	mutex_lock(&icc_mutex);
+	iowrite32(0, sc->bar4 + APCIE_REG_ICC_IRQ_MASK);
+	icc_sc = NULL;
+	mutex_unlock(&icc_mutex);
+	free_irq(apcie_irqnum(sc, APCIE_SUBFUNC_ICC), sc);
+	iounmap(sc->icc.spm);
+	release_mem_region(sc->icc.spm_base, APCIE_SPM_ICC_SIZE);
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_ICC_BASE, APCIE_RGN_ICC_SIZE);
+}
+
+#ifdef CONFIG_PM
+void apcie_icc_suspend(struct apcie_dev *sc, pm_message_t state)
+{
+}
+
+void apcie_icc_resume(struct apcie_dev *sc)
+{
+}
+#endif
diff --git a/drivers/ps4/ps4-apcie-pwrbutton.c b/drivers/ps4/ps4-apcie-pwrbutton.c
new file mode 100644
index 000000000000..d695221703b5
--- /dev/null
+++ b/drivers/ps4/ps4-apcie-pwrbutton.c
@@ -0,0 +1,69 @@
+#include <linux/input.h>
+#include "aeolia.h"
+
+void icc_pwrbutton_trigger(struct apcie_dev *sc, int state)
+{
+	if (sc->icc.pwrbutton_dev) {
+		input_report_key(sc->icc.pwrbutton_dev, KEY_POWER, state ? 1 : 0);
+		input_sync(sc->icc.pwrbutton_dev);
+	}
+}
+
+int icc_pwrbutton_init(struct apcie_dev *sc)
+{
+	int ret = 0;
+	u16 button;
+	struct input_dev *dev;
+
+	dev = input_allocate_device();
+	if (!dev) {
+		sc_err("%s: Not enough memory.\n", __func__);
+		return -ENOMEM;
+	}
+
+	set_bit(EV_KEY, dev->evbit);
+	set_bit(KEY_POWER, dev->keybit);
+
+	dev->name = "Power Button";
+	dev->id.bustype = BUS_HOST;
+
+	/* this makes the button look like an acpi power button
+	 * no clue whether anyone relies on that though */
+	dev->id.product = 0x02;
+	dev->phys = "LNXPWRBN/button/input0";
+
+	dev->dev.parent = &sc->pdev->dev;
+	ret = input_register_device(dev);
+	if (ret) {
+		sc_err("%s: Failed to register device\n", __func__);
+		input_free_device(dev);
+		return ret;
+	}
+
+	sc->icc.pwrbutton_dev = dev;
+
+	// enable power button notifications
+	button = 0x100;
+	ret = apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
+	if (ret < 0) {
+		sc_info("%s: Failed to enable power notifications (%d)\n",
+			__func__, ret);
+	}
+
+	// enable reset button notifications (?)
+	button = 0x102;
+	ret = apcie_icc_cmd(8, 1, &button, sizeof(button), NULL, 0);
+	if (ret < 0) {
+		sc_info("%s: Failed to enable reset notifications (%d)\n",
+		        __func__, ret);
+	}
+
+	return 0;
+}
+
+void icc_pwrbutton_remove(struct apcie_dev *sc)
+{
+	if (sc->icc.pwrbutton_dev)
+		input_free_device(sc->icc.pwrbutton_dev);
+	sc->icc.pwrbutton_dev = NULL;
+}
diff --git a/drivers/ps4/ps4-apcie-uart.c b/drivers/ps4/ps4-apcie-uart.c
new file mode 100644
index 000000000000..6dd6dc195735
--- /dev/null
+++ b/drivers/ps4/ps4-apcie-uart.c
@@ -0,0 +1,67 @@
+#include <linux/serial_8250.h>
+#include <linux/serial_core.h>
+#include <linux/serial_reg.h>
+
+#include "aeolia.h"
+
+void apcie_uart_remove(struct apcie_dev *sc);
+
+int apcie_uart_init(struct apcie_dev *sc)
+{
+	int i;
+	struct uart_8250_port uart;
+
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		sc->serial_line[i] = -1;
+	}
+
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		uint32_t off = APCIE_RGN_UART_BASE + (i << 12);
+		memset(&uart, 0, sizeof(uart));
+		uart.port.irq		= apcie_irqnum(sc, APCIE_SUBFUNC_UART0 + i);
+		uart.port.uartclk	= 58500000;
+		uart.port.flags		= UPF_SHARE_IRQ;
+		uart.port.iotype	= UPIO_MEM32;
+		uart.port.mapbase	= pci_resource_start(sc->pdev, 4) + off;
+		uart.port.membase	= sc->bar4 + off;
+		uart.port.regshift	= 2;
+		uart.port.dev		= &sc->pdev->dev;
+
+		sc->serial_line[i] = serial8250_register_8250_port(&uart);
+		if (sc->serial_line[i] < 0) {
+			sc_err("Failed to register serial port %d\n", i);
+			apcie_uart_remove(sc);
+			return -EIO;
+		}
+	}
+	return 0;
+}
+
+void apcie_uart_remove(struct apcie_dev *sc)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++) {
+		if (sc->serial_line[i] >= 0) {
+			serial8250_unregister_port(sc->serial_line[i]);
+			sc->serial_line[i] = -1;
+		}
+	}
+}
+
+#ifdef CONFIG_PM
+void apcie_uart_suspend(struct apcie_dev *sc, pm_message_t state)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++)
+		if (sc->serial_line[i] >= 0)
+			serial8250_suspend_port(sc->serial_line[i]);
+}
+
+void apcie_uart_resume(struct apcie_dev *sc)
+{
+	int i;
+	for (i = 0; i < APCIE_NR_UARTS; i++)
+		if (sc->serial_line[i] >= 0)
+			serial8250_resume_port(sc->serial_line[i]);
+}
+#endif
diff --git a/drivers/ps4/ps4-apcie.c b/drivers/ps4/ps4-apcie.c
new file mode 100644
index 000000000000..d5e87d1ee74e
--- /dev/null
+++ b/drivers/ps4/ps4-apcie.c
@@ -0,0 +1,560 @@
+#define DEBUG
+
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include <linux/pci.h>
+#include <linux/init.h>
+#include <linux/irq.h>
+#include <linux/irqchip.h>
+#include <linux/irqdomain.h>
+#include <linux/msi.h>
+#include <asm/apic.h>
+#include <asm/irqdomain.h>
+#include <asm/irq_remapping.h>
+
+#include <asm/msi.h>
+
+#include <asm/ps4.h>
+
+#include "aeolia.h"
+
+/* #define QEMU_HACK_NO_IOMMU */
+
+/* Number of implemented MSI registers per function */
+static const int subfuncs_per_func[AEOLIA_NUM_FUNCS] = {
+	4, 4, 4, 4, 31, 2, 2, 4
+};
+
+static inline u32 glue_read32(struct apcie_dev *sc, u32 offset) {
+	return ioread32(sc->bar4 + offset);
+}
+
+static inline void glue_write32(struct apcie_dev *sc, u32 offset, u32 value) {
+	iowrite32(value, sc->bar4 + offset);
+}
+
+static inline void glue_set_region(struct apcie_dev *sc, u32 func, u32 bar,
+			    u32 base, u32 mask) {
+	glue_write32(sc, APCIE_REG_BAR_MASK(func, bar), mask);
+	glue_write32(sc, APCIE_REG_BAR_ADDR(func, bar), base);
+}
+
+static inline void glue_set_mask(struct apcie_dev *sc, u32 offset, u32 mask) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32(ioread32(ptr) | mask, ptr);
+}
+
+static inline void glue_clear_mask(struct apcie_dev *sc, u32 offset, u32 mask) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32(ioread32(ptr) & ~mask, ptr);
+}
+
+static inline void glue_mask_and_set(struct apcie_dev *sc, u32 offset, u32 mask, u32 set) {
+	void __iomem *ptr = sc->bar4 + offset;
+	iowrite32((ioread32(ptr) & ~mask) | set, ptr);
+}
+
+static void apcie_config_msi(struct apcie_dev *sc, u32 func, u32 subfunc,
+			     u32 addr, u32 data) {
+	u32 offset;
+
+	sc_dbg("apcie_config_msi: func: %u, subfunc: %u, addr %08x data: 0x%08x (%u)\n",
+		func, subfunc, addr, data, data);
+
+	glue_clear_mask(sc, APCIE_REG_MSI_CONTROL, APCIE_REG_MSI_CONTROL_ENABLE);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0x8), 0xffffffff);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0xc + (func << 2)), 0xB7FFFF00 + func * 16);
+	glue_write32(sc, APCIE_REG_MSI_ADDR(func), addr);
+	/* Unknown */
+	glue_write32(sc, APCIE_REG_MSI(0xcc + (func << 2)), 0);
+	glue_write32(sc, APCIE_REG_MSI_DATA_HI(func), data & 0xffe0);
+
+	if (func < 4) {
+		/* First 4 functions have 4 IRQs/subfuncs each */
+		offset = (func << 4) | (subfunc << 2);
+	} else if (func == 4) {
+		/* Function 4 gets 24 consecutive slots,
+		 * then 7 more at the end. */
+		if (subfunc < 24)
+			offset = 0x40 + (subfunc << 2);
+		else
+			offset = 0xe0 + ((subfunc - 24) << 2);
+	} else {
+		offset = 0xa0 + ((func - 5) << 4) + (subfunc << 2);
+	}
+	glue_write32(sc, APCIE_REG_MSI_DATA_LO(offset), data & 0x1f);
+
+	if (func == AEOLIA_FUNC_ID_PCIE)
+		glue_set_mask(sc, APCIE_REG_MSI_MASK(func), APCIE_REG_MSI_MASK_FUNC4);
+	else
+		glue_set_mask(sc, APCIE_REG_MSI_MASK(func), APCIE_REG_MSI_MASK_FUNC);
+
+	glue_set_mask(sc, APCIE_REG_MSI_CONTROL, APCIE_REG_MSI_CONTROL_ENABLE);
+}
+
+static void apcie_msi_write_msg(struct irq_data *data, struct msi_msg *msg)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+	u32 subfunc = data->hwirq & 0xff;
+
+	/* Linux likes to unconfigure MSIs like this, but since we share the
+	 * address between subfunctions, we can't do that. The IRQ should be
+	 * masked via apcie_msi_mask anyway, so just do nothing. */
+	if (!msg->address_lo) {
+		return;
+	}
+
+	sc_dbg("apcie_msi_write_msg(%08x, %08x) mask=0x%x irq=%d hwirq=0x%lx %p\n",
+	       msg->address_lo, msg->data, data->mask, data->irq, data->hwirq, sc);
+
+	if (subfunc == 0xff) {
+		int i;
+		for (i = 0; i < subfuncs_per_func[func]; i++)
+			apcie_config_msi(sc, func, i, msg->address_lo, msg->data);
+	} else {
+		apcie_config_msi(sc, func, subfunc, msg->address_lo, msg->data);
+	}
+}
+
+static void apcie_msi_unmask(struct irq_data *data)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+
+	glue_set_mask(sc, APCIE_REG_MSI_MASK(func), data->mask);
+}
+
+static void apcie_msi_mask(struct irq_data *data)
+{
+	struct apcie_dev *sc = data->chip_data;
+	u32 func = data->hwirq >> 8;
+
+	glue_clear_mask(sc, APCIE_REG_MSI_MASK(func), data->mask);
+}
+
+static void apcie_msi_calc_mask(struct irq_data *data) {
+	u32 func = data->hwirq >> 8;
+	u32 subfunc = data->hwirq & 0xff;
+
+	if (subfunc == 0xff) {
+		data->mask = (1 << subfuncs_per_func[func]) - 1;
+	} else {
+		data->mask = 1 << subfunc;
+	}
+}
+
+static void apcie_irq_msi_compose_msg(struct irq_data *data,
+				       struct msi_msg *msg)
+{
+       __irq_msi_compose_msg(irqd_cfg(data), msg, false);
+}
+
+
+static struct irq_chip apcie_msi_controller = {
+	.name = "Aeolia-MSI",
+	.irq_unmask = apcie_msi_unmask,
+	.irq_mask = apcie_msi_mask,
+	.irq_ack = irq_chip_ack_parent,
+	.irq_set_affinity = msi_domain_set_affinity,
+	.irq_retrigger = irq_chip_retrigger_hierarchy,
+	.irq_compose_msi_msg = apcie_irq_msi_compose_msg,
+	.irq_write_msi_msg = apcie_msi_write_msg,
+	.flags = IRQCHIP_SKIP_SET_WAKE,
+};
+
+static irq_hw_number_t apcie_msi_get_hwirq(struct msi_domain_info *info,
+					  msi_alloc_info_t *arg)
+{
+	return arg->hwirq;
+}
+
+static int apcie_msi_init(struct irq_domain *domain,
+			 struct msi_domain_info *info, unsigned int virq,
+			 irq_hw_number_t hwirq, msi_alloc_info_t *arg)
+{
+	struct irq_data *data;
+	pr_devel("apcie_msi_init(%p, %p, %d, 0x%lx, %p)\n", domain, info, virq, hwirq, arg);
+
+	data = irq_domain_get_irq_data(domain, virq);
+	irq_domain_set_info(domain, virq, hwirq, info->chip, info->chip_data,
+			    handle_edge_irq, NULL, "edge");
+	apcie_msi_calc_mask(data);
+	return 0;
+}
+
+static void apcie_msi_free(struct irq_domain *domain,
+			  struct msi_domain_info *info, unsigned int virq)
+{
+	pr_devel("apcie_msi_free(%d)\n", virq);
+}
+
+int apcie_msi_prepare(struct irq_domain *domain, struct device *dev, int nvec,
+		     msi_alloc_info_t *arg)
+{
+	init_irq_alloc_info(arg, NULL);
+
+	arg->type = X86_IRQ_ALLOC_TYPE_PCI_MSI;
+	arg->flags |= MSI_FLAG_MULTI_PCI_MSI;
+
+	return 0;
+}
+
+static struct msi_domain_ops apcie_msi_domain_ops = {
+	.get_hwirq	= apcie_msi_get_hwirq,
+	.msi_prepare	= apcie_msi_prepare,
+	.msi_init	= apcie_msi_init,
+	.msi_free	= apcie_msi_free,
+};
+
+static struct msi_domain_info apcie_msi_domain_info = {
+	.flags		= MSI_FLAG_USE_DEF_DOM_OPS | MSI_FLAG_USE_DEF_CHIP_OPS,
+	.ops		= &apcie_msi_domain_ops,
+	.chip		= &apcie_msi_controller,
+	.handler	= handle_edge_irq,
+	.handler_name	= "edge"
+};
+
+static struct irq_domain *apcie_create_irq_domain(struct apcie_dev *sc)
+{
+	struct irq_domain *domain;
+	struct fwnode_handle *fn;
+
+	sc_dbg("apcie_create_irq_domain\n");
+	if (x86_vector_domain == NULL)
+		return NULL;
+
+	apcie_msi_domain_info.chip_data = (void *)sc;
+	apcie_msi_domain_info.flags |= MSI_FLAG_MULTI_PCI_MSI;
+	apcie_msi_controller.name = "IR-Aeolia-MSI";
+
+	fn = irq_domain_alloc_named_fwnode(apcie_msi_controller.name);
+	if (!fn)
+		return NULL;
+	domain = pci_msi_create_irq_domain(fn, &apcie_msi_domain_info,
+				      x86_vector_domain);
+
+	if (!domain) {
+		irq_domain_free_fwnode(fn);
+		pr_warn("Failed to initialize IR-Aeolia-MSI irqdomain.\n");
+	} else {
+		domain->flags |= IRQ_DOMAIN_MSI_NOMASK_QUIRK;
+	}
+
+	return domain;
+}
+
+static int apcie_is_compatible_device(struct pci_dev *dev)
+{
+	if (!dev || dev->vendor != PCI_VENDOR_ID_SONY) {
+		return 0;
+	}
+	return (dev->device == PCI_DEVICE_ID_SONY_AEOLIA_PCIE ||
+		dev->device == PCI_DEVICE_ID_SONY_BELIZE_PCIE ||
+		dev->device == PCI_DEVICE_ID_SONY_BAIKAL_PCIE);
+}
+
+int apcie_assign_irqs(struct pci_dev *dev, int nvec)
+{
+	int ret;
+	unsigned int sc_devfn;
+	struct pci_dev *sc_dev;
+	struct apcie_dev *sc;
+	struct irq_alloc_info info;
+
+	sc_devfn = (dev->devfn & ~7) | AEOLIA_FUNC_ID_PCIE;
+	sc_dev = pci_get_slot(dev->bus, sc_devfn);
+
+	if (!apcie_is_compatible_device(sc_dev)) {
+		dev_err(&dev->dev, "apcie: this is not an Aeolia device\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+	sc = pci_get_drvdata(sc_dev);
+	if (!sc) {
+		dev_err(&dev->dev, "apcie: not ready yet, cannot assign IRQs\n");
+		ret = -ENODEV;
+		goto fail;
+	}
+
+	init_irq_alloc_info(&info, NULL);
+	info.type = X86_IRQ_ALLOC_TYPE_PCI_MSI;
+	/* IRQs "come from" function 4 as far as the IOMMU/system see */
+	//info.msi_dev = sc->pdev;
+	/* Our hwirq number is function << 8 plus subfunction.
+	 * Subfunction is usually 0 and implicitly increments per hwirq,
+	 * but can also be 0xff to indicate that this is a shared IRQ. */
+	//https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=3b9c1d377d67072d1d8a2373b4969103cca00dab
+	info.hwirq = PCI_FUNC(dev->devfn) << 8;
+
+	dev_dbg(&dev->dev, "apcie_assign_irqs(%d)\n", nvec);
+
+#ifndef QEMU_HACK_NO_IOMMU
+	info.flags = X86_IRQ_ALLOC_CONTIGUOUS_VECTORS;
+	if (!(apcie_msi_domain_info.flags & MSI_FLAG_MULTI_PCI_MSI)) {
+		nvec = 1;
+		info.hwirq |= 0xff; /* Shared IRQ for all subfunctions */
+	}
+#endif
+
+	ret = irq_domain_alloc_irqs(sc->irqdomain, nvec, NUMA_NO_NODE, &info);
+	if (ret >= 0) {
+		dev->irq = ret;
+		ret = nvec;
+	}
+
+fail:
+	dev_dbg(&dev->dev, "apcie_assign_irqs returning %d\n", ret);
+	if (sc_dev)
+		pci_dev_put(sc_dev);
+	return ret;
+}
+EXPORT_SYMBOL(apcie_assign_irqs);
+
+void apcie_free_irqs(unsigned int virq, unsigned int nr_irqs)
+{
+	irq_domain_free_irqs(virq, nr_irqs);
+}
+EXPORT_SYMBOL(apcie_free_irqs);
+
+static void apcie_glue_remove(struct apcie_dev *sc);
+
+static int apcie_glue_init(struct apcie_dev *sc)
+{
+	int i;
+
+	sc_info("apcie glue probe\n");
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 4) +
+				APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE,
+				"apcie.glue")) {
+		sc_err("Failed to request pcie region\n");
+		return -EBUSY;
+
+	}
+
+	if (!request_mem_region(pci_resource_start(sc->pdev, 2) +
+				APCIE_RGN_CHIPID_BASE, APCIE_RGN_CHIPID_SIZE,
+				"apcie.chipid")) {
+		sc_err("Failed to request chipid region\n");
+		release_mem_region(pci_resource_start(sc->pdev, 4) +
+				   APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE);
+		return -EBUSY;
+	}
+
+	glue_set_region(sc, AEOLIA_FUNC_ID_PCIE, 2, 0xbf018000, 0x7fff);
+
+	sc_info("Aeolia chip revision: %08x:%08x:%08x\n",
+		ioread32(sc->bar2 + APCIE_REG_CHIPID_0),
+		ioread32(sc->bar2 + APCIE_REG_CHIPID_1),
+		ioread32(sc->bar2 + APCIE_REG_CHIPREV));
+
+	/* Mask all MSIs first, to avoid spurious IRQs */
+	for (i = 0; i < AEOLIA_NUM_FUNCS; i++) {
+		glue_write32(sc, APCIE_REG_MSI_MASK(i), 0);
+		glue_write32(sc, APCIE_REG_MSI_ADDR(i), 0);
+		glue_write32(sc, APCIE_REG_MSI_DATA_HI(i), 0);
+	}
+
+	for (i = 0; i < 0xfc; i += 4)
+		glue_write32(sc, APCIE_REG_MSI_DATA_LO(i), 0);
+
+	glue_set_region(sc, AEOLIA_FUNC_ID_GBE, 0, 0xbfa00000, 0x3fff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_AHCI, 5, 0xbfa04000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_SDHCI, 0, 0xbfa80000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_SDHCI, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 0, 0xbfa05000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 2, 0xbfa06000, 0xfff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_DMAC, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_MEM, 2, 0xc0000000, 0x3fffffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_MEM, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 0, 0xbf400000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 1, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 2, 0xbf600000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 3, 0, 0);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 4, 0xbf800000, 0x1fffff);
+	glue_set_region(sc, AEOLIA_FUNC_ID_XHCI, 5, 0, 0);
+
+	sc->irqdomain = apcie_create_irq_domain(sc);
+	if (!sc->irqdomain) {
+		sc_err("Failed to create IRQ domain");
+		apcie_glue_remove(sc);
+		return -EIO;
+	}
+	sc->nvec = apcie_assign_irqs(sc->pdev, APCIE_NUM_SUBFUNC);
+	if (sc->nvec <= 0) {
+		sc_err("Failed to assign IRQs");
+		apcie_glue_remove(sc);
+		return -EIO;
+	}
+	sc_dbg("dev->irq=%d\n", sc->pdev->irq);
+
+	return 0;
+}
+
+static void apcie_glue_remove(struct apcie_dev *sc) {
+	sc_info("apcie glue remove\n");
+
+	if (sc->nvec > 0) {
+		apcie_free_irqs(sc->pdev->irq, sc->nvec);
+		sc->nvec = 0;
+	}
+	if (sc->irqdomain) {
+		irq_domain_remove(sc->irqdomain);
+		sc->irqdomain = NULL;
+	}
+	release_mem_region(pci_resource_start(sc->pdev, 2) +
+			   APCIE_RGN_CHIPID_BASE, APCIE_RGN_CHIPID_SIZE);
+	release_mem_region(pci_resource_start(sc->pdev, 4) +
+			   APCIE_RGN_PCIE_BASE, APCIE_RGN_PCIE_SIZE);
+}
+
+#ifdef CONFIG_PM
+static int apcie_glue_suspend(struct apcie_dev *sc, pm_message_t state) {
+	return 0;
+}
+
+static int apcie_glue_resume(struct apcie_dev *sc) {
+	return 0;
+}
+#endif
+
+
+int apcie_uart_init(struct apcie_dev *sc);
+int apcie_icc_init(struct apcie_dev *sc);
+void apcie_uart_remove(struct apcie_dev *sc);
+void apcie_icc_remove(struct apcie_dev *sc);
+#ifdef CONFIG_PM
+void apcie_uart_suspend(struct apcie_dev *sc, pm_message_t state);
+void apcie_icc_suspend(struct apcie_dev *sc, pm_message_t state);
+void apcie_uart_resume(struct apcie_dev *sc);
+void apcie_icc_resume(struct apcie_dev *sc);
+#endif
+
+/* From arch/x86/platform/ps4/ps4.c */
+extern bool apcie_initialized;
+
+static int apcie_probe(struct pci_dev *dev, const struct pci_device_id *id) {
+	struct apcie_dev *sc;
+	int ret;
+
+	dev_dbg(&dev->dev, "apcie_probe()\n");
+
+	ret = pci_enable_device(dev);
+	if (ret) {
+		dev_err(&dev->dev,
+			"apcie_probe(): pci_enable_device failed: %d\n", ret);
+		return ret;
+	}
+
+	sc = kzalloc(sizeof(*sc), GFP_KERNEL);
+	if (!sc) {
+		dev_err(&dev->dev, "apcie_probe(): alloc sc failed\n");
+		ret = -ENOMEM;
+		goto disable_dev;
+	}
+	sc->pdev = dev;
+	pci_set_drvdata(dev, sc);
+
+	// eMMC ... unused?
+	sc->bar0 = pci_ioremap_bar(dev, 0);
+	// pervasive 0
+	sc->bar2 = pci_ioremap_bar(dev, 2);
+	// pervasive 1 - misc peripherals
+	sc->bar4 = pci_ioremap_bar(dev, 4);
+
+	if (!sc->bar0 || !sc->bar2 || !sc->bar4) {
+		sc_err("failed to map some BARs, bailing out\n");
+		ret = -EIO;
+		goto free_bars;
+	}
+
+	if ((ret = apcie_glue_init(sc)) < 0)
+		goto free_bars;
+	if ((ret = apcie_uart_init(sc)) < 0)
+		goto remove_glue;
+	if ((ret = apcie_icc_init(sc)) < 0)
+		goto remove_uart;
+
+	apcie_initialized = true;
+	return 0;
+
+remove_uart:
+	apcie_uart_remove(sc);
+remove_glue:
+	apcie_glue_remove(sc);
+free_bars:
+	if (sc->bar0)
+		iounmap(sc->bar0);
+	if (sc->bar2)
+		iounmap(sc->bar2);
+	if (sc->bar4)
+		iounmap(sc->bar4);
+	kfree(sc);
+disable_dev:
+	pci_disable_device(dev);
+	return ret;
+}
+
+static void apcie_remove(struct pci_dev *dev) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_remove(sc);
+	apcie_uart_remove(sc);
+	apcie_glue_remove(sc);
+
+	if (sc->bar0)
+		iounmap(sc->bar0);
+	if (sc->bar2)
+		iounmap(sc->bar2);
+	if (sc->bar4)
+		iounmap(sc->bar4);
+	kfree(sc);
+	pci_disable_device(dev);
+}
+
+#ifdef CONFIG_PM
+static int apcie_suspend(struct pci_dev *dev, pm_message_t state) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_suspend(sc, state);
+	apcie_uart_suspend(sc, state);
+	apcie_glue_suspend(sc, state);
+	return 0;
+}
+
+static int apcie_resume(struct pci_dev *dev) {
+	struct apcie_dev *sc;
+	sc = pci_get_drvdata(dev);
+
+	apcie_icc_resume(sc);
+	apcie_glue_resume(sc);
+	apcie_uart_resume(sc);
+	return 0;
+}
+#endif
+
+static const struct pci_device_id apcie_pci_tbl[] = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_AEOLIA_PCIE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BELIZE_PCIE), },
+	{ PCI_DEVICE(PCI_VENDOR_ID_SONY, PCI_DEVICE_ID_SONY_BAIKAL_PCIE), },
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, apcie_pci_tbl);
+
+static struct pci_driver apcie_driver = {
+	.name		= "aeolia_pcie",
+	.id_table	= apcie_pci_tbl,
+	.probe		= apcie_probe,
+	.remove		= apcie_remove,
+#ifdef CONFIG_PM
+	.suspend	= apcie_suspend,
+	.resume		= apcie_resume,
+#endif
+};
+module_pci_driver(apcie_driver);
diff --git a/include/linux/pci_ids.h b/include/linux/pci_ids.h
index 8a1e26473566..9c62f14fad84 100644
--- a/include/linux/pci_ids.h
+++ b/include/linux/pci_ids.h
@@ -551,6 +551,8 @@
 #define PCI_DEVICE_ID_AMD_16H_NB_F4	0x1534
 #define PCI_DEVICE_ID_AMD_16H_M30H_NB_F3 0x1583
 #define PCI_DEVICE_ID_AMD_16H_M30H_NB_F4 0x1584
+#define PCI_DEVICE_ID_AMD_16H_M41H_F3  0x1431
+#define PCI_DEVICE_ID_AMD_16H_M41H_F4  0x1432
 #define PCI_DEVICE_ID_AMD_17H_DF_F3	0x1463
 #define PCI_DEVICE_ID_AMD_17H_M10H_DF_F3 0x15eb
 #define PCI_DEVICE_ID_AMD_17H_M30H_DF_F3 0x1493
@@ -893,6 +895,30 @@
 #define PCI_DEVICE_ID_TI_DRA72x		0xb501
 
 #define PCI_VENDOR_ID_SONY		0x104d
+#define PCI_DEVICE_ID_SONY_AEOLIA_ACPI	0x908f
+#define PCI_DEVICE_ID_SONY_AEOLIA_GBE	0x909e
+#define PCI_DEVICE_ID_SONY_AEOLIA_AHCI	0x909f
+#define PCI_DEVICE_ID_SONY_AEOLIA_SDHCI	0x90a0
+#define PCI_DEVICE_ID_SONY_AEOLIA_PCIE	0x90a1
+#define PCI_DEVICE_ID_SONY_AEOLIA_DMAC	0x90a2
+#define PCI_DEVICE_ID_SONY_AEOLIA_MEM	0x90a3
+#define PCI_DEVICE_ID_SONY_AEOLIA_XHCI	0x90a4
+#define PCI_DEVICE_ID_SONY_BELIZE_ACPI	0x90c8
+#define PCI_DEVICE_ID_SONY_BELIZE_GBE	0x90c9
+#define PCI_DEVICE_ID_SONY_BELIZE_AHCI	0x90ca
+#define PCI_DEVICE_ID_SONY_BELIZE_SDHCI	0x90cb
+#define PCI_DEVICE_ID_SONY_BELIZE_PCIE	0x90cc
+#define PCI_DEVICE_ID_SONY_BELIZE_DMAC	0x90cd
+#define PCI_DEVICE_ID_SONY_BELIZE_MEM	0x90ce
+#define PCI_DEVICE_ID_SONY_BELIZE_XHCI	0x90cf
+#define PCI_DEVICE_ID_SONY_BAIKAL_ACPI	0x90d7
+#define PCI_DEVICE_ID_SONY_BAIKAL_GBE	0x90d8
+#define PCI_DEVICE_ID_SONY_BAIKAL_AHCI	0x90d9
+#define PCI_DEVICE_ID_SONY_BAIKAL_SDHCI	0x90da
+#define PCI_DEVICE_ID_SONY_BAIKAL_PCIE	0x90db
+#define PCI_DEVICE_ID_SONY_BAIKAL_DMAC	0x90dc
+#define PCI_DEVICE_ID_SONY_BAIKAL_MEM	0x90dd
+#define PCI_DEVICE_ID_SONY_BAIKAL_XHCI	0x90de
 
 /* Winbond have two vendor IDs! See 0x10ad as well */
 #define PCI_VENDOR_ID_WINBOND2		0x1050
-- 
2.45.1

