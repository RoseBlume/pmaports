From dc3a4684ee5dde8df325a4f94af3d2ca6a248736 Mon Sep 17 00:00:00 2001
From: codedwrench <rick.04.1996@gmail.com>
Date: Mon, 20 Dec 2021 12:32:27 +0100
Subject: [PATCH 02/22] feat: amdgpu patches

---
 drivers/gpu/drm/amd/amdgpu/Makefile           |   1 +
 drivers/gpu/drm/amd/amdgpu/amdgpu.h           |   3 +
 .../gpu/drm/amd/amdgpu/amdgpu_connectors.c    |  51 +-
 drivers/gpu/drm/amd/amdgpu/amdgpu_device.c    |   6 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c       |  20 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c  |  20 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c        |   5 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c     |   2 +
 drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c      |   2 +
 drivers/gpu/drm/amd/amdgpu/atombios_dp.c      |  10 +-
 .../gpu/drm/amd/amdgpu/atombios_encoders.c    |   6 +-
 drivers/gpu/drm/amd/amdgpu/cik.c              | 321 ++++++++
 drivers/gpu/drm/amd/amdgpu/cik_sdma.c         |  29 +-
 drivers/gpu/drm/amd/amdgpu/dce_v8_0.c         |  44 +-
 drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c         | 667 ++++++++++++++-
 drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c         |  19 +
 drivers/gpu/drm/amd/amdgpu/ps4_bridge.c       | 776 ++++++++++++++++++
 .../gpu/drm/amd/amdkfd/cik_event_interrupt.c  |   5 +-
 drivers/gpu/drm/amd/amdkfd/kfd_crat.c         |   3 +
 drivers/gpu/drm/amd/amdkfd/kfd_device.c       |  46 ++
 .../drm/amd/amdkfd/kfd_device_queue_manager.c |   5 +-
 drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c  |   2 +
 drivers/gpu/drm/amd/amdkfd/kfd_kernel_queue.c |   2 +
 .../gpu/drm/amd/amdkfd/kfd_packet_manager.c   |   2 +
 drivers/gpu/drm/amd/amdkfd/kfd_topology.c     |   2 +
 .../drm/amd/include/asic_reg/gmc/gmc_7_1_d.h  |  28 +
 include/drm/amd_asic_type.h                   |  56 +-
 include/drm/drm_pciids.h                      |   4 +
 28 files changed, 2086 insertions(+), 51 deletions(-)
 create mode 100644 drivers/gpu/drm/amd/amdgpu/ps4_bridge.c

diff --git a/drivers/gpu/drm/amd/amdgpu/Makefile b/drivers/gpu/drm/amd/amdgpu/Makefile
index 8d0748184a14..bc79dc5dfaac 100644
--- a/drivers/gpu/drm/amd/amdgpu/Makefile
+++ b/drivers/gpu/drm/amd/amdgpu/Makefile
@@ -237,6 +237,7 @@ amdgpu-$(CONFIG_COMPAT) += amdgpu_ioc32.o
 amdgpu-$(CONFIG_VGA_SWITCHEROO) += amdgpu_atpx_handler.o
 amdgpu-$(CONFIG_ACPI) += amdgpu_acpi.o
 amdgpu-$(CONFIG_HMM_MIRROR) += amdgpu_mn.o
+amdgpu-$(CONFIG_X86_PS4) += ps4_bridge.o
 
 include $(FULL_AMD_PATH)/pm/Makefile
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu.h b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
index d90da384d185..fc3d11bbd206 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu.h
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu.h
@@ -270,6 +270,9 @@ extern int amdgpu_num_kcq;
 #define CIK_CURSOR_WIDTH 128
 #define CIK_CURSOR_HEIGHT 128
 
+#define LVP_CURSOR_WIDTH 64 
+#define LVP_CURSOR_HEIGHT 64
+
 /* smasrt shift bias level limits */
 #define AMDGPU_SMARTSHIFT_MAX_BIAS (100)
 #define AMDGPU_SMARTSHIFT_MIN_BIAS (-100)
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
index c777aff164b7..edceba19b54a 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_connectors.c
@@ -1516,6 +1516,31 @@ static const struct drm_connector_funcs amdgpu_connector_dp_funcs = {
 	.late_register = amdgpu_connector_late_register,
 };
 
+#ifdef CONFIG_X86_PS4
+int ps4_bridge_get_modes(struct drm_connector *connector);
+int ps4_bridge_mode_valid(struct drm_connector *connector,
+			struct drm_display_mode *mode);
+enum drm_connector_status ps4_bridge_detect(struct drm_connector *connector,
+					  bool force);
+
+
+static const struct drm_connector_helper_funcs amdgpu_ps4_dp_connector_helper_funcs = {
+	.get_modes = ps4_bridge_get_modes,
+	.mode_valid = ps4_bridge_mode_valid,
+	.best_encoder = amdgpu_connector_dvi_encoder,
+};
+
+static const struct drm_connector_funcs amdgpu_ps4_dp_connector_funcs = {
+	.dpms = drm_helper_connector_dpms,
+	.detect = ps4_bridge_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	//.set_property = amdgpu_connector_set_property,
+	.destroy = amdgpu_connector_destroy,
+	.force = amdgpu_connector_dvi_force,
+	.late_register = amdgpu_connector_late_register,
+};
+#endif
+
 static const struct drm_connector_funcs amdgpu_connector_edp_funcs = {
 	.dpms = drm_helper_connector_dpms,
 	.detect = amdgpu_connector_dp_detect,
@@ -1547,6 +1572,7 @@ amdgpu_connector_add(struct amdgpu_device *adev,
 	struct i2c_adapter *ddc = NULL;
 	uint32_t subpixel_order = SubPixelNone;
 	bool shared_ddc = false;
+	bool is_ps4_bridge = false;
 	bool is_dp_bridge = false;
 	bool has_aux = false;
 
@@ -1595,6 +1621,18 @@ amdgpu_connector_add(struct amdgpu_device *adev,
 	if (!amdgpu_connector)
 		return;
 
+	/* Liverpool (PS4) has an DP bridge which needs a special driver, and
+	 * a fake HDMI port that doesn't really exist. */
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		if (connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
+			connector_type = DRM_MODE_CONNECTOR_HDMIA;
+			is_dp_bridge = true;
+			is_ps4_bridge = true;
+		} else {
+			return;
+		}
+	}
+
 	connector = &amdgpu_connector->base;
 
 	amdgpu_connector->connector_id = connector_id;
@@ -1649,12 +1687,21 @@ amdgpu_connector_add(struct amdgpu_device *adev,
 		case DRM_MODE_CONNECTOR_HDMIA:
 		case DRM_MODE_CONNECTOR_HDMIB:
 		case DRM_MODE_CONNECTOR_DisplayPort:
-			drm_connector_init_with_ddc(dev, &amdgpu_connector->base,
+			if(!is_ps4_bridge) {
+				drm_connector_init_with_ddc(dev, &amdgpu_connector->base,
 						    &amdgpu_connector_dp_funcs,
 						    connector_type,
 						    ddc);
-			drm_connector_helper_add(&amdgpu_connector->base,
+				drm_connector_helper_add(&amdgpu_connector->base,
 						 &amdgpu_connector_dp_helper_funcs);
+			} else {
+				drm_connector_init(dev, &amdgpu_connector->base, 
+						&amdgpu_ps4_dp_connector_funcs, 
+						connector_type);
+
+				drm_connector_helper_add(&amdgpu_connector->base,
+						&amdgpu_ps4_dp_connector_helper_funcs);
+			}
 			drm_object_attach_property(&amdgpu_connector->base.base,
 						      adev->mode_info.underscan_property,
 						      UNDERSCAN_OFF);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
index 2f51789d9818..125233cf8287 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_device.c
@@ -106,6 +106,8 @@ const char *amdgpu_asic_name[] = {
 	"KAVERI",
 	"KABINI",
 	"HAWAII",
+	"LIVERPOOL",
+	"GLADIUS",
 	"MULLINS",
 	"TOPAZ",
 	"TONGA",
@@ -1957,6 +1959,8 @@ static int amdgpu_device_parse_gpu_info_fw(struct amdgpu_device *adev)
 #ifdef CONFIG_DRM_AMDGPU_CIK
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
+	case CHIP_LIVERPOOL:
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
@@ -2144,6 +2148,8 @@ static int amdgpu_device_ip_early_init(struct amdgpu_device *adev)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		if (adev->flags & AMD_IS_APU)
 			adev->family = AMDGPU_FAMILY_KV;
 		else
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
index 4df888c7e2ff..8efd8c40762b 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_drv.c
@@ -46,6 +46,10 @@
 #include "amdgpu_fdinfo.h"
 #include "amdgpu_amdkfd.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
+
 #include "amdgpu_ras.h"
 #include "amdgpu_xgmi.h"
 #include "amdgpu_reset.h"
@@ -1759,6 +1763,12 @@ static const struct pci_device_id pciidlist[] = {
 	{0x1002, 0x985D, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
 	{0x1002, 0x985E, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
 	{0x1002, 0x985F, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_MULLINS|AMD_IS_MOBILITY|AMD_IS_APU},
+	/* Liverpool */
+	{0x1002, 0x9920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	{0x1002, 0x9922, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	{0x1002, 0x9923, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|AMD_IS_APU},
+	/* Gladius */
+	{0x1002, 0x9924, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_GLADIUS|AMD_IS_APU},
 #endif
 	/* topaz */
 	{0x1002, 0x6900, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_TOPAZ},
@@ -2066,6 +2076,16 @@ static int amdgpu_pci_probe(struct pci_dev *pdev,
 	size = pci_resource_len(pdev, 0);
 	is_fw_fb = amdgpu_is_fw_framebuffer(base, size);
 
+	#ifdef CONFIG_X86_PS4
+	/* On the PS4 (Liverpool graphics) we have a hard dependency on the
+	 * Aeolia driver to set up the HDMI encoder which is connected to it,
+	 * so defer probe until it is ready. This test passes if this isn't
+	 * a PS4 (returns -ENODEV).
+	 */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+	#endif
+
 	adev = devm_drm_dev_alloc(&pdev->dev, &amdgpu_kms_driver, typeof(*adev), ddev);
 	if (IS_ERR(adev))
 		return PTR_ERR(adev);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c
index af4ef84e27a7..619d4c771176 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_encoders.c
@@ -32,6 +32,23 @@
 #include "atom.h"
 #include "atombios_encoders.h"
 
+#ifdef CONFIG_X86_PS4
+int 
+ps4_bridge_register(struct drm_connector *connector,
+	     	    struct drm_encoder *encoder);
+
+static void amdgpu_maybe_add_bridge(struct drm_connector *connector,
+				    struct drm_encoder *encoder)
+{
+	struct drm_device *dev = connector->dev;
+	struct amdgpu_device *adev = dev->dev_private;
+
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		ps4_bridge_register(connector, encoder);
+	}
+}
+#endif
+
 void
 amdgpu_link_encoder_connector(struct drm_device *dev)
 {
@@ -49,6 +66,9 @@ amdgpu_link_encoder_connector(struct drm_device *dev)
 		list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 			amdgpu_encoder = to_amdgpu_encoder(encoder);
 			if (amdgpu_encoder->devices & amdgpu_connector->devices) {
+				#ifdef CONFIG_X86_PS4
+				amdgpu_maybe_add_bridge(connector, encoder);
+				#endif
 				drm_connector_attach_encoder(connector, encoder);
 				if (amdgpu_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT)) {
 					amdgpu_atombios_encoder_init_backlight(amdgpu_encoder, connector);
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c
index c076a6b9a5a2..486c571768d8 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ib.c
@@ -385,7 +385,12 @@ int amdgpu_ib_ring_tests(struct amdgpu_device *adev)
 		tmo_gfx = AMDGPU_IB_TEST_GFX_XGMI_TIMEOUT;
 	}
 
+	#ifdef CONFIG_X86_PS4
+	//TODO test if this is needed now
+	for (i = 0; i < 1 /*adev->num_rings*/; ++i) {
+	#else
 	for (i = 0; i < adev->num_rings; ++i) {
+	#endif
 		struct amdgpu_ring *ring = adev->rings[i];
 		long tmo;
 
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c
index 0ed0736d515a..b98296c851db 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_ucode.c
@@ -377,6 +377,8 @@ amdgpu_ucode_get_load_type(struct amdgpu_device *adev, int load_type)
 	case CHIP_KABINI:
 	case CHIP_HAWAII:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		return AMDGPU_FW_LOAD_DIRECT;
 #endif
 	case CHIP_TOPAZ:
diff --git a/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c b/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c
index 7d58bf410be0..412faeef0c96 100644
--- a/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c
+++ b/drivers/gpu/drm/amd/amdgpu/amdgpu_vkms.c
@@ -536,6 +536,8 @@ static int amdgpu_vkms_hw_init(void *handle)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		dce_v8_0_disable_dce(adev);
 		break;
 #endif
diff --git a/drivers/gpu/drm/amd/amdgpu/atombios_dp.c b/drivers/gpu/drm/amd/amdgpu/atombios_dp.c
index f327becb022f..33987ecdc517 100644
--- a/drivers/gpu/drm/amd/amdgpu/atombios_dp.c
+++ b/drivers/gpu/drm/amd/amdgpu/atombios_dp.c
@@ -257,12 +257,20 @@ static int amdgpu_atombios_dp_get_dp_link_config(struct drm_connector *connector
 		amdgpu_atombios_dp_convert_bpc_to_bpp(amdgpu_connector_get_monitor_bpc(connector));
 	static const unsigned link_rates[3] = { 162000, 270000, 540000 };
 	unsigned max_link_rate = drm_dp_max_link_rate(dpcd);
+	unsigned min_lane_num = 1;
 	unsigned max_lane_num = drm_dp_max_lane_count(dpcd);
 	unsigned lane_num, i, max_pix_clock;
+	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+	struct drm_device *dev = amdgpu_connector->base.dev;
+	struct amdgpu_device *adev = dev->dev_private;
+
+	/* Liverpool is always connected to an encoder that needs 4 lanes */
+	if (adev->asic_type == CHIP_LIVERPOOL)
+		min_lane_num = 4;
 
 	if (amdgpu_connector_encoder_get_dp_bridge_encoder_id(connector) ==
 	    ENCODER_OBJECT_ID_NUTMEG) {
-		for (lane_num = 1; lane_num <= max_lane_num; lane_num <<= 1) {
+		for (lane_num = min_lane_num; lane_num <= max_lane_num; lane_num <<= 1) {
 			max_pix_clock = (lane_num * 270000 * 8) / bpp;
 			if (max_pix_clock >= pix_clock) {
 				*dp_lanes = lane_num;
diff --git a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
index 6134ed964027..5bd8a782feb5 100644
--- a/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
+++ b/drivers/gpu/drm/amd/amdgpu/atombios_encoders.c
@@ -445,8 +445,12 @@ int amdgpu_atombios_encoder_get_encoder_mode(struct drm_encoder *encoder)
 	struct amdgpu_connector *amdgpu_connector;
 	struct amdgpu_connector_atom_dig *dig_connector;
 
+	struct drm_device *dev = encoder->dev;
+	struct amdgpu_device *adev = dev->dev_private;
+
 	/* dp bridges are always DP */
-	if (amdgpu_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)
+	if ((amdgpu_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE) ||
+	    (adev->asic_type == CHIP_LIVERPOOL) || (adev->asic_type == CHIP_GLADIUS))
 		return ATOM_ENCODER_MODE_DP;
 
 	/* DVO is always DVO */
diff --git a/drivers/gpu/drm/amd/amdgpu/cik.c b/drivers/gpu/drm/amd/amdgpu/cik.c
index de6d10390ab2..353899a95424 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik.c
@@ -788,6 +788,206 @@ static const u32 hawaii_mgcg_cgcg_init[] =
 	0x3603, 0xff000ff0, 0x00000100
 };
 
+static const u32 liverpool_golden_common_registers[] =
+{
+	0x31dc, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+	0x31dd, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+	0x31e6, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+	0x31e7, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1 */
+	0x31e8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+	0x31e9, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3*/
+	0x31ea, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+	0x31eb, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5 */
+	0x31ec, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+	0x31ed, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+	0x31ee, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+	0x31ef, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+	0xa0d4, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+	0xa0d5, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+	0x1401, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+};
+
+static const u32 liverpool_golden_registers[] =
+{
+	0x3108, 0xffffffff, 0xfffffffc, /* RLC_CGTT_MGCG_OVERRIDE */
+	0xc200, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	/* These are all setting OFF_HYSTERESIS = 0x10 */
+	0xf0a8, 0xffffffff, 0x00000100, /* CB_CGTT_SCLK_CTRL */
+	0xf082, 0xffffffff, 0x00000100, /* CGTT_BCI_CLK_CTRL */
+	0xf0b0, 0xffffffff, 0x00000100, /* CGTT_CP_CLK_CTRL */
+	0xf0b2, 0xffffffff, 0x00000100, /* CGTT_CPC_CLK_CTRL */
+	0xf0b1, 0xffffffff, 0x00000100, /* CGTT_CPF_CLK_CTRL */
+	0x1579, 0xffffffff, 0x00600100, /* CGTT_DRM_CLK_CTRL0 */
+	0xf0a0, 0xffffffff, 0x00000100, /* CGTT_GDS_CLK_CTRL */
+	0xf085, 0xffffffff, 0x06000100, /* CGTT_IA_CLK_CTRL */
+	0xf088, 0xffffffff, 0x00000100, /* CGTT_PA_CLK_CTRL */
+	0xf086, 0xffffffff, 0x06000100, /* CGTT_WD_CLK_CTRL */
+	0xf081, 0xffffffff, 0x00000100, /* CGTT_PC_CLK_CTRL */
+	0xf0b8, 0xffffffff, 0x00000100, /* CGTT_RLC_CLK_CTRL */
+	0xf089, 0xffffffff, 0x00000100, /* CGTT_SC_CLK_CTRL */
+	0xf080, 0xffffffff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0xf08c, 0xffffffff, 0x00000100, /* CGTT_SQ_CLK_CTRL */
+	0xf08d, 0xffffffff, 0x00000100, /* CGTT_SQG_CLK_CTRL */
+	0xf094, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL0 */
+	0xf095, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL1 */
+	0xf096, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL2 */
+	0xf097, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL3 */
+	0xf098, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL4 */
+	0xf09f, 0xffffffff, 0x00000100, /* CGTT_TCI_CLK_CTRL */
+	0xf09e, 0xffffffff, 0x00000100, /* CGTT_TCP_CLK_CTRL */
+	0xf084, 0xffffffff, 0x06000100, /* CGTT_VGT_CLK_CTRL */
+	0xf0a4, 0xffffffff, 0x00000100, /* DB_CGTT_CLK_CTRL_0 */
+	0xf09d, 0xffffffff, 0x00000100, /* TA_CGTT_CTRL */
+	0xf0ad, 0xffffffff, 0x00000100, /* TCA_CGTT_SCLK_CTRL */
+	0xf0ac, 0xffffffff, 0x00000100, /* TCC_CGTT_SCLK_CTRL */
+	0xf09c, 0xffffffff, 0x00000100, /* TD_CGTT_CTRL */
+	/* */
+	0xc200, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	0xf008, 0xffffffff, 0x00010000, /* CGTS_CU0_SP0_CTRL_REG */
+	0xf009, 0xffffffff, 0x00030002, /* CGTS_CU0_LDS_SQ_CTRL_REG */
+	0xf00a, 0xffffffff, 0x00040007, /* CGTS_CU0_TA_SQC_CTRL_REG */
+	0xf00b, 0xffffffff, 0x00060005, /* CGTS_CU0_SP1_CTRL_REG */
+	0xf00c, 0xffffffff, 0x00090008, /* CGTS_CU0_TD_TCP_CTRL_REG */
+	0xf00d, 0xffffffff, 0x00010000, /* CGTS_CU1_SP0_CTRL_REG */
+	0xf00e, 0xffffffff, 0x00030002, /* CGTS_CU1_LDS_SQ_CTRL_REG */
+	0xf00f, 0xffffffff, 0x00040007, /* CGTS_CU1_TA_CTRL_REG */
+	0xf010, 0xffffffff, 0x00060005, /* CGTS_CU1_SP1_CTRL_REG */
+	0xf011, 0xffffffff, 0x00090008, /* CGTS_CU1_TD_TCP_CTRL_REG */
+	0xf012, 0xffffffff, 0x00010000, /* CGTS_CU2_SP0_CTRL_REG */
+	0xf013, 0xffffffff, 0x00030002, /* CGTS_CU2_LDS_SQ_CTRL_REG */
+	0xf014, 0xffffffff, 0x00040007, /* CGTS_CU2_TA_CTRL_REG */
+	0xf015, 0xffffffff, 0x00060005, /* CGTS_CU2_SP1_CTRL_REG */
+	0xf016, 0xffffffff, 0x00090008, /* CGTS_CU2_TD_TCP_CTRL_REG */
+	0xf017, 0xffffffff, 0x00010000, /* CGTS_CU3_SP0_CTRL_REG */
+	0xf018, 0xffffffff, 0x00030002, /* CGTS_CU3_LDS_SQ_CTRL_REG */
+	0xf019, 0xffffffff, 0x00040007, /* CGTS_CU3_TA_SQC_CTRL_REG */
+	0xf01a, 0xffffffff, 0x00060005, /* CGTS_CU3_SP1_CTRL_REG */
+	0xf01b, 0xffffffff, 0x00090008, /* CGTS_CU3_TD_TCP_CTRL_REG */
+	0xf01c, 0xffffffff, 0x00010000, /* CGTS_CU4_SP0_CTRL_REG */
+	0xf01d, 0xffffffff, 0x00030002, /* CGTS_CU4_LDS_SQ_CTRL_REG */
+	0xf01e, 0xffffffff, 0x00040007, /* CGTS_CU4_TA_CTRL_REG */
+	0xf01f, 0xffffffff, 0x00060005, /* CGTS_CU4_SP1_CTRL_REG */
+	0xf020, 0xffffffff, 0x00090008, /* CGTS_CU4_TD_TCP_CTRL_REG */
+	0xf021, 0xffffffff, 0x00010000, /* CGTS_CU5_SP0_CTRL_REG */
+	0xf022, 0xffffffff, 0x00030002, /* CGTS_CU5_LDS_SQ_CTRL_REG */
+	0xf023, 0xffffffff, 0x00040007, /* CGTS_CU5_TA_CTRL_REG */
+	0xf024, 0xffffffff, 0x00060005, /* CGTS_CU5_SP1_CTRL_REG */
+	0xf025, 0xffffffff, 0x00090008, /* CGTS_CU5_TD_TCP_CTRL_REG */
+	0xf026, 0xffffffff, 0x00010000, /* CGTS_CU6_SP0_CTRL_REG */
+	0xf027, 0xffffffff, 0x00030002, /* CGTS_CU6_LDS_SQ_CTRL_REG */
+	0xf028, 0xffffffff, 0x00040007, /* CGTS_CU6_TA_SQC_CTRL_REG */
+	0xf029, 0xffffffff, 0x00060005, /* CGTS_CU6_SP1_CTRL_REG */
+	0xf02a, 0xffffffff, 0x00090008, /* CGTS_CU6_TD_TCP_CTRL_REG */
+	0xf02b, 0xffffffff, 0x00010000, /* CGTS_CU7_SP0_CTRL_REG */
+	0xf02c, 0xffffffff, 0x00030002, /* CGTS_CU7_LDS_SQ_CTRL_REG */
+	0xf02d, 0xffffffff, 0x00040007, /* CGTS_CU7_TA_SQC_CTRL_REG */
+	0xf02e, 0xffffffff, 0x00060005, /* CGTS_CU7_SP1_CTRL_REG */
+	0xf02f, 0xffffffff, 0x00090008, /* CGTS_CU7_TD_TCP_CTRL_REG */
+	0xf030, 0xffffffff, 0x00010000, /* CGTS_CU8_SP0_CTRL_REG */
+	0xf031, 0xffffffff, 0x00030002, /* CGTS_CU8_LDS_SQ_CTRL_REG */
+	0xf032, 0xffffffff, 0x00040007, /* CGTS_CU8_TA_CTRL_REG */
+	0xf033, 0xffffffff, 0x00060005, /* CGTS_CU8_SP1_CTRL_REG */
+	0xf034, 0xffffffff, 0x00090008, /* CGTS_CU8_TD_TCP_CTRL_REG */
+	0xf035, 0xffffffff, 0x00010000, /* CGTS_CU9_SP0_CTRL_REG */
+	0xf036, 0xffffffff, 0x00030002, /* CGTS_CU9_LDS_SQ_CTRL_REG */
+	0xf037, 0xffffffff, 0x00040007, /* CGTS_CU9_TA_CTRL_REG */
+	0xf038, 0xffffffff, 0x00060005, /* CGTS_CU9_SP1_CTRL_REG */
+	0xf039, 0xffffffff, 0x00090008, /* CGTS_CU9_TD_TCP_CTRL_REG */
+	0xf000, 0xffffffff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0x21c2, 0xffffffff, 0x00900100, /* CP_RB_WPTR_POLL_CNTL */
+	0x3109, 0xffffffff, 0x0020003f, /* RLC_CGCG_CGLS_CTRL */
+	0x2684, 0x00210000, 0x00018208, /* CB_HW_CONTROL */
+	0xf000, 0xffff1fff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0xf003, 0xffff0001, 0xff000000, /* CGTS_TCC_DISABLE */
+	0xf004, 0xffff0000, 0xff000000, /* CGTS_USER_TCC_DISABLE */
+	0x1579, 0xff607fff, 0xfc000100, /* CGTT_DRM_CLK_CTRL0 */
+	0xf080, 0xfdfc0fff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0x1bb6, 0x00010000, 0x00010000, /* CRTC_DOUBLE_BUFFER_CONTROL */
+	0x260d, 0xf00fffff, 0x00004400, /* DB_DEBUG2 */
+	0x16ec, 0x000000f0, 0x00000070, /* FBC_DEBUG_COMP */
+	0x263e, 0x73773777, 0x12011003, /* GB_ADDR_CONFIG */
+	0xbd2, 0x73773777, 0x12010001, /* HDP_ADDR_CONFIG */
+	0x2285, 0xf000003f, 0x00000007, /* PA_CL_ENHANCE */
+	0x22fc, 0x00000001, 0x00000001, /* PA_SC_ENHANCE */
+	0x22c9, 0xffffffff, 0x00ffffff, /* PA_SC_FORCE_EOV_MAX_CNTS */
+	0xc281, 0x0000ff0f, 0x00000000, /* PA_SC_LINE_STIPPLE_STATE */
+	0xa293, 0x07ffffff, 0x06000000, /* PA_SC_MODE_CNTL_1 */
+	0x30df, 0xffffffff, 0x00000b00, /* RLC_PG_DELAY_2 */
+	0x136, 0x00000fff, 0x00000100, /* SCLK_CGTT_BLK_CTRL_REG */
+	0xf9e, 0x00000001, 0x00000002, /* SEM_CHICKEN_BITS */
+	0x31da, 0x00000008, 0x00000008, /* SPI_RESET_DEBUG */
+	0x2300, 0x000000ff, 0x00000001, /* SQ_CONFIG */
+	0x2542, 0x00010000, 0x00010000, /* TA_CNTL_AUX */
+	0x2b03, 0xffffffff, 0x76325410, /* TCP_CHAN_STEER_LO */
+	0x31dc, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+	0x31dd, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+	0x31e6, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+	0x31e7, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1  */
+	0x31e8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+	0x31e9, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3 */
+	0x31ea, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+	0x31eb, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5*/
+	0x31ec, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+	0x31ed, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+	0x31ee, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+	0x31ef, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+	0xa0d4, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+	0xa0d5, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+	0x1401, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+	0x535, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+};
+
+static const u32 gladius_golden_common_registers[] =
+{
+	mmATC_MISC_CG, 0x000c0fc0, 0x000c0200,
+	mmCB_HW_CONTROL, 0x0001f3cf, 0x00007208,	// 0x2684
+	mmCB_HW_CONTROL_2, 0x0f000000, 0x0f000000,
+	mmCB_HW_CONTROL_3, 0x000001ff, 0x00000040,
+	mmDB_DEBUG2, 0xf00fffff, 0x00000400,
+	mmPA_SC_ENHANCE, 0xffffffff, 0x20000001,
+	mmPA_SC_LINE_STIPPLE_STATE, 0x0000ff0f, 0x00000000,
+	mmPA_SC_RASTER_CONFIG, 0x3f3fffff, 0x2a00161a,
+	mmPA_SC_RASTER_CONFIG_1, 0x0000003f, 0x0000002e,
+	mmRLC_CGCG_CGLS_CTRL, 0x00000003, 0x0020003c, //0x0001003c,
+	0xec9d, 0xffffffff, 0x0001003c,//mmRLC_CGCG_CGLS_CTRL_3D, 0xffffffff, 0x0001003c,
+	mmSQ_CONFIG, 0x07f80000, 0x07180000,
+	mmTA_CNTL_AUX, 0x000f000f, 0x000b0000,
+	mmTCC_CTRL, 0x00100000, 0xf31fff7f,
+	mmTCP_ADDR_CONFIG, 0x000003ff, 0x000000f7,
+	mmTCP_CHAN_STEER_HI, 0xffffffff, 0x00000000,
+	mmVGT_RESET_DEBUG, 0x00000004, 0x00000004,
+	mmDCI_CLK_CNTL, 0x00000080, 0x00000000,
+	mmFBC_DEBUG_COMP, 0x000000f0, 0x00000070,
+	mmFBC_MISC, 0x9f313fff, 0x14302008,
+	mmHDMI_CONTROL, 0x313f031f, 0x00000011,
+};
+
+static const u32 gladius_golden_registers[] =
+{
+	mmGRBM_GFX_INDEX, 0xffffffff, 0xe0000000,
+	mmPA_SC_RASTER_CONFIG, 0xffffffff, 0x2a00161a,
+	mmPA_SC_RASTER_CONFIG_1, 0xffffffff, 0x0000002e,
+	mmGB_ADDR_CONFIG, 0xffffffff, 0x22011003, //0x22011003,
+	mmSPI_RESOURCE_RESERVE_CU_0, 0xffffffff, 0x00000800,
+	mmSPI_RESOURCE_RESERVE_CU_1, 0xffffffff, 0x00000800,
+	mmSPI_RESOURCE_RESERVE_EN_CU_0, 0xffffffff, 0x00FF7FBF,
+	mmSPI_RESOURCE_RESERVE_EN_CU_1, 0xffffffff, 0x00FF7FAF,
+	0x535, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+
+};
+
+static const u32 gladius_mgcg_cgcg_init[] =
+{
+	0x0000313a, 0xffffffff, 0x00000003,
+	0x00003079, 0xffffffff, 0x00020201,
+	0x00003108, 0xffffffff, 0xfffffffd,
+	0x0000c200, 0xffffffff, 0xe0000000,
+	0x0000311d, 0xffffffff, 0xffffffff,
+	0x0000311e, 0xffffffff, 0xffffffff,
+	0x0000311f, 0xffffffff, 0x004000ff,
+	0x0000313a, 0xffffffff, 0x00000001,
+};
+
 static const u32 godavari_golden_registers[] =
 {
 	0x1579, 0xff607fff, 0xfc000100,
@@ -900,6 +1100,34 @@ static void cik_init_golden_registers(struct amdgpu_device *adev)
 							hawaii_golden_spm_registers,
 							ARRAY_SIZE(hawaii_golden_spm_registers));
 		break;
+	case CHIP_LIVERPOOL:
+		// TODO (ps4patches): Why is this in comments?
+		/*amdgpu_device_program_register_sequence(adev,
+						 liverpool_mgcg_cgcg_init,
+						 ARRAY_SIZE(liverpool_mgcg_cgcg_init));*/
+		amdgpu_device_program_register_sequence(adev,
+						 liverpool_golden_registers,
+						 ARRAY_SIZE(liverpool_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+						 liverpool_golden_common_registers,
+						 ARRAY_SIZE(liverpool_golden_common_registers));
+		// TODO (ps4patches): no spm registers, try the bonaire ones?
+		break;
+	case CHIP_GLADIUS:
+		amdgpu_device_program_register_sequence(adev,
+						 gladius_mgcg_cgcg_init,
+						 ARRAY_SIZE(gladius_mgcg_cgcg_init));
+		amdgpu_device_program_register_sequence(adev,
+						 gladius_golden_registers,
+						 ARRAY_SIZE(gladius_golden_registers));
+		amdgpu_device_program_register_sequence(adev,
+						 gladius_golden_common_registers,
+						 ARRAY_SIZE(gladius_golden_common_registers));
+		// TODO (ps4patches): Why is this using the Hawaii golden spm registers, that seems wrong?
+		amdgpu_device_program_register_sequence(adev,
+						 hawaii_golden_spm_registers,
+						 ARRAY_SIZE(hawaii_golden_spm_registers));
+		break;
 	default:
 		break;
 	}
@@ -2147,6 +2375,63 @@ static int cik_common_early_init(void *handle)
 		} else
 			adev->external_rev_id = adev->rev_id + 0xa1;
 		break;
+		case CHIP_LIVERPOOL:
+			adev->cg_flags =
+				AMD_CG_SUPPORT_GFX_MGCG |
+				AMD_CG_SUPPORT_GFX_MGLS |
+				/*AMD_CG_SUPPORT_GFX_CGCG |*/
+				AMD_CG_SUPPORT_GFX_CGLS |
+				AMD_CG_SUPPORT_GFX_CGTS |
+				AMD_CG_SUPPORT_GFX_CGTS_LS |
+				AMD_CG_SUPPORT_GFX_CP_LS |
+				AMD_CG_SUPPORT_SDMA_MGCG |
+				AMD_CG_SUPPORT_SDMA_LS |
+				AMD_CG_SUPPORT_BIF_LS |
+				AMD_CG_SUPPORT_VCE_MGCG |
+				AMD_CG_SUPPORT_UVD_MGCG |
+				AMD_CG_SUPPORT_HDP_LS |
+				AMD_CG_SUPPORT_HDP_MGCG;
+			adev->pg_flags =
+				/*AMD_PG_SUPPORT_GFX_PG |
+				  AMD_PG_SUPPORT_GFX_SMG | */
+				/*AMD_PG_SUPPORT_UVD | */
+				/*AMD_PG_SUPPORT_VCE |
+				  AMD_PG_SUPPORT_CP |
+				  AMD_PG_SUPPORT_GDS |
+				  AMD_PG_SUPPORT_RLC_SMU_HS |
+				  AMD_PG_SUPPORT_SAMU |*/
+				0;
+			adev->external_rev_id = adev->rev_id + 0x61;
+			break;
+
+		case CHIP_GLADIUS:
+			adev->cg_flags =
+				AMD_CG_SUPPORT_GFX_MGCG |
+				AMD_CG_SUPPORT_GFX_MGLS |
+				AMD_CG_SUPPORT_GFX_CGCG |
+				AMD_CG_SUPPORT_GFX_CGLS |
+				AMD_CG_SUPPORT_GFX_CGTS |
+				AMD_CG_SUPPORT_GFX_CGTS_LS |
+				AMD_CG_SUPPORT_GFX_CP_LS |
+				AMD_CG_SUPPORT_SDMA_MGCG |
+				AMD_CG_SUPPORT_SDMA_LS |
+				AMD_CG_SUPPORT_BIF_LS |
+				AMD_CG_SUPPORT_VCE_MGCG |
+				AMD_CG_SUPPORT_UVD_MGCG |
+				AMD_CG_SUPPORT_HDP_LS |
+				AMD_CG_SUPPORT_HDP_MGCG;
+			adev->pg_flags =
+				/*AMD_PG_SUPPORT_GFX_PG |
+					AMD_PG_SUPPORT_GFX_SMG | */
+				/*AMD_PG_SUPPORT_UVD | */
+				/*AMD_PG_SUPPORT_VCE |
+					AMD_PG_SUPPORT_CP |
+					AMD_PG_SUPPORT_GDS |
+					AMD_PG_SUPPORT_RLC_SMU_HS |
+					AMD_PG_SUPPORT_SAMU |*/
+				0;
+			adev->external_rev_id = adev->rev_id + 0x71;
+			break;
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
@@ -2329,6 +2614,42 @@ int cik_set_ip_blocks(struct amdgpu_device *adev)
 		amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block);
 		amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block);
 		break;
+	case CHIP_LIVERPOOL:
+		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		//amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_device_ip_block_add(adev, &amdgpu_vkms_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_device_ip_block_add(adev, &dm_ip_block);
+#endif
+		else
+			amdgpu_device_ip_block_add(adev, &dce_v8_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+		/*amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block)*/;
+		/*amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block)*/;
+		break;
+	case CHIP_GLADIUS:
+		amdgpu_device_ip_block_add(adev, &cik_common_ip_block);
+		amdgpu_device_ip_block_add(adev, &gmc_v7_0_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_ih_ip_block);
+		//amdgpu_device_ip_block_add(adev, &pp_smu_ip_block);
+		if (adev->enable_virtual_display)
+			amdgpu_device_ip_block_add(adev, &amdgpu_vkms_ip_block);
+#if defined(CONFIG_DRM_AMD_DC)
+		else if (amdgpu_device_has_dc_support(adev))
+			amdgpu_device_ip_block_add(adev, &dm_ip_block);
+#endif
+		else
+		amdgpu_device_ip_block_add(adev, &dce_v8_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &gfx_v7_1_ip_block);
+		amdgpu_device_ip_block_add(adev, &cik_sdma_ip_block);
+		/*amdgpu_device_ip_block_add(adev, &uvd_v4_2_ip_block)*/;
+		/*amdgpu_device_ip_block_add(adev, &vce_v2_0_ip_block)*/;
+		break;
 	default:
 		/* FIXME: not supported yet */
 		return -EINVAL;
diff --git a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
index c8ebd108548d..fd8228981558 100644
--- a/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
+++ b/drivers/gpu/drm/amd/amdgpu/cik_sdma.c
@@ -66,6 +66,10 @@ MODULE_FIRMWARE("amdgpu/kabini_sdma.bin");
 MODULE_FIRMWARE("amdgpu/kabini_sdma1.bin");
 MODULE_FIRMWARE("amdgpu/mullins_sdma.bin");
 MODULE_FIRMWARE("amdgpu/mullins_sdma1.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_sdma.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_sdma1.bin");
+MODULE_FIRMWARE("amdgpu/gladius_sdma.bin");
+MODULE_FIRMWARE("amdgpu/gladius_sdma1.bin");
 
 u32 amdgpu_cik_gpu_check_soft_reset(struct amdgpu_device *adev);
 
@@ -129,6 +133,12 @@ static int cik_sdma_init_microcode(struct amdgpu_device *adev)
 	case CHIP_MULLINS:
 		chip_name = "mullins";
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "liverpool";
+		break;
+	case CHIP_GLADIUS:
+		chip_name = "gladius";
+		break;
 	default: BUG();
 	}
 
@@ -633,11 +643,20 @@ static int cik_sdma_ring_test_ring(struct amdgpu_ring *ring)
 	if (r)
 		goto error_free_wb;
 
-	amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
-	amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
-	amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
-	amdgpu_ring_write(ring, 1); /* number of DWs to follow */
-	amdgpu_ring_write(ring, 0xDEADBEEF);
+	/* The SDMA_OPCODE_WRITE opcode is broken in the ring on Liverpool */
+	if (adev->asic_type == CHIP_LIVERPOOL) {
+		amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0, SDMA_CONSTANT_FILL_EXTRA_SIZE(2)));
+		amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, 0xDEADBEEF);
+		amdgpu_ring_write(ring, 4); /* number of bytes */
+	} else {
+		amdgpu_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
+		amdgpu_ring_write(ring, lower_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, upper_32_bits(gpu_addr));
+		amdgpu_ring_write(ring, 1); /* number of DWs to follow */
+		amdgpu_ring_write(ring, 0xDEADBEEF);
+	}
 	amdgpu_ring_commit(ring);
 
 	for (i = 0; i < adev->usec_timeout; i++) {
diff --git a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
index b200b9e722d9..aaa6893d8e51 100644
--- a/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/dce_v8_0.c
@@ -403,9 +403,11 @@ static int dce_v8_0_get_num_crtc(struct amdgpu_device *adev)
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
 		num_crtc = 6;
 		break;
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
 		num_crtc = 4;
 		break;
 	case CHIP_KABINI:
@@ -1099,6 +1101,12 @@ static void dce_v8_0_bandwidth_update(struct amdgpu_device *adev)
 	u32 num_heads = 0, lb_size;
 	int i;
 
+	if((adev->asic_type == CHIP_LIVERPOOL) ||
+	   (adev->asic_type == CHIP_GLADIUS)) {
+		// FIXME PS4 (ps4patches): this stuff is broken
+		return;
+	}
+
 	amdgpu_display_update_priority(adev);
 
 	for (i = 0; i < adev->mode_info.num_crtc; i++) {
@@ -1406,6 +1414,7 @@ static int dce_v8_0_audio_init(struct amdgpu_device *adev)
 		 (adev->asic_type == CHIP_HAWAII))/* BN/HW: 6 streams, 7 endpoints */
 		adev->mode_info.audio.num_pins = 7;
 	else
+		/* (ps4patches) - Liverpool and Gladius use 3 streams so that is fine here */
 		adev->mode_info.audio.num_pins = 3;
 
 	for (i = 0; i < adev->mode_info.audio.num_pins; i++) {
@@ -1419,7 +1428,11 @@ static int dce_v8_0_audio_init(struct amdgpu_device *adev)
 		adev->mode_info.audio.pin[i].id = i;
 		/* disable audio.  it will be set up later */
 		/* XXX remove once we switch to ip funcs */
-		dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		/* Liverpool pin 2 is S/PDIF and should always be available */
+		if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], true);
+		else
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
 	}
 
 	return 0;
@@ -1995,7 +2008,9 @@ static int dce_v8_0_crtc_do_set_base(struct drm_crtc *crtc,
 	}
 
 	/* Bytes per pixel may have changed */
-	dce_v8_0_bandwidth_update(adev);
+	if ((adev->asic_type != CHIP_LIVERPOOL) &&
+	    (adev->asic_type != CHIP_GLADIUS))
+		dce_v8_0_bandwidth_update(adev);
 
 	return 0;
 }
@@ -2615,10 +2630,18 @@ static int dce_v8_0_crtc_init(struct amdgpu_device *adev, int index)
 	amdgpu_crtc->crtc_id = index;
 	adev->mode_info.crtcs[index] = amdgpu_crtc;
 
-	amdgpu_crtc->max_cursor_width = CIK_CURSOR_WIDTH;
-	amdgpu_crtc->max_cursor_height = CIK_CURSOR_HEIGHT;
-	adev_to_drm(adev)->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
-	adev_to_drm(adev)->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
+	if ((adev->asic_type == CHIP_LIVERPOOL) || (adev->asic_type == CHIP_GLADIUS)) {
+		amdgpu_crtc->max_cursor_width = LVP_CURSOR_WIDTH;
+		amdgpu_crtc->max_cursor_height = LVP_CURSOR_HEIGHT;
+		adev_to_drm(adev)->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
+		adev_to_drm(adev)->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
+	}
+	else {
+		amdgpu_crtc->max_cursor_width = CIK_CURSOR_WIDTH;
+		amdgpu_crtc->max_cursor_height = CIK_CURSOR_HEIGHT;
+		adev_to_drm(adev)->mode_config.cursor_width = amdgpu_crtc->max_cursor_width;
+		adev_to_drm(adev)->mode_config.cursor_height = amdgpu_crtc->max_cursor_height;
+	}
 
 	amdgpu_crtc->crtc_offset = crtc_offsets[amdgpu_crtc->crtc_id];
 
@@ -2645,10 +2668,12 @@ static int dce_v8_0_early_init(void *handle)
 	switch (adev->asic_type) {
 	case CHIP_BONAIRE:
 	case CHIP_HAWAII:
+	case CHIP_GLADIUS:
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 6;
 		break;
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
 		adev->mode_info.num_hpd = 6;
 		adev->mode_info.num_dig = 7;
 		break;
@@ -2768,7 +2793,12 @@ static int dce_v8_0_hw_init(void *handle)
 	dce_v8_0_hpd_init(adev);
 
 	for (i = 0; i < adev->mode_info.audio.num_pins; i++) {
-		dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
+		// TODO (ps4patches): In original patches original disable was still here
+		// Maybe that is still needed
+		if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS)
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], true);
+		else
+			dce_v8_0_audio_enable(adev, &adev->mode_info.audio.pin[i], false);
 	}
 
 	dce_v8_0_pageflip_interrupt_init(adev);
diff --git a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
index 37b4a3db6360..d81187445ebe 100644
--- a/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gfx_v7_0.c
@@ -90,6 +90,20 @@ MODULE_FIRMWARE("amdgpu/mullins_ce.bin");
 MODULE_FIRMWARE("amdgpu/mullins_rlc.bin");
 MODULE_FIRMWARE("amdgpu/mullins_mec.bin");
 
+MODULE_FIRMWARE("amdgpu/liverpool_pfp.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_me.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_ce.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_rlc.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_mec.bin");
+MODULE_FIRMWARE("amdgpu/liverpool_mec2.bin");
+
+MODULE_FIRMWARE("amdgpu/gladius_pfp.bin");
+MODULE_FIRMWARE("amdgpu/gladius_me.bin");
+MODULE_FIRMWARE("amdgpu/gladius_ce.bin");
+MODULE_FIRMWARE("amdgpu/gladius_rlc.bin");
+MODULE_FIRMWARE("amdgpu/gladius_mec.bin");
+MODULE_FIRMWARE("amdgpu/gladius_mec2.bin");
+
 static const struct amdgpu_gds_reg_offset amdgpu_gds_reg_offset[] =
 {
 	{mmGDS_VMID0_BASE, mmGDS_VMID0_SIZE, mmGDS_GWS_VMID0, mmGDS_OA_VMID0},
@@ -882,6 +896,423 @@ static const u32 kalindi_rlc_save_restore_register_list[] =
 	(0x0e00 << 16) | (0x9600 >> 2),
 };
 
+static const u32 liverpool_rlc_save_restore_register_list[] =
+{
+	(0x0600 << 16) | (0x98f4 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x98f4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x98f8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9900 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc260 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x90e8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c000 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c00c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c1c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9700 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x4e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x5e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x6e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x7e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x8e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x9e00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0xae00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0xbe00 << 16) | (0xcd20 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0x89bc >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0x89bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8900 >> 2),
+	0x00000000,
+	0x3,
+	(0x0e00 << 16) | (0x9834 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f00 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f04 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f08 >> 2),
+	0x00000000,
+	(0x0000 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0001 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0002 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0003 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0080 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0081 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0082 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0083 << 16) | (0x30f0c >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x9b7c >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x9b7c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8a14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8a18 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8bf0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8bcc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8b24 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x30a04 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0x30a04 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a10 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a14 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a18 >> 2),
+	0x00000000,
+	(0x0600 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x0680 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x1600 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x1680 << 16) | (0x30a2c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc700 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc704 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc708 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xc768 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc770 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc770 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc774 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc774 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc778 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc778 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc77c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc77c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc780 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc780 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc784 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc784 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc788 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc788 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc78c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc78c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc790 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc790 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc794 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc794 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc798 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc798 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc79c >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc79c >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a0 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a4 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a4 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7a8 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7a8 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7ac >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7ac >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b0 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b4 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b4 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7b8 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7b8 >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0xc7bc >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0xc7bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9100 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c010 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92a8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92ac >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92bc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92c8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92cc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x92d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c04 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c20 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c38 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8c3c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xae00 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9604 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac08 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac0c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac10 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac58 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac68 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac6c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac70 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac74 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac78 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac7c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac80 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac84 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac88 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xac8c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x970c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9714 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x9718 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x971c >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x1e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x4e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x5e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x6e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x7e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x8e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x9e00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0xae00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0xbe00 << 16) | (0x31068 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd10 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0xcd14 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88bc >> 2),
+	0x00000000,
+	(0x0400 << 16) | (0x89c0 >> 2),
+	0x00000000,
+	(0x0480 << 16) | (0x89c0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88c4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88d8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8980 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8988 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89a0 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88c8 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x88cc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x89b4 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3e1fc >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c210 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c214 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x3c218 >> 2),
+	0x00000000,
+	(0x0e00 << 16) | (0x8904 >> 2),
+	0x00000000,
+	1,
+	(0x0e00 << 16) | (0x8c34 >> 2),
+};
+
+// TODO (ps4patches): No Gladius save/restore list?
+
 static u32 gfx_v7_0_get_csb_size(struct amdgpu_device *adev);
 static void gfx_v7_0_get_csb_buffer(struct amdgpu_device *adev, volatile u32 *buffer);
 static void gfx_v7_0_init_pg(struct amdgpu_device *adev);
@@ -923,6 +1354,12 @@ static int gfx_v7_0_init_microcode(struct amdgpu_device *adev)
 	case CHIP_MULLINS:
 		chip_name = "mullins";
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "liverpool";
+		break;
+	case CHIP_GLADIUS:
+		chip_name = "gladius";
+		break;
 	default: BUG();
 	}
 
@@ -958,14 +1395,20 @@ static int gfx_v7_0_init_microcode(struct amdgpu_device *adev)
 	if (err)
 		goto out;
 
-	if (adev->asic_type == CHIP_KAVERI) {
+	if ((adev->asic_type == CHIP_KAVERI) ||
+	    (adev->asic_type == CHIP_LIVERPOOL) ||
+	    (adev->asic_type == CHIP_GLADIUS)) {
 		snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_mec2.bin", chip_name);
 		err = request_firmware(&adev->gfx.mec2_fw, fw_name, adev->dev);
-		if (err)
+		{
+			pr_err("gfx7: Failed to open firmware \"%s\"\n", fw_name);
 			goto out;
+		}
 		err = amdgpu_ucode_validate(adev->gfx.mec2_fw);
-		if (err)
+		{
+			pr_err("gfx7: Failed to validate ucode firmware \"%s\"\n", fw_name);
 			goto out;
+		}
 	}
 
 	snprintf(fw_name, sizeof(fw_name), "amdgpu/%s_rlc.bin", chip_name);
@@ -1218,6 +1661,151 @@ static void gfx_v7_0_tiling_mode_table_init(struct amdgpu_device *adev)
 			if (reg_offset != 7)
 				WREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);
 		break;
+
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
+		tile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+				   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+				   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_64B));
+		tile[1] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+				   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+				   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_128B));
+		tile[2] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+				   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+				   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));
+		tile[3] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+				   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+				   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_512B));
+		tile[4] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+				   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+				   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				   TILE_SPLIT(split_equal_to_row_size));
+		tile[5] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+				   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING));
+		tile[6] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+				   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+				   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				   TILE_SPLIT(ADDR_SURF_TILE_SPLIT_256B));
+		tile[7] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+				   MICRO_TILE_MODE_NEW(ADDR_SURF_DEPTH_MICRO_TILING) |
+				   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				   TILE_SPLIT(split_equal_to_row_size));
+		tile[8] = (ARRAY_MODE(ARRAY_LINEAR_ALIGNED) |
+				   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16));
+		tile[9] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+				   PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				   MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING));
+		tile[10] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+				    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+				    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[11] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+				    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+				    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+				    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[12] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+				    MICRO_TILE_MODE_NEW(ADDR_SURF_DISPLAY_MICRO_TILING) |
+				    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[13] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+				    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING));
+		tile[14] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+				    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+				    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[16] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+				    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+				    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+				    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[17] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+				    MICRO_TILE_MODE_NEW(ADDR_SURF_THIN_MICRO_TILING) |
+				    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[27] = (ARRAY_MODE(ARRAY_1D_TILED_THIN1) |
+				    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING));
+		tile[28] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
+				    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+				    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[29] = (ARRAY_MODE(ARRAY_PRT_TILED_THIN1) |
+				    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+				    PIPE_CONFIG(ADDR_SURF_P8_32x32_8x16) |
+				    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+		tile[30] = (ARRAY_MODE(ARRAY_PRT_2D_TILED_THIN1) |
+				    MICRO_TILE_MODE_NEW(ADDR_SURF_ROTATED_MICRO_TILING) |
+				    PIPE_CONFIG(ADDR_SURF_P8_32x32_16x16) |
+				    SAMPLE_SPLIT(ADDR_SURF_SAMPLE_SPLIT_2));
+
+		macrotile[0] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+					NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[1] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+					NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[2] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+					NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[3] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+					NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[4] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+					NUM_BANKS(ADDR_SURF_8_BANK));
+		macrotile[5] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+					NUM_BANKS(ADDR_SURF_4_BANK));
+		macrotile[6] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+					NUM_BANKS(ADDR_SURF_2_BANK));
+		macrotile[8] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_8) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+					NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[9] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_4) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_4) |
+					NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[10] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_2) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+					NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[11] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_2) |
+					NUM_BANKS(ADDR_SURF_16_BANK));
+		macrotile[12] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+					NUM_BANKS(ADDR_SURF_8_BANK));
+		macrotile[13] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+					NUM_BANKS(ADDR_SURF_4_BANK));
+		macrotile[14] = (BANK_WIDTH(ADDR_SURF_BANK_WIDTH_1) |
+					BANK_HEIGHT(ADDR_SURF_BANK_HEIGHT_1) |
+					MACRO_TILE_ASPECT(ADDR_SURF_MACRO_ASPECT_1) |
+					NUM_BANKS(ADDR_SURF_2_BANK));
+
+		for (reg_offset = 0; reg_offset < num_tile_mode_states; reg_offset++)
+			WREG32(mmGB_TILE_MODE0 + reg_offset, tile[reg_offset]);
+		for (reg_offset = 0; reg_offset < num_secondary_tile_mode_states; reg_offset++)
+			if (reg_offset != 7)
+				WREG32(mmGB_MACROTILE_MODE0 + reg_offset, macrotile[reg_offset]);
+		break;
 	case CHIP_HAWAII:
 		tile[0] = (ARRAY_MODE(ARRAY_2D_TILED_THIN1) |
 			   PIPE_CONFIG(ADDR_SURF_P16_32x32_16x16) |
@@ -1660,6 +2248,17 @@ gfx_v7_0_raster_config(struct amdgpu_device *adev, u32 *rconf, u32 *rconf1)
 		*rconf |= 0x0;
 		*rconf1 |= 0x0;
 		break;
+	case CHIP_LIVERPOOL:
+		*rconf |= RB_MAP_PKR0(2) | RB_MAP_PKR1(2) |
+			  RB_XSEL2(1) | PKR_MAP(2) | PKR_XSEL(1) |
+			  PKR_YSEL(1) | SE_MAP(2) | SE_XSEL(2) |
+			  SE_YSEL(2);
+		*rconf1 |= 0x0;
+		break;
+	case CHIP_GLADIUS:
+		*rconf |= 0x2a00161a;
+		*rconf1 |= 0x0000002e;
+		break;
 	default:
 		DRM_ERROR("unknown asic: 0x%x\n", adev->asic_type);
 		break;
@@ -2742,7 +3341,9 @@ static int gfx_v7_0_cp_compute_load_microcode(struct amdgpu_device *adev)
 		WREG32(mmCP_MEC_ME1_UCODE_DATA, le32_to_cpup(fw_data++));
 	WREG32(mmCP_MEC_ME1_UCODE_ADDR, 0);
 
-	if (adev->asic_type == CHIP_KAVERI) {
+	if ((adev->asic_type == CHIP_KAVERI) ||
+	    (adev->asic_type == CHIP_LIVERPOOL) ||
+	    (adev->asic_type == CHIP_GLADIUS)) {
 		const struct gfx_firmware_header_v1_0 *mec2_hdr;
 
 		if (!adev->gfx.mec2_fw)
@@ -3307,6 +3908,15 @@ static int gfx_v7_0_rlc_init(struct amdgpu_device *adev)
 			adev->gfx.rlc.reg_list = spectre_rlc_save_restore_register_list;
 			adev->gfx.rlc.reg_list_size =
 				(u32)ARRAY_SIZE(spectre_rlc_save_restore_register_list);
+		} else if (adev->asic_type == CHIP_LIVERPOOL) {
+			adev->gfx.rlc.reg_list = liverpool_rlc_save_restore_register_list;
+			adev->gfx.rlc.reg_list_size =
+				(u32)ARRAY_SIZE(liverpool_rlc_save_restore_register_list);
+		} else if (adev->asic_type == CHIP_GLADIUS) {
+			adev->gfx.rlc.reg_list =
+				liverpool_rlc_save_restore_register_list;
+			adev->gfx.rlc.reg_list_size = (u32)ARRAY_SIZE(
+				liverpool_rlc_save_restore_register_list);
 		} else {
 			adev->gfx.rlc.reg_list = kalindi_rlc_save_restore_register_list;
 			adev->gfx.rlc.reg_list_size =
@@ -4031,6 +4641,14 @@ static void gfx_v7_0_get_csb_buffer(struct amdgpu_device *adev,
 		buffer[count++] = cpu_to_le32(0x3a00161a);
 		buffer[count++] = cpu_to_le32(0x0000002e);
 		break;
+	case CHIP_LIVERPOOL:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x00000000);
+		break;
+	case CHIP_GLADIUS:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x0000002e);
+		break;
 	default:
 		buffer[count++] = cpu_to_le32(0x00000000);
 		buffer[count++] = cpu_to_le32(0x00000000);
@@ -4330,6 +4948,41 @@ static void gfx_v7_0_gpu_early_init(struct amdgpu_device *adev)
 		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
 		gb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;
 		break;
+	case CHIP_LIVERPOOL:
+		adev->gfx.config.max_shader_engines = 2; // Verified
+		adev->gfx.config.max_tile_pipes = 8; // Verified
+		adev->gfx.config.max_cu_per_sh = 9; // Probably OK
+		adev->gfx.config.max_sh_per_se = 1; // Verified
+		adev->gfx.config.max_backends_per_se = 1; // Probably OK?
+		adev->gfx.config.max_texture_channel_caches = 4; // ??
+		adev->gfx.config.max_gprs = 256;
+		adev->gfx.config.max_gs_threads = 32; // ??
+		adev->gfx.config.max_hw_contexts = 8;
+
+		adev->gfx.config.sc_prim_fifo_size_frontend = 0x20;
+		adev->gfx.config.sc_prim_fifo_size_backend = 0x100;
+		adev->gfx.config.sc_hiz_tile_fifo_size = 0x30;
+		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
+		gb_addr_config = HAWAII_GB_ADDR_CONFIG_GOLDEN;
+		break;
+
+	case CHIP_GLADIUS:
+		adev->gfx.config.max_shader_engines = 4; // Verified
+		adev->gfx.config.max_tile_pipes = 8; // Verified
+		adev->gfx.config.max_cu_per_sh = 9; // Probably OK
+		adev->gfx.config.max_sh_per_se = 1; // Verified
+		adev->gfx.config.max_backends_per_se = 2; // Probably OK?
+		adev->gfx.config.max_texture_channel_caches = 8; // ??
+		adev->gfx.config.max_gprs = 256;
+		adev->gfx.config.max_gs_threads = 32; // ??
+		adev->gfx.config.max_hw_contexts = 8;
+
+		adev->gfx.config.sc_prim_fifo_size_frontend = 0x20;
+		adev->gfx.config.sc_prim_fifo_size_backend = 0x100;
+		adev->gfx.config.sc_hiz_tile_fifo_size = 0x30;
+		adev->gfx.config.sc_earlyz_tile_fifo_size = 0x130;
+		gb_addr_config = 0x10000000; //0x22011003; //0x12011003;
+		break;
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
 	default:
@@ -4455,6 +5108,8 @@ static int gfx_v7_0_sw_init(void *handle)
 
 	switch (adev->asic_type) {
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		adev->gfx.mec.num_mec = 2;
 		break;
 	case CHIP_BONAIRE:
@@ -5166,7 +5821,9 @@ static void gfx_v7_0_get_cu_info(struct amdgpu_device *adev)
 	unsigned disable_masks[4 * 2];
 	u32 ao_cu_num;
 
-	if (adev->flags & AMD_IS_APU)
+	if ((adev->flags & AMD_IS_APU) &&
+	    (adev->asic_type != CHIP_LIVERPOOL) &&
+	    (adev->asic_type != CHIP_GLADIUS))
 		ao_cu_num = 2;
 	else
 		ao_cu_num = adev->gfx.config.max_cu_per_sh;
diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
index 63c47f61d0df..752b66d7d0df 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
@@ -150,6 +150,8 @@ static int gmc_v7_0_init_microcode(struct amdgpu_device *adev)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		return 0;
 	default: BUG();
 	}
@@ -402,6 +404,10 @@ static int gmc_v7_0_mc_init(struct amdgpu_device *adev)
 			adev->gmc.gart_size = 256ULL << 20;
 			break;
 #ifdef CONFIG_DRM_AMDGPU_CIK
+		case CHIP_LIVERPOOL:
+		case CHIP_GLADIUS:
+			adev->gmc.gart_size = 512ULL << 20;
+			break;
 		case CHIP_BONAIRE: /* UVD, VCE do not support GPUVM */
 		case CHIP_HAWAII:  /* UVD, VCE do not support GPUVM */
 		case CHIP_KAVERI:  /* UVD, VCE do not support GPUVM */
@@ -688,6 +694,19 @@ static int gmc_v7_0_gart_enable(struct amdgpu_device *adev)
 			       table_addr >> 12);
 	}
 
+	if (adev->asic_type == CHIP_LIVERPOOL || adev->asic_type == CHIP_GLADIUS) {
+		for (i = 2; i < 8; i++) {
+			WREG32(mmVM_CONTEXT0_PAGE_TABLE_START_ADDR + i, 0);
+			WREG32(mmVM_CONTEXT0_PAGE_TABLE_END_ADDR + i,
+			       adev->vm_manager.max_pfn - 1);
+		}
+		for (i = 0; i < 8; i++) {
+			WREG32(mmVM_CONTEXT8_PAGE_TABLE_START_ADDR + i, 0);
+			WREG32(mmVM_CONTEXT8_PAGE_TABLE_END_ADDR + i,
+			       adev->vm_manager.max_pfn - 1);
+		}
+	}
+
 	/* enable context1-15 */
 	WREG32(mmVM_CONTEXT1_PROTECTION_FAULT_DEFAULT_ADDR,
 	       (u32)(adev->dummy_page_addr >> 12));
diff --git a/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c b/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c
new file mode 100644
index 000000000000..86af15c134c4
--- /dev/null
+++ b/drivers/gpu/drm/amd/amdgpu/ps4_bridge.c
@@ -0,0 +1,776 @@
+/*
+ * Panasonic MN86471A DP->HDMI bridge driver (via PS4 Aeolia ICC interface)
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/ps4.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+
+#include <drm/drm_bridge.h>
+#include <drm/drm_encoder.h>
+
+#include <linux/i2c.h>
+#include <linux/i2c-algo-bit.h>
+
+
+#include "amdgpu.h"
+#include "amdgpu_mode.h"
+#include "atombios_dp.h"
+#include "ObjectID.h"
+
+#define CMD_READ	1, 1
+#define CMD_WRITE	2, 2
+#define CMD_MASK	2, 3
+#define CMD_DELAY	3, 1
+#define CMD_WAIT_SET	3, 2
+#define CMD_WAIT_CLEAR	3, 3
+
+#define TSYSCTRL 0x7005
+#define TSYSCTRL_HDMI BIT(7)
+
+#define TSRST 0x7006
+#define TSRST_AVCSRST BIT(0)
+#define TSRST_ENCSRST BIT(1)
+#define TSRST_FIFOSRST BIT(2)
+#define TSRST_CCSRST BIT(3)
+#define TSRST_HDCPSRST BIT(4)
+#define TSRST_AUDSRST BIT(6)
+#define TSRST_VIFSRST BIT(7)
+
+#define TMONREG 0x7008
+#define TMONREG_HPD BIT(3)
+
+#define TDPCMODE 0x7009
+
+
+#define UPDCTRL 0x7011
+#define UPDCTRL_ALLUPD BIT(7)
+#define UPDCTRL_AVIIUPD BIT(6)
+#define UPDCTRL_AUDIUPD BIT(5)
+#define UPDCTRL_CLKUPD BIT(4)
+#define UPDCTRL_HVSIUPD BIT(3)
+#define UPDCTRL_VIFUPD BIT(2)
+#define UPDCTRL_AUDUPD BIT(1)
+#define UPDCTRL_CSCUPD BIT(0)
+
+
+#define VINCNT 0x7040
+#define VINCNT_VIF_FILEN BIT(6)
+
+#define VMUTECNT 0x705f
+#define VMUTECNT_CCVMUTE BIT(7)
+#define VMUTECNT_DUMON BIT(6)
+#define VMUTECNT_LINEWIDTH_80 (0<<4)
+#define VMUTECNT_LINEWIDTH_90 (1<<4)
+#define VMUTECNT_LINEWIDTH_180 (2<<4)
+#define VMUTECNT_LINEWIDTH_360 (3<<4)
+#define VMUTECNT_VMUTE_MUTE_ASYNC 1
+#define VMUTECNT_VMUTE_MUTE_NORMAL 2
+#define VMUTECNT_VMUTE_MUTE_RAMPA 4
+#define VMUTECNT_VMUTE_MUTE_RAMPB 8
+#define VMUTECNT_VMUTE_MUTE_COLORBAR_RGB 10
+#define VMUTECNT_VMUTE_MUTE_TOGGLE 12
+#define VMUTECNT_VMUTE_MUTE_COLORBAR_YCBCR 14
+
+#define CSCMOD 0x70c0
+#define C420SET 0x70c2
+#define OUTWSET 0x70c3
+
+#define PKTENA 0x7202
+
+#define INFENA 0x7203
+#define INFENA_AVIEN BIT(6)
+
+#define AKESTA 0x7a84
+#define AKESTA_BUSY BIT(0)
+
+#define AKESRST 0x7a88
+
+#define HDCPEN 0x7a8b
+#define HDCPEN_NONE 0x00
+#define HDCPEN_ENC_EN 0x03
+#define HDCPEN_ENC_DIS 0x05
+
+#define PCI_DEVICE_ID_CUH_11XX 0x9920
+#define PCI_DEVICE_ID_CUH_12XX 0x9922
+#define PCI_DEVICE_ID_CUH_2XXX 0x9923
+#define PCI_DEVICE_ID_CUH_7XXX 0x9924
+
+struct edid *drm_get_edid(struct drm_connector *connector,
+ 				 struct i2c_adapter *adapter);
+
+struct i2c_cmd_hdr {
+	u8 major;
+	u8 length;
+	u8 minor;
+	u8 count;
+} __packed;
+
+struct i2c_cmdqueue {
+	struct {
+		u8 code;
+		u16 length;
+		u8 count;
+		u8 cmdbuf[0x7ec];
+	} __packed req;
+	struct {
+		u8 res1, res2;
+		u8 unk1, unk2;
+		u8 count;
+		u8 databuf[0x7eb];
+	} __packed reply;
+
+	u8 *p;
+	struct i2c_cmd_hdr *cmd;
+};
+
+struct ps4_bridge {
+	struct drm_connector *connector;
+	struct drm_encoder *encoder;
+	struct drm_bridge bridge;
+	struct i2c_cmdqueue cq;
+	struct mutex mutex;
+
+	int mode;
+};
+
+/* this should really be taken care of by the connector, but that is currently
+ * contained/owned by radeon_connector so just use a global for now */
+static struct ps4_bridge g_bridge = {
+	.mutex = __MUTEX_INITIALIZER(g_bridge.mutex)
+};
+
+static void cq_init(struct i2c_cmdqueue *q, u8 code)
+{
+	q->req.code = code;
+	q->req.count = 0;
+	q->p = q->req.cmdbuf;
+	q->cmd = NULL;
+}
+
+static void cq_cmd(struct i2c_cmdqueue *q, u8 major, u8 minor)
+{
+	if (!q->cmd || q->cmd->major != major || q->cmd->minor != minor) {
+		if (q->cmd)
+			q->cmd->length = q->p - (u8 *)q->cmd;
+		q->cmd = (struct i2c_cmd_hdr *)q->p;
+		q->cmd->major = major;
+		q->cmd->minor = minor;
+		q->cmd->length = 0;
+		q->cmd->count = 1;
+		q->req.count += 1;
+		q->p += sizeof(*q->cmd);
+	} else {
+		q->cmd->count += 1;
+	}
+}
+
+static int cq_exec(struct i2c_cmdqueue *q)
+{
+	int res;
+
+	if (!q->cmd)
+		return 0;
+
+	q->cmd->length = q->p - (u8 *)q->cmd;
+	q->req.length = q->p - (u8 *)&q->req;
+
+	res = apcie_icc_cmd(0x10, 0, &q->req, q->req.length,
+		      &q->reply, sizeof(q->reply));
+
+	if (res < 5) {
+		DRM_ERROR("icc i2c commandqueue failed: %d\n", res);
+		return -EIO;
+	}
+	if (q->reply.res1 != 0 || q->reply.res2) {
+		DRM_ERROR("icc i2c commandqueue failed: %d, %d\n",
+			  q->reply.res1, q->reply.res2);
+		return -EIO;
+	}
+
+	return res;
+}
+
+static void cq_read(struct i2c_cmdqueue *q, u16 addr, u8 count)
+{
+	cq_cmd(q, CMD_READ);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = 0;
+}
+
+static void cq_writereg(struct i2c_cmdqueue *q, u16 addr, u8 data)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = data;
+}
+
+#if 0
+static void cq_write(struct i2c_cmdqueue *q, u16 addr, u8 *data, u8 count)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	while (count--)
+		*q->p++ = *data++;
+}
+#endif
+
+static void cq_mask(struct i2c_cmdqueue *q, u16 addr, u8 value, u8 mask)
+{
+	cq_cmd(q, CMD_MASK);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = value;
+	*q->p++ = mask;
+}
+
+#if 1
+static void cq_delay(struct i2c_cmdqueue *q, u16 time)
+{
+	cq_cmd(q, CMD_DELAY);
+	*q->p++ = 0;
+	*q->p++ = time & 0xff;
+	*q->p++ = time>>8;
+	*q->p++ = 0;
+}
+#endif
+
+static void cq_wait_set(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_SET);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static void cq_wait_clear(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_CLEAR);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static inline struct ps4_bridge *
+		bridge_to_ps4_bridge(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct ps4_bridge, bridge);
+}
+
+void ps4_bridge_mode_set(struct drm_bridge *bridge,
+			 const struct drm_display_mode *mode,
+			 const struct drm_display_mode *adjusted_mode)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+
+	/* This gets called before pre_enable/enable, so we just stash
+	 * the vic ID for later */
+	mn_bridge->mode = drm_match_cea_mode(adjusted_mode);
+	DRM_DEBUG_KMS("vic mode: %d\n", mn_bridge->mode);
+	if (!mn_bridge->mode) {
+		DRM_ERROR("attempted to set non-CEA mode\n");
+	}
+}
+
+static void ps4_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("ps4_bridge_pre_enable\n");
+	DRM_DEBUG("Enable ps4_bridge_pre_enable\n");
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+
+#if 0
+	/* No idea. DP stuff probably. This borks for some reason. Meh. */
+	cq_writereg(&mn_bridge->cq, 0x7657,0xff);
+	cq_writereg(&mn_bridge->cq, 0x76a5,0x80);
+	cq_writereg(&mn_bridge->cq, 0x76a6,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7601,0x0a);
+	cq_writereg(&mn_bridge->cq, 0x7602,0x84);
+	cq_writereg(&mn_bridge->cq, 0x7603,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76a8,0x09);
+	cq_writereg(&mn_bridge->cq, 0x76ae,0xd1);
+	cq_writereg(&mn_bridge->cq, 0x76af,0x50);
+	cq_writereg(&mn_bridge->cq, 0x76b0,0x70);
+	cq_writereg(&mn_bridge->cq, 0x76b1,0xb0);
+	cq_writereg(&mn_bridge->cq, 0x76b2,0xf0);
+	cq_writereg(&mn_bridge->cq, 0x76db,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76dc,0x64);
+	cq_writereg(&mn_bridge->cq, 0x76dd,0x22);
+	cq_writereg(&mn_bridge->cq, 0x76e4,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76e6,0x1e); /* 0 for (DP?) scramble off */
+	cq_writereg(&mn_bridge->cq, 0x7670,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7671,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7672,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7673,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7668,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7669,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766a,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766b,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7655,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7007,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7098,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7099,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709a,0x0f);
+	cq_writereg(&mn_bridge->cq, 0x709b,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709c,0x50);
+	cq_writereg(&mn_bridge->cq, 0x709d,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709e,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709f,0xd0);
+	cq_writereg(&mn_bridge->cq, 0x7a9c,0x2e);
+	cq_writereg(&mn_bridge->cq, 0x7021,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7028,0x00);
+	cq_writereg(&mn_bridge->cq, 0x7030,0xa3);
+	cq_writereg(&mn_bridge->cq, 0x7016,0x04);
+#endif
+
+	/* Disable InfoFrames */
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	/* Reset HDCP */
+	cq_writereg(&mn_bridge->cq, TSRST, TSRST_ENCSRST | TSRST_HDCPSRST);
+	/* Disable HDCP flag */
+	cq_writereg(&mn_bridge->cq, TSRST, HDCPEN_ENC_DIS);
+	/* HDCP AKE reset */
+	cq_writereg(&mn_bridge->cq, AKESRST, 0xff);
+	/* Wait AKE busy */
+	cq_wait_clear(&mn_bridge->cq, AKESTA, AKESTA_BUSY);
+
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("failed to run pre-enable sequence");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void ps4_bridge_enable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	struct drm_connector *connector = mn_bridge->connector;
+	struct drm_device *dev = connector->dev;
+	struct pci_dev *pdev = to_pci_dev(dev->dev);
+	u8 dp[3];
+
+	DRM_DEBUG("Enable PS4_BRIDGE_ENABLE\n");
+	if (!mn_bridge->mode) {
+		DRM_ERROR("mode not available\n");
+		return;
+	}
+
+	if(pdev->vendor != PCI_VENDOR_ID_ATI) {
+		DRM_ERROR("Invalid vendor: %04x", pdev->vendor);
+		return;
+	}
+
+	DRM_DEBUG_KMS("ps4_bridge_enable (mode: %d)\n", mn_bridge->mode);
+
+	/* Here come the dragons */
+
+	if(pdev->device == PCI_DEVICE_ID_CUH_11XX)
+	{
+		/* Panasonic MN86471A */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Read DisplayPort status (?) */
+		cq_read(&mn_bridge->cq, 0x76e1, 3);
+		if (cq_exec(&mn_bridge->cq) < 11) {
+			mutex_unlock(&mn_bridge->mutex);
+			DRM_ERROR("could not read DP status");
+		return;
+		}
+		memcpy(dp, &mn_bridge->cq.reply.databuf[3], 3);
+
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x761e, 0x77);
+		cq_wait_set(&mn_bridge->cq, 0x761f, 0x77);
+		/* Wait for ?? */
+		cq_wait_set(&mn_bridge->cq, 0x7669, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x76d9, (dp[0] & 0x1f) | (dp[0] << 5));
+		cq_writereg(&mn_bridge->cq, 0x76da, (dp[1] & 0x7c) | ((dp[0] >> 3) & 3) | ((dp[1] << 5) & 0x80));
+		cq_writereg(&mn_bridge->cq, 0x76db, 0x80 | ((dp[1] >> 3) & 0xf));
+		cq_writereg(&mn_bridge->cq, 0x76e4, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, VINCNT, VINCNT_VIF_FILEN);
+		cq_writereg(&mn_bridge->cq, 0x7071, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x765a, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7215, 0x28); /* aspect */
+		cq_writereg(&mn_bridge->cq, 0x7217, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0);
+		cq_writereg(&mn_bridge->cq, CSCMOD, 0xdc);
+		cq_writereg(&mn_bridge->cq, C420SET, 0xaa);
+		cq_writereg(&mn_bridge->cq, TDPCMODE, 0x4a);
+		cq_writereg(&mn_bridge->cq, OUTWSET, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7027, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x700b, 0x01);
+		cq_writereg(&mn_bridge->cq, PKTENA, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, INFENA, INFENA_AVIEN);
+		cq_writereg(&mn_bridge->cq, UPDCTRL, UPDCTRL_ALLUPD | UPDCTRL_AVIIUPD |
+						     UPDCTRL_CLKUPD | UPDCTRL_VIFUPD |
+						     UPDCTRL_CSCUPD);
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_mask(&mn_bridge->cq, 0x7216, 0x00, 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0x00);
+
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+		cq_writereg(&mn_bridge->cq, 0x7016, 0x04);
+		cq_writereg(&mn_bridge->cq, 0x7a88, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7a83, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_writereg(&mn_bridge->cq, 0x7006, 0x02);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN86471A) mode\n");
+		}
+		#if 1
+		// preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b3, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70b7, 0x0b);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0x24);
+
+		cq_mask(&mn_bridge->cq,0x70b9, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x40, 0x70);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x20, 0xe0);
+		cq_mask(&mn_bridge->cq,0x7257, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x00, 0x88);
+		cq_mask(&mn_bridge->cq,0x70b9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable MN86471A hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x7ed8, 0x01);
+
+		cq_mask(&mn_bridge->cq,0x70b4, 0x00, 0x3e);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x3f);
+		cq_mask(&mn_bridge->cq,0x70b7, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70bd, 0x00, 0xff);
+
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+
+		cq_wait_set(&mn_bridge->cq,0x7096, 0x80);
+		cq_writereg(&mn_bridge->cq,0x7096, 0xff);
+
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70b1, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable hdmi MN86471A audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+	else
+	{
+		/* Panasonic MN864729 */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+		cq_mask(&mn_bridge->cq, 0x6005, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a03, 0x47);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x60f8, 0xff);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a01, 0x4d);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x1a);
+
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x00, 0x21);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x00, 0x70);
+		// 03 08 01 01 00  2c 01 00
+		cq_delay(&mn_bridge->cq, 0x012c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x00);
+		cq_delay(&mn_bridge->cq, 0x0032);
+		cq_writereg(&mn_bridge->cq, 0x7402, 0x1c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x04);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, 0x10c7, 0x38);
+		cq_writereg(&mn_bridge->cq, 0x1e02, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x1e00, 0x66);
+		cq_writereg(&mn_bridge->cq, 0x100c, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+
+		cq_writereg(&mn_bridge->cq, 0x7009, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7040, 0x42);
+		cq_writereg(&mn_bridge->cq, 0x7225, 0x28);
+		cq_writereg(&mn_bridge->cq, 0x7227, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7228, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7070, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7071, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7072, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7073, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7074, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7075, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c2, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70fe, 0x12);
+		cq_writereg(&mn_bridge->cq, 0x70c3, 0x10);
+
+		if(pdev->device == PCI_DEVICE_ID_CUH_12XX) {
+			/* newer ps4 phats need here 0x03 idk why. */
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x03);
+		} else {
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x00);
+		}
+
+		cq_writereg(&mn_bridge->cq, 0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7202, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7203, 0x60);
+		cq_writereg(&mn_bridge->cq, 0x7011, 0xd5);
+		//cq_writereg(&mn_bridge->cq, 0x7a00, 0x0e);
+
+		cq_wait_set(&mn_bridge->cq, 0x10f6, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7226, 0x00, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7228, 0x00, 0xFF);
+		cq_delay(&mn_bridge->cq, 0x012c);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+		cq_wait_clear(&mn_bridge->cq, 0x7204, 0x40);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x05);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x70, 0x70);
+		cq_mask(&mn_bridge->cq, 0x1034, 0x02, 0x02);
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		cq_writereg(&mn_bridge->cq, HDCPEN, 0x00);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN864729) mode\n");
+		}
+		#if 1
+		// AUDIO preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70aa, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70af, 0x07);
+		cq_writereg(&mn_bridge->cq,0x70a9, 0x5a);
+
+		cq_mask(&mn_bridge->cq,0x70af, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70af, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x80, 0xe0);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x01, 0x07);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x80, 0x88);
+		cq_mask(&mn_bridge->cq,0x70a9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b0, 0x01);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b1, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b4, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+		cq_wait_set(&mn_bridge->cq,0x10f6, 0xa2);
+		cq_mask(&mn_bridge->cq,0x7267, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7204, 0x10);
+		cq_wait_clear(&mn_bridge->cq,0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+
+}
+
+static void ps4_bridge_disable(struct drm_bridge *bridge)
+{
+	struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("ps4_bridge_disable\n");
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("Failed to disable bridge\n");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void ps4_bridge_post_disable(struct drm_bridge *bridge)
+{
+	/* struct ps4_bridge *mn_bridge = bridge_to_mn864729(bridge); */
+	DRM_DEBUG_KMS("ps4_bridge_post_disable\n");
+}
+
+/* Hardcoded modes, since we don't really know how to do custom modes yet.
+ * Other CEA modes *should* work (and are allowed if externally added) */
+
+// TODO (ps4patches): Apparently the vrefresh option is calculated on the fly now
+// Check if this actually works.
+
+/* 1 - 640x480@60Hz */
+static const struct drm_display_mode mode_480p = {
+	DRM_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		 752, 800, 0, 480, 490, 492, 525, 0,
+		 DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3
+};
+/* 4 - 1280x720@60Hz */
+static const struct drm_display_mode mode_720p = {
+	DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		 1430, 1650, 0, 720, 725, 730, 750, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+/* 16 - 1920x1080@60Hz */
+static const struct drm_display_mode mode_1080p = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		 2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+
+int ps4_bridge_get_modes(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_display_mode *newmode;
+	DRM_DEBUG_KMS("ps4_bridge_get_modes\n");
+
+	newmode = drm_mode_duplicate(dev, &mode_1080p);
+	drm_mode_probed_add(connector, newmode);
+
+	//newmode = drm_mode_duplicate(dev, &mode_720p);
+	//drm_mode_probed_add(connector, newmode);
+	//newmode = drm_mode_duplicate(dev, &mode_480p);
+	//drm_mode_probed_add(connector, newmode);
+
+	drm_connector_update_edid_property(connector, NULL);
+    
+	return 0;
+}
+
+enum drm_connector_status ps4_bridge_detect(struct drm_connector *connector,
+		bool force)
+{
+	struct ps4_bridge *mn_bridge = &g_bridge;
+	u8 reg;
+
+	struct amdgpu_connector *amdgpu_connector = to_amdgpu_connector(connector);
+	struct amdgpu_connector_atom_dig *amdgpu_dig_connector = amdgpu_connector->con_priv;
+
+	amdgpu_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;
+	amdgpu_atombios_dp_get_dpcd(amdgpu_connector);
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_read(&mn_bridge->cq, TMONREG, 1);
+	if (cq_exec(&mn_bridge->cq) < 9) {
+		mutex_unlock(&mn_bridge->mutex);
+		DRM_ERROR("could not read TMONREG");
+		return connector_status_disconnected;
+	}
+	reg = mn_bridge->cq.reply.databuf[3];
+	mutex_unlock(&mn_bridge->mutex);
+
+	DRM_DEBUG_KMS("TMONREG=0x%02x\n", reg);
+
+	if (reg & TMONREG_HPD)
+		return connector_status_connected;
+	else
+		return connector_status_disconnected;
+}
+
+int ps4_bridge_mode_valid(struct drm_connector *connector,
+				  struct drm_display_mode *mode)
+{
+	int vic = drm_match_cea_mode(mode);
+
+	/* Allow anything that we can match up to a VIC (CEA modes) */
+	if (!vic || (vic != 16 && vic != 4)) {
+		return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
+static int ps4_bridge_attach(struct drm_bridge *bridge,
+			     enum drm_bridge_attach_flags flags)
+{
+	// TODO (ps4patches): Why is this in comments?
+	/* struct ps4_bridge *mn_bridge = bridge_to_ps4_bridge(bridge); */
+
+	return 0;
+}
+
+static struct drm_bridge_funcs ps4_bridge_funcs = {
+	.pre_enable = ps4_bridge_pre_enable,
+	.enable = ps4_bridge_enable,
+	.disable = ps4_bridge_disable,
+	.post_disable = ps4_bridge_post_disable,
+	.attach = ps4_bridge_attach,
+	.mode_set = ps4_bridge_mode_set,
+};
+
+int ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder)
+{
+	int ret;
+	struct ps4_bridge *mn_bridge = &g_bridge;
+
+	mn_bridge->encoder = encoder;
+	mn_bridge->connector = connector;
+	mn_bridge->bridge.funcs = &ps4_bridge_funcs;
+	ret = drm_bridge_attach(mn_bridge->encoder, &mn_bridge->bridge, NULL, 0);
+	if (ret) {
+		DRM_ERROR("Failed to initialize bridge with drm\n");
+		return -EINVAL;
+	}
+
+	//encoder->bridge = &mn_bridge->bridge;
+	// TODO (ps4patches): This seems to be the new way of adding bridges
+	drm_bridge_add(&mn_bridge->bridge);
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/amd/amdkfd/cik_event_interrupt.c b/drivers/gpu/drm/amd/amdkfd/cik_event_interrupt.c
index f6233019f042..d7d510c76e4f 100644
--- a/drivers/gpu/drm/amd/amdkfd/cik_event_interrupt.c
+++ b/drivers/gpu/drm/amd/amdkfd/cik_event_interrupt.c
@@ -38,12 +38,13 @@ static bool cik_event_interrupt_isr(struct kfd_dev *dev,
 	uint16_t pasid;
 	bool ret;
 
-	/* This workaround is due to HW/FW limitation on Hawaii that
+	/* This workaround is due to HW/FW limitation on Hawaii and Liverpool that
 	 * VMID and PASID are not written into ih_ring_entry
 	 */
 	if ((ihre->source_id == CIK_INTSRC_GFX_PAGE_INV_FAULT ||
 		ihre->source_id == CIK_INTSRC_GFX_MEM_PROT_FAULT) &&
-		dev->device_info->asic_family == CHIP_HAWAII) {
+		((dev->device_info->asic_family == CHIP_HAWAII) ||
+	         (dev->device_info->asic_family == CHIP_LIVERPOOL)) {
 		struct cik_ih_ring_entry *tmp_ihre =
 			(struct cik_ih_ring_entry *)patched_ihre;
 
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_crat.c b/drivers/gpu/drm/amd/amdkfd/kfd_crat.c
index e574aa32a111..5aa872cbef5e 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_crat.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_crat.c
@@ -1349,6 +1349,9 @@ static int kfd_fill_gpu_cache_info(struct kfd_dev *kdev,
 		num_of_cache_types = ARRAY_SIZE(kaveri_cache_info);
 		break;
 	case CHIP_HAWAII:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
+		// TODO (ps4patches): Is the Hawaii cache info really fine here?
 		pcache_info = hawaii_cache_info;
 		num_of_cache_types = ARRAY_SIZE(hawaii_cache_info);
 		break;
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_device.c b/drivers/gpu/drm/amd/amdkfd/kfd_device.c
index 660eb7097cfc..f40f9e4f3134 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_device.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_device.c
@@ -62,6 +62,8 @@ static const struct kfd2kgd_calls *kfd2kgd_funcs[] = {
 #endif
 #ifdef CONFIG_DRM_AMDGPU_CIK
 	[CHIP_HAWAII] = &gfx_v7_kfd2kgd,
+	[CHIP_GLADIUS] = &gfx_v7_kfd2kgd,
+	[CHIP_LIVERPOOL] = &gfx_v7_kfd2kgd,
 #endif
 	[CHIP_TONGA] = &gfx_v8_kfd2kgd,
 	[CHIP_FIJI] = &gfx_v8_kfd2kgd,
@@ -168,6 +170,47 @@ static const struct kfd_device_info hawaii_device_info = {
 	.num_sdma_queues_per_engine = 2,
 };
 
+// TODO (ps4patches): asic_name was hawaii in original patches, check if liverpool as name is ok
+static const struct kfd_device_info liverpool_device_info = {
+	.asic_family = CHIP_LIVERPOOL,
+	.asic_name = "liverpool",
+	.gfx_target_version = 70001,
+	.max_pasid_bits = 16,
+	/* max num of queues for KV.TODO should be a dynamic value */
+	.max_no_of_hqd	= 24,
+	.doorbell_size  = 4,
+	.ih_ring_entry_size = 4 * sizeof(uint32_t),
+	.event_interrupt_class = &event_interrupt_class_cik,
+	.num_of_watch_points = 4,
+	.mqd_size_aligned = MQD_SIZE_ALIGNED,
+	.supports_cwsr = false,
+	.needs_iommu_device = true,
+	.needs_pci_atomics = false,
+	.num_sdma_engines = 2,
+	.num_xgmi_sdma_engines = 0,
+	.num_sdma_queues_per_engine = 2,
+};
+
+static const struct kfd_device_info gladius_device_info = {
+	.asic_family = CHIP_GLADIUS,
+	.asic_name = "gladius",
+	.gfx_target_version = 70001,
+	.max_pasid_bits = 16,
+	/* max num of queues for KV.TODO should be a dynamic value */
+	.max_no_of_hqd	= 24,
+	.doorbell_size  = 4,
+	.ih_ring_entry_size = 4 * sizeof(uint32_t),
+	.event_interrupt_class = &event_interrupt_class_cik,
+	.num_of_watch_points = 4,
+	.mqd_size_aligned = MQD_SIZE_ALIGNED,
+	.supports_cwsr = false,
+	.needs_iommu_device = true,
+	.needs_pci_atomics = false,
+	.num_sdma_engines = 2,
+	.num_xgmi_sdma_engines = 0,
+	.num_sdma_queues_per_engine = 2,
+};
+
 static const struct kfd_device_info tonga_device_info = {
 	.asic_family = CHIP_TONGA,
 	.asic_name = "tonga",
@@ -661,6 +704,9 @@ static const struct kfd_device_info *kfd_supported_devices[][2] = {
 #endif
 	[CHIP_RAVEN] = {&raven_device_info, NULL},
 	[CHIP_HAWAII] = {&hawaii_device_info, NULL},
+	[CHIP_LIVERPOOL] = {&liverpool_device_info, NULL},
+	// TODO (ps4patches): This seems to be needed for the new kernel but this might break spectacularly
+	[CHIP_GLADIUS] = {&gladius_device_info, NULL},
 	[CHIP_TONGA] = {&tonga_device_info, NULL},
 	[CHIP_FIJI] = {&fiji_device_info, &fiji_vf_device_info},
 	[CHIP_POLARIS10] = {&polaris10_device_info, &polaris10_vf_device_info},
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c b/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c
index 442857f3bde7..d88513d0aca0 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_device_queue_manager.c
@@ -307,7 +307,8 @@ static void deallocate_vmid(struct device_queue_manager *dqm,
 				struct queue *q)
 {
 	/* On GFX v7, CP doesn't flush TC at dequeue */
-	if (q->device->device_info->asic_family == CHIP_HAWAII)
+	if ((q->device->device_info->asic_family == CHIP_HAWAII) ||
+	    (q->device->device_info->asic_family == CHIP_LIVERPOOL))
 		if (flush_texture_cache_nocpsch(q->device, qpd))
 			pr_err("Failed to flush TC\n");
 
@@ -1929,6 +1930,8 @@ struct device_queue_manager *device_queue_manager_init(struct kfd_dev *dev)
 		device_queue_manager_init_cik(&dqm->asic_ops);
 		break;
 
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 	case CHIP_HAWAII:
 		device_queue_manager_init_cik_hawaii(&dqm->asic_ops);
 		break;
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c b/drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c
index 2e86692def19..5db8e9656f5f 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_flat_memory.c
@@ -397,6 +397,8 @@ int kfd_init_apertures(struct kfd_process *process)
 			switch (dev->device_info->asic_family) {
 			case CHIP_KAVERI:
 			case CHIP_HAWAII:
+			case CHIP_GLADIUS:
+			case CHIP_LIVERPOOL:
 			case CHIP_CARRIZO:
 			case CHIP_TONGA:
 			case CHIP_FIJI:
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_kernel_queue.c b/drivers/gpu/drm/amd/amdkfd/kfd_kernel_queue.c
index a2b77d1df854..37dcb8dbc9e2 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_kernel_queue.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_kernel_queue.c
@@ -91,6 +91,8 @@ static bool kq_initialize(struct kernel_queue *kq, struct kfd_dev *dev,
 	kq->pq_gpu_addr = kq->pq->gpu_addr;
 
 	/* For CIK family asics, kq->eop_mem is not needed */
+	// TODO (ps4patches): Liverpool and Gladius were specifically added here before,
+	// this seems to be unneeded here now.
 	if (dev->device_info->asic_family > CHIP_MULLINS) {
 		retval = kfd_gtt_sa_allocate(dev, PAGE_SIZE, &kq->eop_mem);
 		if (retval != 0)
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_packet_manager.c b/drivers/gpu/drm/amd/amdkfd/kfd_packet_manager.c
index e547f1f8c49f..e5b3a425b92e 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_packet_manager.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_packet_manager.c
@@ -226,6 +226,8 @@ int pm_init(struct packet_manager *pm, struct device_queue_manager *dqm)
 	switch (dqm->dev->device_info->asic_family) {
 	case CHIP_KAVERI:
 	case CHIP_HAWAII:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 		/* PM4 packet structures on CIK are the same as on VI */
 	case CHIP_CARRIZO:
 	case CHIP_TONGA:
diff --git a/drivers/gpu/drm/amd/amdkfd/kfd_topology.c b/drivers/gpu/drm/amd/amdkfd/kfd_topology.c
index 98cca5f2b27f..cf39e72ace7f 100644
--- a/drivers/gpu/drm/amd/amdkfd/kfd_topology.c
+++ b/drivers/gpu/drm/amd/amdkfd/kfd_topology.c
@@ -1395,6 +1395,8 @@ int kfd_topology_add_device(struct kfd_dev *gpu)
 	switch (dev->gpu->device_info->asic_family) {
 	case CHIP_KAVERI:
 	case CHIP_HAWAII:
+	case CHIP_LIVERPOOL:
+	case CHIP_GLADIUS:
 	case CHIP_TONGA:
 		dev->node_props.capability |= ((HSA_CAP_DOORBELL_TYPE_PRE_1_0 <<
 			HSA_CAP_DOORBELL_TYPE_TOTALBITS_SHIFT) &
diff --git a/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h b/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h
index 9da033dc1a34..3ac8b09a1852 100644
--- a/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h
+++ b/drivers/gpu/drm/amd/include/asic_reg/gmc/gmc_7_1_d.h
@@ -589,8 +589,24 @@
 #define mmVM_CONTEXT13_PAGE_TABLE_BASE_ADDR                                     0x513
 #define mmVM_CONTEXT14_PAGE_TABLE_BASE_ADDR                                     0x514
 #define mmVM_CONTEXT15_PAGE_TABLE_BASE_ADDR                                     0x515
+#define mmVM_CONTEXT8_PAGE_TABLE_START_ADDR                                     0x516
+#define mmVM_CONTEXT9_PAGE_TABLE_START_ADDR                                     0x517
+#define mmVM_CONTEXT10_PAGE_TABLE_START_ADDR                                    0x518
+#define mmVM_CONTEXT11_PAGE_TABLE_START_ADDR                                    0x519
+#define mmVM_CONTEXT12_PAGE_TABLE_START_ADDR                                    0x51a
+#define mmVM_CONTEXT13_PAGE_TABLE_START_ADDR                                    0x51b
+#define mmVM_CONTEXT14_PAGE_TABLE_START_ADDR                                    0x51c
+#define mmVM_CONTEXT15_PAGE_TABLE_START_ADDR                                    0x51d
 #define mmVM_INVALIDATE_REQUEST                                                 0x51e
 #define mmVM_INVALIDATE_RESPONSE                                                0x51f
+#define mmVM_CONTEXT8_PAGE_TABLE_END_ADDR                                       0x524
+#define mmVM_CONTEXT9_PAGE_TABLE_END_ADDR                                       0x525
+#define mmVM_CONTEXT10_PAGE_TABLE_END_ADDR                                      0x526
+#define mmVM_CONTEXT11_PAGE_TABLE_END_ADDR                                      0x527
+#define mmVM_CONTEXT12_PAGE_TABLE_END_ADDR                                      0x528
+#define mmVM_CONTEXT13_PAGE_TABLE_END_ADDR                                      0x529
+#define mmVM_CONTEXT14_PAGE_TABLE_END_ADDR                                      0x52a
+#define mmVM_CONTEXT15_PAGE_TABLE_END_ADDR                                      0x52b
 #define mmVM_PRT_APERTURE0_LOW_ADDR                                             0x52c
 #define mmVM_PRT_APERTURE1_LOW_ADDR                                             0x52d
 #define mmVM_PRT_APERTURE2_LOW_ADDR                                             0x52e
@@ -620,8 +636,20 @@
 #define mmVM_CONTEXT7_PAGE_TABLE_BASE_ADDR                                      0x556
 #define mmVM_CONTEXT0_PAGE_TABLE_START_ADDR                                     0x557
 #define mmVM_CONTEXT1_PAGE_TABLE_START_ADDR                                     0x558
+#define mmVM_CONTEXT2_PAGE_TABLE_START_ADDR                                     0x559
+#define mmVM_CONTEXT3_PAGE_TABLE_START_ADDR                                     0x55a
+#define mmVM_CONTEXT4_PAGE_TABLE_START_ADDR                                     0x55b
+#define mmVM_CONTEXT5_PAGE_TABLE_START_ADDR                                     0x55c
+#define mmVM_CONTEXT6_PAGE_TABLE_START_ADDR                                     0x55d
+#define mmVM_CONTEXT7_PAGE_TABLE_START_ADDR                                     0x55e
 #define mmVM_CONTEXT0_PAGE_TABLE_END_ADDR                                       0x55f
 #define mmVM_CONTEXT1_PAGE_TABLE_END_ADDR                                       0x560
+#define mmVM_CONTEXT2_PAGE_TABLE_END_ADDR                                       0x561
+#define mmVM_CONTEXT3_PAGE_TABLE_END_ADDR                                       0x562
+#define mmVM_CONTEXT4_PAGE_TABLE_END_ADDR                                       0x563
+#define mmVM_CONTEXT5_PAGE_TABLE_END_ADDR                                       0x564
+#define mmVM_CONTEXT6_PAGE_TABLE_END_ADDR                                       0x565
+#define mmVM_CONTEXT7_PAGE_TABLE_END_ADDR                                       0x566
 #define mmVM_DEBUG                                                              0x56f
 #define mmVM_L2_CG                                                              0x570
 #define mmVM_L2_BANK_SELECT_MASKA                                               0x572
diff --git a/include/drm/amd_asic_type.h b/include/drm/amd_asic_type.h
index 0f66a0d9f06d..24ffc40e76dc 100644
--- a/include/drm/amd_asic_type.h
+++ b/include/drm/amd_asic_type.h
@@ -35,33 +35,35 @@ enum amd_asic_type {
 	CHIP_KAVERI,	/* 6 */
 	CHIP_KABINI,	/* 7 */
 	CHIP_HAWAII,	/* 8 */
-	CHIP_MULLINS,	/* 9 */
-	CHIP_TOPAZ,	/* 10 */
-	CHIP_TONGA,	/* 11 */
-	CHIP_FIJI,	/* 12 */
-	CHIP_CARRIZO,	/* 13 */
-	CHIP_STONEY,	/* 14 */
-	CHIP_POLARIS10,	/* 15 */
-	CHIP_POLARIS11,	/* 16 */
-	CHIP_POLARIS12,	/* 17 */
-	CHIP_VEGAM,	/* 18 */
-	CHIP_VEGA10,	/* 19 */
-	CHIP_VEGA12,	/* 20 */
-	CHIP_VEGA20,	/* 21 */
-	CHIP_RAVEN,	/* 22 */
-	CHIP_ARCTURUS,	/* 23 */
-	CHIP_RENOIR,	/* 24 */
-	CHIP_ALDEBARAN, /* 25 */
-	CHIP_NAVI10,	/* 26 */
-	CHIP_CYAN_SKILLFISH,	/* 27 */
-	CHIP_NAVI14,	/* 28 */
-	CHIP_NAVI12,	/* 29 */
-	CHIP_SIENNA_CICHLID,	/* 30 */
-	CHIP_NAVY_FLOUNDER,	/* 31 */
-	CHIP_VANGOGH,	/* 32 */
-	CHIP_DIMGREY_CAVEFISH,	/* 33 */
-	CHIP_BEIGE_GOBY,	/* 34 */
-	CHIP_YELLOW_CARP,	/* 35 */
+	CHIP_LIVERPOOL,	/* 9 */
+	CHIP_GLADIUS,	/* 10 */
+	CHIP_MULLINS,	/* 11 */
+	CHIP_TOPAZ,	/* 12 */
+	CHIP_TONGA,	/* 13 */
+	CHIP_FIJI,	/* 15 */
+	CHIP_CARRIZO,	/* 16 */
+	CHIP_STONEY,	/* 17 */
+	CHIP_POLARIS10,	/* 18 */
+	CHIP_POLARIS11,	/* 19 */
+	CHIP_POLARIS12,	/* 20 */
+	CHIP_VEGAM,	/* 21 */
+	CHIP_VEGA10,	/* 22 */
+	CHIP_VEGA12,	/* 23 */
+	CHIP_VEGA20,	/* 24 */
+	CHIP_RAVEN,	/* 25 */
+	CHIP_ARCTURUS,	/* 26 */
+	CHIP_RENOIR,	/* 27 */
+	CHIP_ALDEBARAN, /* 28 */
+	CHIP_NAVI10,	/* 29 */
+	CHIP_CYAN_SKILLFISH,	/* 30 */
+	CHIP_NAVI14,	/* 31 */
+	CHIP_NAVI12,	/* 32 */
+	CHIP_SIENNA_CICHLID,	/* 33 */
+	CHIP_NAVY_FLOUNDER,	/* 34 */
+	CHIP_VANGOGH,	/* 35 */
+	CHIP_DIMGREY_CAVEFISH,	/* 36 */
+	CHIP_BEIGE_GOBY,	/* 38 */
+	CHIP_YELLOW_CARP,	/* 39 */
 	CHIP_LAST,
 };
 
diff --git a/include/drm/drm_pciids.h b/include/drm/drm_pciids.h
index b7e899ce44f0..858f9e7667d0 100644
--- a/include/drm/drm_pciids.h
+++ b/include/drm/drm_pciids.h
@@ -281,6 +281,10 @@
 	{0x1002, 0x67B9, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x67BA, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x67BE, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_HAWAII|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9920, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9922, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9923, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_LIVERPOOL|RADEON_NEW_MEMMAP}, \
+	{0x1002, 0x9924, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_GLADIUS|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6800, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6801, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
 	{0x1002, 0x6802, PCI_ANY_ID, PCI_ANY_ID, 0, 0, CHIP_PITCAIRN|RADEON_IS_MOBILITY|RADEON_NEW_MEMMAP}, \
-- 
2.45.1

