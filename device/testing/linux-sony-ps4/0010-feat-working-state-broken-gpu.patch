From 92a4a84d51795f0a765a0dc6b3db08ca60b74805 Mon Sep 17 00:00:00 2001
From: codedwrench <rick.04.1996@gmail.com>
Date: Fri, 24 Dec 2021 22:40:25 +0100
Subject: [PATCH 10/22] feat: working state, broken gpu

---
 drivers/ata/ahci.c                    | 289 ++++++++++++++++++++++++++
 drivers/ata/ahci.h                    |  28 +++
 drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c |   6 +
 drivers/iommu/amd/iommu.c             |   1 +
 drivers/ps4/aeolia.h                  |   8 +-
 drivers/ps4/ps4-apcie.c               |  95 ++++++---
 6 files changed, 392 insertions(+), 35 deletions(-)

diff --git a/drivers/ata/ahci.c b/drivers/ata/ahci.c
index 149ee16fd022..5ba41c18b295 100644
--- a/drivers/ata/ahci.c
+++ b/drivers/ata/ahci.c
@@ -34,6 +34,10 @@
 #include <linux/io-64-nonatomic-lo-hi.h>
 #include "ahci.h"
 
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
+
 #define DRV_NAME	"ahci"
 #define DRV_VERSION	"3.0"
 
@@ -605,6 +609,11 @@ static const struct pci_device_id ahci_pci_tbl[] = {
 	/* Enmotus */
 	{ PCI_DEVICE(0x1c44, 0x8000), board_ahci },
 
+	/* Sony (PS4) */
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_AEOLIA_AHCI), board_ahci },
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_BELIZE_AHCI), board_ahci },
+	{ PCI_VDEVICE(SONY, PCI_DEVICE_ID_SONY_BAIKAL_AHCI), board_ahci },
+
 	/* Loongson */
 	{ PCI_VDEVICE(LOONGSON, 0x7a08), board_ahci },
 
@@ -954,6 +963,23 @@ static int ahci_configure_dma_masks(struct pci_dev *pdev, int using_dac)
 	if (pdev->dma_mask && pdev->dma_mask < DMA_BIT_MASK(32))
 		return 0;
 
+	#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		rc = dma_set_mask(&pdev->dev, DMA_BIT_MASK(31));
+		if (rc) {
+			dev_err(&pdev->dev, "31-bit DMA enable failed\n");
+			return rc;
+		}
+		rc = dma_set_coherent_mask(&pdev->dev, DMA_BIT_MASK(31));
+		if (rc) {
+			dev_err(&pdev->dev,
+				"31-bit consistent DMA enable failed\n");
+			return rc;
+		}
+		return 0;
+	}
+	#endif
+
 	rc = dma_set_mask_and_coherent(&pdev->dev, DMA_BIT_MASK(dma_bits));
 	if (rc)
 		dev_err(&pdev->dev, "DMA enable failed\n");
@@ -1574,6 +1600,12 @@ static int ahci_init_msi(struct pci_dev *pdev, unsigned int n_ports,
 {
 	int nvec;
 
+	#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		return apcie_assign_irqs(pdev, n_ports);
+	}
+	#endif
+
 	if (hpriv->flags & AHCI_HFLAG_NO_MSI)
 		return -ENODEV;
 
@@ -1700,6 +1732,13 @@ static int ahci_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
 
 	WARN_ON((int)ATA_MAX_QUEUE > AHCI_MAX_CMDS);
 
+	
+	#ifdef CONFIG_X86_PS4
+	/* This will return negative on non-PS4 platforms */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+	#endif
+
 	ata_print_version_once(&pdev->dev, DRV_VERSION);
 
 	/* The AHCI driver can only drive the SATA ports, the PATA driver
@@ -1947,8 +1986,258 @@ static void ahci_remove_one(struct pci_dev *pdev)
 				     NULL);
 	pm_runtime_get_noresume(&pdev->dev);
 	ata_pci_remove_one(pdev);
+
+	#ifdef CONFIG_X86_PS4
+	if (pdev->vendor == PCI_VENDOR_ID_SONY) {
+		apcie_free_irqs(pdev->irq, 1);
+	}
+	#endif
+}
+
+#ifdef CONFIG_X86_PS4
+void bpcie_sata_phy_init(struct device *dev, struct ahci_controller *ctlr)
+{
+	int i;
+	u32 v;
+	u32 v2;
+	bool is_phy_gen_3;
+	unsigned int trace_length;
+
+  	dev_info(dev, "Belize SATA PHY init\n");
+
+	for (i = 0; i < 100; i++) {
+		udelay(10000);
+	}
+
+ 	//step 1
+  	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x81);
+
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffff00) | 1);
+
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0xa5);
+
+	//step 2
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+
+	if (ctlr->dev_id == 0x90ca104d || ctlr->dev_id == 0x909f104d || ctlr->dev_id == 0x90d9104d) {
+		is_phy_gen_3 = false;
+		bpcie_ahci_write(ctlr->r_mem, 0x17c, v & 0xfffff3ff);
+	} else {
+		u32 v2 = bpcie_ahci_read(ctlr->r_mem, 0);
+	  	if ((v2 & 0xf00000) != 0x300000) {
+	    		bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff3ff) | 0x400);
+	    		is_phy_gen_3 = false;
+	  	} else {
+	    		 dev_info(dev,"PHY SET GEN3\n");
+	    		 bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff3ff) | 0x800);
+	    		 is_phy_gen_3 = true;
+	  	}
+	}
+
+	//--- step 3 ---
+	if (ctlr->trace_len == 0) {
+	  	trace_length = 6;
+	} else {
+	  	trace_length = ctlr->trace_len & 0x1f;
+	  	if (trace_length >= 0x13) {
+	    		trace_length = 6;
+	  	}
+	}
+
+	dev_info(dev,"Belize SATA PHY Trace length : %d\n",trace_length);
+
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0xa3);
+
+	//--- step 4 ---
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff3ff) | 0x800);
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0xd0);
+
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff800) | 0x441);
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0xe1);
+
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffff8f) | 0x60);
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0xd0);
+
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffff3fff) | 0x8000);
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0xf1);
+
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff3ff) | 0x400);
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x48);
+
+	//--- step 5 ---
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, 0x62d8);
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0xe);
+
+	//--- step 6 ---
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, v & 0xffffdfff);
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8d);
+
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, v | 1);
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8f);
+
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, v | 1);
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x91);
+
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, v | 1);
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8d);
+
+	//--- step 7 ---
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	if (trace_length >= 0xe) {
+		bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc1) | 0x28);
+	} else {
+		if (trace_length < 0xb) {
+	    		bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc1) | 8);
+	  	} else {
+	    		bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc1) | 0x10);
+	  	}
+	}
+
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8f);
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc1) | 0x12);
+
+	//--- step 8 ---
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x91);
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	if (trace_length < 5) {
+		bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc1) | 0x24);
+	} else {
+	  	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc1) | 0x2a);
+	}
+
+	//--- step 9 ---
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0xff);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, 1);
+
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x97);
+
+	//--- step 10 ---
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	if (is_phy_gen_3) {
+		bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffff80) | 0xd3);
+	} else {
+	  	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffff80) | 0xee);
+	}
+
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x95);
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffff00) | 0xee);
+
+	//--- step 11 ---
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0xff);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, 0);
+
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8d);
+
+	//--- step 12 ---
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	if (trace_length < 0xe) {
+		bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff87f) | 0x900);
+	} else {
+		bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff87f) | 0xe00);
+	}
+
+	//--- step 13 ---
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8f);
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff07f) | 0x900);
+
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x91);
+
+	//--- step 14 ---
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	if (is_phy_gen_3) {
+		bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff87f) | 0xd00);
+	} else {
+		bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xfffff87f) | 0xe80);
+	}
+
+	//--- step 15 ---
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 200);
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, v & 0xffffefff);
+
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 10);
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, v & 0xffffefff);
+
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x82);
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, v | 0x1000);
+
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0xc9);
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, v | 0x1000);
+
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x84);
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffffffc0) | 0xc);
+
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8d);
+
+	//--- step 16 ---
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	v = v & 0xffff0fff;
+	if (trace_length < 0xe) {
+		bpcie_ahci_write(ctlr->r_mem, 0x17c, v | 0x8000);
+	} else {
+		bpcie_ahci_write(ctlr->r_mem, 0x17c, v);
+	}
+
+	//--- step 17 ---
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0x8f);
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+	bpcie_ahci_write(ctlr->r_mem, 0x17c, (v & 0xffff0fff) | 0x8000);
+
+	//--- step 18 ---
+	bpcie_ahci_write(ctlr->r_mem, 0xa0, 0);
+	v = bpcie_ahci_read(ctlr->r_mem, 0xa4);
+	bpcie_ahci_write(ctlr->r_mem, 0xa4, v | 0x40);
+
+	//--- step 19 ---
+	if (ctlr->dev_id != 0x909f104d && ctlr->dev_id != 0x90ca104d && ctlr->dev_id != 0x90d9104d) {
+		v2 = 0x73000000;
+	} else {
+		v2 = 0x30000000;
+	}
+
+	//--- step 20 ---
+	bpcie_ahci_write(ctlr->r_mem, 0xa0, 4);
+	v = bpcie_ahci_read(ctlr->r_mem, 0xa4);
+	bpcie_ahci_write(ctlr->r_mem, 0xa4, (v & 0x88ffffff) | v2);
+
+	//--- step 21 ---
+	v = bpcie_ahci_read(ctlr->r_mem, 0xa4);
+
+	//--- step 22 ---
+	for (i = 0; i < 100; i++) {
+		udelay(10000);
+	}
+
+	//--- step 23 ---
+	bpcie_ahci_write(ctlr->r_mem, 0x178, 0xf9);
+	v = bpcie_ahci_read(ctlr->r_mem, 0x17c);
+
+	if (is_phy_gen_3) {
+		dev_info(dev,"Align 90=0x%02x\n",v & 0x7f);
+	}
+	//done!
 }
 
+EXPORT_SYMBOL_GPL(bpcie_sata_phy_init);
+#endif
+
 module_pci_driver(ahci_pci_driver);
 
 MODULE_AUTHOR("Jeff Garzik");
diff --git a/drivers/ata/ahci.h b/drivers/ata/ahci.h
index 60ae707a88cc..efdfac788727 100644
--- a/drivers/ata/ahci.h
+++ b/drivers/ata/ahci.h
@@ -447,4 +447,32 @@ static inline int ahci_nr_ports(u32 cap)
 	return (cap & 0x1f) + 1;
 }
 
+#ifdef CONFIG_X86_PS4
+struct f_resource{
+	u64 resource_i_ptr;
+	u64 r_bustag;
+	void __iomem * r_bushandle;
+};
+
+struct ahci_controller{
+	void *dev;
+	int dev_id;
+	struct f_resource *r_mem;
+	u32 trace_len;
+};
+
+void bpcie_sata_phy_init(struct device *dev, struct ahci_controller *ctlr);
+
+static inline void bpcie_ahci_write(struct f_resource *r_mem, u32 offset, u32 val) {
+	iowrite32(val, r_mem->r_bushandle + offset);
+}
+
+static inline u32 bpcie_ahci_read(struct f_resource *r_mem, u32 offset) {
+		return ioread32(r_mem->r_bushandle + offset);
+}
+#endif
+
+
+
+
 #endif /* _AHCI_H */
diff --git a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
index 752b66d7d0df..5e249922a72a 100644
--- a/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
+++ b/drivers/gpu/drm/amd/amdgpu/gmc_v7_0.c
@@ -1068,6 +1068,10 @@ static int gmc_v7_0_sw_init(void *handle)
 	if (r)
 		return r;
 
+
+	dev_info(adev->dev, "Done gart\n");
+
+
 	/*
 	 * number of VMs
 	 * VMID 0 is reserved for System
@@ -1093,6 +1097,8 @@ static int gmc_v7_0_sw_init(void *handle)
 		return -ENOMEM;
 	atomic_set(&adev->gmc.vm_fault_info_updated, 0);
 
+	dev_info(adev->dev, "Done init\n");
+
 	return 0;
 }
 
diff --git a/drivers/iommu/amd/iommu.c b/drivers/iommu/amd/iommu.c
index f20dc0c7b78f..4d36261e88a9 100644
--- a/drivers/iommu/amd/iommu.c
+++ b/drivers/iommu/amd/iommu.c
@@ -3300,6 +3300,7 @@ static int irq_remapping_select(struct irq_domain *d, struct irq_fwspec *fwspec,
 	if (devid < 0)
 		return 0;
 
+	pr_err("Remapping Selected: %x\n", devid);
 	iommu = amd_iommu_rlookup_table[devid];
 	return iommu && iommu->ir_domain == d;
 }
diff --git a/drivers/ps4/aeolia.h b/drivers/ps4/aeolia.h
index 13df4b9a4fef..5319822ca818 100644
--- a/drivers/ps4/aeolia.h
+++ b/drivers/ps4/aeolia.h
@@ -151,11 +151,11 @@ struct apcie_dev {
 	struct apcie_icc_dev icc;
 };
 
-#define sc_err(...) dev_err(&sc->pdev->dev, __VA_ARGS__)
-#define sc_warn(...) dev_warn(&sc->pdev->dev, __VA_ARGS__)
-#define sc_notice(...) dev_notice(&sc->pdev->dev, __VA_ARGS__)
+#define sc_err(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
+#define sc_warn(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
+#define sc_notice(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
 #define sc_info(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
-#define sc_dbg(...) dev_dbg(&sc->pdev->dev, __VA_ARGS__)
+#define sc_dbg(...) dev_info(&sc->pdev->dev, __VA_ARGS__)
 
 static inline int apcie_irqnum(struct apcie_dev *sc, int index)
 {
diff --git a/drivers/ps4/ps4-apcie.c b/drivers/ps4/ps4-apcie.c
index d9c36f7715bb..f4e3a380d591 100644
--- a/drivers/ps4/ps4-apcie.c
+++ b/drivers/ps4/ps4-apcie.c
@@ -18,6 +18,11 @@
 
 #include "aeolia.h"
 
+
+#define     MSI_DATA_VECTOR_SHIFT	0
+#define	    MSI_DATA_VECTOR(v)		(((u8)v) << MSI_DATA_VECTOR_SHIFT)
+#define     MSI_DATA_VECTOR_MASK	0xffffff00
+
 /* #define QEMU_HACK_NO_IOMMU */
 
 /* Number of implemented MSI registers per function */
@@ -63,12 +68,20 @@ static void apcie_config_msi(struct apcie_dev *sc, u32 func, u32 subfunc,
 
 	glue_clear_mask(sc, APCIE_REG_MSI_CONTROL, APCIE_REG_MSI_CONTROL_ENABLE);
 	/* Unknown */
+	sc_dbg("glue_write32 to offset, value (%08x, %08x, %08x)\n", sc->bar4, APCIE_REG_MSI(0x8), 0xffffffff);
 	glue_write32(sc, APCIE_REG_MSI(0x8), 0xffffffff);
 	/* Unknown */
+	sc_dbg("glue_write32 to offset, value (%08x, %08x, %08x)\n", sc->bar4, APCIE_REG_MSI(0xc + (func << 2)), 0xB7FFFF00 + func * 16);
 	glue_write32(sc, APCIE_REG_MSI(0xc + (func << 2)), 0xB7FFFF00 + func * 16);
+
+	sc_dbg("glue_write32 to offset, value (%08x, %08x, %08x)\n", sc->bar4, APCIE_REG_MSI_ADDR(func), addr);
 	glue_write32(sc, APCIE_REG_MSI_ADDR(func), addr);
 	/* Unknown */
+
+	sc_dbg("glue_write32 to offset, value (%08x, %08x, %08x)\n", sc->bar4, APCIE_REG_MSI(0xcc + (func << 2)), 0);
 	glue_write32(sc, APCIE_REG_MSI(0xcc + (func << 2)), 0);
+
+	sc_dbg("glue_write32 to offset, value (%08x, %08x, %08x)\n", sc->bar4, APCIE_REG_MSI_DATA_HI(func),  data & 0xffe0);
 	glue_write32(sc, APCIE_REG_MSI_DATA_HI(func), data & 0xffe0);
 
 	if (func < 4) {
@@ -84,6 +97,8 @@ static void apcie_config_msi(struct apcie_dev *sc, u32 func, u32 subfunc,
 	} else {
 		offset = 0xa0 + ((func - 5) << 4) + (subfunc << 2);
 	}
+
+	sc_dbg("glue_write32 to offset, value (%08x, %08x, %08x)\n", sc->bar4,  APCIE_REG_MSI_DATA_LO(offset), data & 0x1f);
 	glue_write32(sc, APCIE_REG_MSI_DATA_LO(offset), data & 0x1f);
 
 	if (func == AEOLIA_FUNC_ID_PCIE)
@@ -149,9 +164,17 @@ static void apcie_msi_calc_mask(struct irq_data *data) {
 static void apcie_irq_msi_compose_msg(struct irq_data *data,
 				       struct msi_msg *msg)
 {
-       __irq_msi_compose_msg(irqd_cfg(data), msg, false);
-}
+	struct irq_cfg *cfg = irqd_cfg(data);
 
+	memset(msg, 0, sizeof(*msg));
+	msg->address_hi = X86_MSI_BASE_ADDRESS_HIGH;
+	msg->address_lo = 0xfee00000;// Just do it like this for now
+
+	// I know this is absolute horseshit, but it matches a known working kernel
+	msg->data = data->irq - 1;
+
+	pr_err("apcie_irq_msi_compose_msg\n");
+}
 
 static struct irq_chip apcie_msi_controller = {
 	.name = "Aeolia-MSI",
@@ -162,7 +185,7 @@ static struct irq_chip apcie_msi_controller = {
 	.irq_retrigger = irq_chip_retrigger_hierarchy,
 	.irq_compose_msi_msg = apcie_irq_msi_compose_msg,
 	.irq_write_msi_msg = apcie_msi_write_msg,
-	.flags = IRQCHIP_SKIP_SET_WAKE,
+	.flags = IRQCHIP_SKIP_SET_WAKE | IRQCHIP_AFFINITY_PRE_STARTUP,
 };
 
 static irq_hw_number_t apcie_msi_get_hwirq(struct msi_domain_info *info,
@@ -176,7 +199,7 @@ static int apcie_msi_init(struct irq_domain *domain,
 			 irq_hw_number_t hwirq, msi_alloc_info_t *arg)
 {
 	struct irq_data *data;
-	pr_devel("apcie_msi_init(%p, %p, %d, 0x%lx, %p)\n", domain, info, virq, hwirq, arg);
+	pr_err("apcie_msi_init(%p, %p, %d, 0x%lx, %p)\n", domain, info, virq, hwirq, arg);
 
 	data = irq_domain_get_irq_data(domain, virq);
 	irq_domain_set_info(domain, virq, hwirq, info->chip, info->chip_data,
@@ -188,23 +211,25 @@ static int apcie_msi_init(struct irq_domain *domain,
 static void apcie_msi_free(struct irq_domain *domain,
 			  struct msi_domain_info *info, unsigned int virq)
 {
-	pr_devel("apcie_msi_free(%d)\n", virq);
+	pr_err("apcie_msi_free(%d)\n", virq);
 }
 
-int apcie_msi_prepare(struct irq_domain *domain, struct device *dev, int nvec,
-		     msi_alloc_info_t *arg)
+
+static void apcie_set_desc(msi_alloc_info_t *arg, struct msi_desc *desc)
 {
-	init_irq_alloc_info(arg, NULL);
+	arg->desc = desc;
+	struct pci_dev* device = msi_desc_to_pci_dev(desc);
 
-	arg->type = X86_IRQ_ALLOC_TYPE_PCI_MSI;
-	arg->flags |= MSI_FLAG_MULTI_PCI_MSI;
+	arg->hwirq = PCI_FUNC(device->devfn) << 8;
 
-	return 0;
+#ifndef QEMU_HACK_NO_IOMMU
+	arg->hwirq |= 0xFF;
+#endif
 }
 
 static struct msi_domain_ops apcie_msi_domain_ops = {
 	.get_hwirq	= apcie_msi_get_hwirq,
-	.msi_prepare	= apcie_msi_prepare,
+	.set_desc       = apcie_set_desc,
 	.msi_init	= apcie_msi_init,
 	.msi_free	= apcie_msi_free,
 };
@@ -219,7 +244,6 @@ static struct msi_domain_info apcie_msi_domain_info = {
 
 static struct irq_domain *apcie_create_irq_domain(struct apcie_dev *sc)
 {
-	struct msi_domain_info *domain_info;
 	struct irq_domain *domain, *parent;
 	struct fwnode_handle *fn;
 	struct irq_fwspec fwspec;
@@ -228,19 +252,15 @@ static struct irq_domain *apcie_create_irq_domain(struct apcie_dev *sc)
 	if (x86_vector_domain == NULL)
 		return NULL;
 
-	domain_info = kzalloc(sizeof(*domain_info), GFP_KERNEL);
-	if (!domain_info)
-		return NULL;
-
-	*domain_info = apcie_msi_domain_info;
-	domain_info->chip_data = (void *)sc;
+	apcie_msi_domain_info.chip_data = (void *)sc;
 
 	fn = irq_domain_alloc_named_id_fwnode(apcie_msi_controller.name, pci_dev_id(sc->pdev));
 	if (!fn) {
-		kfree(domain_info);
 		return NULL;
 	}
 
+	sc_dbg("devid = %d\n", pci_dev_id(sc->pdev));
+
 	fwspec.fwnode = fn;
 	fwspec.param_count = 1;
 
@@ -249,17 +269,19 @@ static struct irq_domain *apcie_create_irq_domain(struct apcie_dev *sc)
 
 	parent = irq_find_matching_fwspec(&fwspec, DOMAIN_BUS_ANY);
 	if (!parent) {
+		sc_dbg("no parent \n");
 		parent = x86_vector_domain;
+	} else if (parent == x86_vector_domain) {
+		sc_dbg("no parent \n");
 	} else {
 		apcie_msi_domain_info.flags |= MSI_FLAG_MULTI_PCI_MSI;
 		apcie_msi_controller.name = "IR-Aeolia-MSI";
 	}
 
-	domain = msi_create_irq_domain(fn, domain_info, parent);
+	domain = msi_create_irq_domain(fn, &apcie_msi_domain_info, parent);
 	if (!domain) {
 		irq_domain_free_fwnode(fn);
-		kfree(domain_info);
-		pr_warn("Failed to initialize IR-Aeolia-MSI irqdomain.\n");
+		pr_warn("Failed to initialize Aeolia-MSI irqdomain.\n");
 	}
 
 	return domain;
@@ -302,15 +324,17 @@ int apcie_assign_irqs(struct pci_dev *dev, int nvec)
 	info.type = X86_IRQ_ALLOC_TYPE_PCI_MSI;
 	/* IRQs "come from" function 4 as far as the IOMMU/system see */
 	//info.msi_dev = sc->pdev;
-	info.desc = alloc_msi_entry(&dev->dev, nvec, NULL);
+	info.devid = pci_dev_id(sc->pdev);
+
+	int i, base = 0;
+	struct msi_desc *desc;
+	struct device* bare_dev = &sc->pdev->dev;
+
 	/* Our hwirq number is function << 8 plus subfunction.
 	 * Subfunction is usually 0 and implicitly increments per hwirq,
 	 * but can also be 0xff to indicate that this is a shared IRQ. */
-	//https://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git/commit/?id=3b9c1d377d67072d1d8a2373b4969103cca00dab
 	info.hwirq = PCI_FUNC(dev->devfn) << 8;
 
-	dev_dbg(&dev->dev, "apcie_assign_irqs(%d)\n", nvec);
-
 #ifndef QEMU_HACK_NO_IOMMU
 	info.flags = X86_IRQ_ALLOC_CONTIGUOUS_VECTORS;
 	if (!(apcie_msi_domain_info.flags & MSI_FLAG_MULTI_PCI_MSI)) {
@@ -319,14 +343,23 @@ int apcie_assign_irqs(struct pci_dev *dev, int nvec)
 	}
 #endif
 
+	desc = alloc_msi_entry(bare_dev, 1, NULL);
+
+	info.desc = desc;
+	info.data = sc;
+
+	dev_info(&dev->dev, "apcie_assign_irqs(%d) (%d)\n", nvec, info.hwirq);
+
 	ret = irq_domain_alloc_irqs(sc->irqdomain, nvec, NUMA_NO_NODE, &info);
 	if (ret >= 0) {
+		dev_info(&dev->dev, "irq_domain_alloc_irqs = %x\n", ret);
 		dev->irq = ret;
+		desc->irq = ret;
 		ret = nvec;
 	}
 
 fail:
-	dev_dbg(&dev->dev, "apcie_assign_irqs returning %d\n", ret);
+	dev_info(&dev->dev, "apcie_assign_irqs returning %d\n", ret);
 	if (sc_dev)
 		pci_dev_put(sc_dev);
 	return ret;
@@ -494,10 +527,10 @@ static int apcie_probe(struct pci_dev *dev, const struct pci_device_id *id) {
 
 	if ((ret = apcie_glue_init(sc)) < 0)
 		goto free_bars;
-	if ((ret = apcie_uart_init(sc)) < 0)
-		goto remove_glue;
+	//if ((ret = apcie_uart_init(sc)) < 0)
+	//	goto remove_glue;
 	if ((ret = apcie_icc_init(sc)) < 0)
-		goto remove_uart;
+		goto remove_glue;
 
 	apcie_initialized = true;
 	return 0;
-- 
2.45.1

