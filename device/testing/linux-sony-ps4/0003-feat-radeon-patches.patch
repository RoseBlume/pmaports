From 246294ab578bb46cdcba26ebca73246089e2043b Mon Sep 17 00:00:00 2001
From: codedwrench <rick.04.1996@gmail.com>
Date: Mon, 20 Dec 2021 13:59:32 +0100
Subject: [PATCH 03/22] feat: radeon patches

---
 drivers/gpu/drm/radeon/Makefile            |   2 +
 drivers/gpu/drm/radeon/atombios_encoders.c |   3 +-
 drivers/gpu/drm/radeon/cik.c               | 714 ++++++++++++++++++-
 drivers/gpu/drm/radeon/cik_sdma.c          |  51 +-
 drivers/gpu/drm/radeon/cikd.h              |  24 +
 drivers/gpu/drm/radeon/ps4_bridge.c        | 758 +++++++++++++++++++++
 drivers/gpu/drm/radeon/radeon.h            |   3 +-
 drivers/gpu/drm/radeon/radeon_asic.c       |  19 +-
 drivers/gpu/drm/radeon/radeon_audio.c      |  10 +-
 drivers/gpu/drm/radeon/radeon_connectors.c |  57 +-
 drivers/gpu/drm/radeon/radeon_device.c     |   1 +
 drivers/gpu/drm/radeon/radeon_display.c    |   2 +-
 drivers/gpu/drm/radeon/radeon_drv.c        |  15 +
 drivers/gpu/drm/radeon/radeon_encoders.c   |  19 +
 drivers/gpu/drm/radeon/radeon_family.h     |   1 +
 drivers/gpu/drm/radeon/radeon_ib.c         |   9 +-
 drivers/gpu/drm/radeon/radeon_pm.c         |   1 +
 drivers/gpu/drm/radeon/radeon_ucode.h      |   3 +
 drivers/gpu/drm/radeon/radeon_uvd.c        |   1 +
 drivers/gpu/drm/radeon/radeon_vce.c        |   1 +
 20 files changed, 1663 insertions(+), 31 deletions(-)
 create mode 100644 drivers/gpu/drm/radeon/ps4_bridge.c

diff --git a/drivers/gpu/drm/radeon/Makefile b/drivers/gpu/drm/radeon/Makefile
index 3d502f1bbfcb..9735ac7a69fa 100644
--- a/drivers/gpu/drm/radeon/Makefile
+++ b/drivers/gpu/drm/radeon/Makefile
@@ -53,6 +53,8 @@ radeon-y += radeon_device.o radeon_asic.o radeon_kms.o \
 
 radeon-$(CONFIG_MMU_NOTIFIER) += radeon_mn.o
 
+radeon-$(CONFIG_X86_PS4) += ps4_bridge.o
+
 # add async DMA block
 radeon-y += \
 	r600_dma.o \
diff --git a/drivers/gpu/drm/radeon/atombios_encoders.c b/drivers/gpu/drm/radeon/atombios_encoders.c
index 2b4491137217..12f2f35be471 100644
--- a/drivers/gpu/drm/radeon/atombios_encoders.c
+++ b/drivers/gpu/drm/radeon/atombios_encoders.c
@@ -691,7 +691,8 @@ atombios_get_encoder_mode(struct drm_encoder *encoder)
 	if (radeon_encoder->is_mst_encoder || radeon_encoder->offset)
 		return ATOM_ENCODER_MODE_DP_MST;
 	/* dp bridges are always DP */
-	if (radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE)
+	if (radeon_encoder_get_dp_bridge_encoder_id(encoder) != ENCODER_OBJECT_ID_NONE ||
+	    (rdev->family == CHIP_LIVERPOOL))
 		return ATOM_ENCODER_MODE_DP;
 
 	/* DVO is always DVO */
diff --git a/drivers/gpu/drm/radeon/cik.c b/drivers/gpu/drm/radeon/cik.c
index 81b4de7be9f2..f6ca400c006f 100644
--- a/drivers/gpu/drm/radeon/cik.c
+++ b/drivers/gpu/drm/radeon/cik.c
@@ -122,6 +122,13 @@ MODULE_FIRMWARE("radeon/MULLINS_mec.bin");
 MODULE_FIRMWARE("radeon/MULLINS_rlc.bin");
 MODULE_FIRMWARE("radeon/MULLINS_sdma.bin");
 
+MODULE_FIRMWARE("radeon/LIVERPOOL_pfp.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_me.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_ce.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_mec.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_rlc.bin");
+MODULE_FIRMWARE("radeon/LIVERPOOL_sdma.bin");
+
 MODULE_FIRMWARE("radeon/mullins_pfp.bin");
 MODULE_FIRMWARE("radeon/mullins_me.bin");
 MODULE_FIRMWARE("radeon/mullins_ce.bin");
@@ -1031,6 +1038,421 @@ static const u32 kalindi_rlc_save_restore_register_list[] =
 	(0x0e00 << 16) | (0x9600 >> 2),
 };
 
+static const u32 liverpool_rlc_save_restore_register_li
+{
+	(0x0600 << 16) | 0x263d,
+	0x00000000,
+	(0x0680 << 16) | 0x263d,
+	0x00000000,
+	(0x0e00 << 16) | 0x263e,
+	0x00000000,
+	(0x0e00 << 16) | 0x2640,
+	0x00000000,
+	(0x0e00 << 16) | 0x3098,
+	0x00000000,
+	(0x0e00 << 16) | 0x243a,
+	0x00000000,
+	(0x0e00 << 16) | 0xf000,
+	0x00000000,
+	(0x0e00 << 16) | 0xf003,
+	0x00000000,
+	(0x0e00 << 16) | 0x2307,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c0,
+	0x00000000,
+	(0x0e00 << 16) | 0x3348,
+	0x00000000,
+	(0x1e00 << 16) | 0x3348,
+	0x00000000,
+	(0x4e00 << 16) | 0x3348,
+	0x00000000,
+	(0x5e00 << 16) | 0x3348,
+	0x00000000,
+	(0x6e00 << 16) | 0x3348,
+	0x00000000,
+	(0x7e00 << 16) | 0x3348,
+	0x00000000,
+	(0x8e00 << 16) | 0x3348,
+	0x00000000,
+	(0x9e00 << 16) | 0x3348,
+	0x00000000,
+	(0xae00 << 16) | 0x3348,
+	0x00000000,
+	(0xbe00 << 16) | 0x3348,
+	0x00000000,
+	(0x0400 << 16) | 0x226f,
+	0x00000000,
+	(0x0480 << 16) | 0x226f,
+	0x00000000,
+	(0x0e00 << 16) | 0x2240,
+	0x00000000,
+	0x3,
+	(0x0e00 << 16) | 0x260d,
+	0x00000000,
+	(0x0000 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0001 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0002 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0003 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0080 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0081 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0082 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0083 << 16) | 0xc3c0,
+	0x00000000,
+	(0x0000 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0001 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0002 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0003 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0080 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0081 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0082 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0083 << 16) | 0xc3c1,
+	0x00000000,
+	(0x0000 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0001 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0002 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0003 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0080 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0081 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0082 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0083 << 16) | 0xc3c2,
+	0x00000000,
+	(0x0000 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0001 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0002 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0003 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0080 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0081 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0082 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0083 << 16) | 0xc3c3,
+	0x00000000,
+	(0x0600 << 16) | 0x26df,
+	0x00000000,
+	(0x0680 << 16) | 0x26df,
+	0x00000000,
+	(0x0e00 << 16) | 0x2285,
+	0x00000000,
+	(0x0e00 << 16) | 0x2286,
+	0x00000000,
+	(0x0600 << 16) | 0xc280,
+	0x00000000,
+	(0x0680 << 16) | 0xc280,
+	0x00000000,
+	(0x1600 << 16) | 0xc280,
+	0x00000000,
+	(0x1680 << 16) | 0xc280,
+	0x00000000,
+	(0x0e00 << 16) | 0x22fc,
+	0x00000000,
+	(0x0e00 << 16) | 0x22f3,
+	0x00000000,
+	(0x0e00 << 16) | 0x22c9,
+	0x00000000,
+	(0x0e00 << 16) | 0xc281,
+	0x00000000,
+	(0x1e00 << 16) | 0xc281,
+	0x00000000,
+	(0x0600 << 16) | 0xc284,
+	0x00000000,
+	(0x0680 << 16) | 0xc284,
+	0x00000000,
+	(0x1600 << 16) | 0xc284,
+	0x00000000,
+	(0x1680 << 16) | 0xc284,
+	0x00000000,
+	(0x0600 << 16) | 0xc285,
+	0x00000000,
+	(0x0680 << 16) | 0xc285,
+	0x00000000,
+	(0x1600 << 16) | 0xc285,
+	0x00000000,
+	(0x1680 << 16) | 0xc285,
+	0x00000000,
+	(0x0600 << 16) | 0xc286,
+	0x00000000,
+	(0x0680 << 16) | 0xc286,
+	0x00000000,
+	(0x1600 << 16) | 0xc286,
+	0x00000000,
+	(0x1680 << 16) | 0xc286,
+	0x00000000,
+	(0x0600 << 16) | 0xc28b,
+	0x00000000,
+	(0x0680 << 16) | 0xc28b,
+	0x00000000,
+	(0x1600 << 16) | 0xc28b,
+	0x00000000,
+	(0x1680 << 16) | 0xc28b,
+	0x00000000,
+	(0x0e00 << 16) | 0x31c0,
+	0x00000000,
+	(0x0e00 << 16) | 0x31c1,
+	0x00000000,
+	(0x0e00 << 16) | 0x31c2,
+	0x00000000,
+	(0x0e00 << 16) | 0x31da,
+	0x00000000,
+	(0x0400 << 16) | 0x31dc,
+	0x00000000,
+	(0x0480 << 16) | 0x31dc,
+	0x00000000,
+	(0x0400 << 16) | 0x31dd,
+	0x00000000,
+	(0x0480 << 16) | 0x31dd,
+	0x00000000,
+	(0x0400 << 16) | 0x31de,
+	0x00000000,
+	(0x0480 << 16) | 0x31de,
+	0x00000000,
+	(0x0400 << 16) | 0x31df,
+	0x00000000,
+	(0x0480 << 16) | 0x31df,
+	0x00000000,
+	(0x0400 << 16) | 0x31e0,
+	0x00000000,
+	(0x0480 << 16) | 0x31e0,
+	0x00000000,
+	(0x0400 << 16) | 0x31e1,
+	0x00000000,
+	(0x0480 << 16) | 0x31e1,
+	0x00000000,
+	(0x0400 << 16) | 0x31e2,
+	0x00000000,
+	(0x0480 << 16) | 0x31e2,
+	0x00000000,
+	(0x0400 << 16) | 0x31e3,
+	0x00000000,
+	(0x0480 << 16) | 0x31e3,
+	0x00000000,
+	(0x0400 << 16) | 0x31e4,
+	0x00000000,
+	(0x0480 << 16) | 0x31e4,
+	0x00000000,
+	(0x0400 << 16) | 0x31e5,
+	0x00000000,
+	(0x0480 << 16) | 0x31e5,
+	0x00000000,
+	(0x0400 << 16) | 0x31e6,
+	0x00000000,
+	(0x0480 << 16) | 0x31e6,
+	0x00000000,
+	(0x0400 << 16) | 0x31e7,
+	0x00000000,
+	(0x0480 << 16) | 0x31e7,
+	0x00000000,
+	(0x0400 << 16) | 0x31e8,
+	0x00000000,
+	(0x0480 << 16) | 0x31e8,
+	0x00000000,
+	(0x0400 << 16) | 0x31e9,
+	0x00000000,
+	(0x0480 << 16) | 0x31e9,
+	0x00000000,
+	(0x0400 << 16) | 0x31ea,
+	0x00000000,
+	(0x0480 << 16) | 0x31ea,
+	0x00000000,
+	(0x0400 << 16) | 0x31eb,
+	0x00000000,
+	(0x0480 << 16) | 0x31eb,
+	0x00000000,
+	(0x0400 << 16) | 0x31ec,
+	0x00000000,
+	(0x0480 << 16) | 0x31ec,
+	0x00000000,
+	(0x0400 << 16) | 0x31ed,
+	0x00000000,
+	(0x0480 << 16) | 0x31ed,
+	0x00000000,
+	(0x0400 << 16) | 0x31ee,
+	0x00000000,
+	(0x0480 << 16) | 0x31ee,
+	0x00000000,
+	(0x0400 << 16) | 0x31ef,
+	0x00000000,
+	(0x0480 << 16) | 0x31ef,
+	0x00000000,
+	(0x0e00 << 16) | 0x2440,
+	0x00000000,
+	(0x0e00 << 16) | 0xf004,
+	0x00000000,
+	(0x0e00 << 16) | 0x24aa,
+	0x00000000,
+	(0x0e00 << 16) | 0x24ab,
+	0x00000000,
+	(0x0e00 << 16) | 0x24ac,
+	0x00000000,
+	(0x0e00 << 16) | 0x24ad,
+	0x00000000,
+	(0x0e00 << 16) | 0x24ae,
+	0x00000000,
+	(0x0e00 << 16) | 0x24af,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b0,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b1,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b2,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b3,
+	0x00000000,
+	(0x0e00 << 16) | 0x24b4,
+	0x00000000,
+	(0x0e00 << 16) | 0x2300,
+	0x00000000,
+	(0x0e00 << 16) | 0x2301,
+	0x00000000,
+	(0x0e00 << 16) | 0x2308,
+	0x00000000,
+	(0x0e00 << 16) | 0x230e,
+	0x00000000,
+	(0x0e00 << 16) | 0x230f,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b80,
+	0x00000000,
+	(0x0e00 << 16) | 0x2581,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b02,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b03,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b04,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b05,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b16,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1a,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1b,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1c,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1d,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1e,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b1f,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b20,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b21,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b22,
+	0x00000000,
+	(0x0e00 << 16) | 0x2b23,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c3,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c5,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c6,
+	0x00000000,
+	(0x0e00 << 16) | 0x25c7,
+	0x00000000,
+	(0x0e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x1e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x4e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x5e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x6e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x7e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x8e00 << 16) | 0xc41a,
+	0x00000000,
+	(0x9e00 << 16) | 0xc41a,
+	0x00000000,
+	(0xae00 << 16) | 0xc41a,
+	0x00000000,
+	(0xbe00 << 16) | 0xc41a,
+	0x00000000,
+	(0x0e00 << 16) | 0x3344,
+	0x00000000,
+	(0x0e00 << 16) | 0x3345,
+	0x00000000,
+	(0x0e00 << 16) | 0x222c,
+	0x00000000,
+	(0x0e00 << 16) | 0x222d,
+	0x00000000,
+	(0x0e00 << 16) | 0x222e,
+	0x00000000,
+	(0x0e00 << 16) | 0x222f,
+	0x00000000,
+	(0x0400 << 16) | 0x2270,
+	0x00000000,
+	(0x0480 << 16) | 0x2270,
+	0x00000000,
+	(0x0e00 << 16) | 0x2231,
+	0x00000000,
+	(0x0e00 << 16) | 0x2274,
+	0x00000000,
+	(0x0e00 << 16) | 0x2234,
+	0x00000000,
+	(0x0e00 << 16) | 0x2235,
+	0x00000000,
+	(0x0e00 << 16) | 0x2236,
+	0x00000000,
+	(0x0e00 << 16) | 0x2260,
+	0x00000000,
+	(0x0e00 << 16) | 0x2262,
+	0x00000000,
+	(0x0e00 << 16) | 0x226c,
+	0x00000000,
+	(0x0e00 << 16) | 0x226e,
+	0x00000000,
+	(0x0e00 << 16) | 0x2268,
+	0x00000000,
+	(0x0e00 << 16) | 0x2232,
+	0x00000000,
+	(0x0e00 << 16) | 0x2233,
+	0x00000000,
+	(0x0e00 << 16) | 0x226d,
+	0x00000000,
+	(0x0e00 << 16) | 0xf87f,
+	0x00000000,
+	(0x0e00 << 16) | 0xf084,
+	0x00000000,
+	(0x0e00 << 16) | 0xf085,
+	0x00000000,
+	(0x0e00 << 16) | 0xf086,
+	0x00000000,
+	(0x0e00 << 16) | 0x2241,
+	0x00000000,
+	1,
+	(0x0e00 << 16) | 0x230d,
+};
+
 static const u32 bonaire_golden_spm_registers[] =
 {
 	0x30800, 0xe0ffffff, 0xe0000000
@@ -1175,6 +1597,163 @@ static const u32 bonaire_mgcg_cgcg_init[] =
 	0xd80c, 0xff000ff0, 0x00000100
 };
 
+static const u32 liverpool_golden_common_registers[] =
+{
+	0xc770, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+	0xc774, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+	0xc798, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+	0xc79c, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1 */
+	0xc7a0, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+	0xc7a4, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3*/
+	0xc7a8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+	0xc7ac, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5 */
+	0xc7b0, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+	0xc7b4, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+	0xc7b8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+	0xc7bc, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+	0x28350, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+	0x28354, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+	0x5004, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+};
+
+onst u32 liverpool_golden_registers[] =
+{
+	0xc420, 0xffffffff, 0xfffffffc, /* RLC_CGTT_MGCG_OVERRIDE */
+	0x30800, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	/* These are all setting OFF_HYSTERESIS = 0x10 */
+	0x3c2a0, 0xffffffff, 0x00000100, /* CB_CGTT_SCLK_CTRL */
+	0x3c208, 0xffffffff, 0x00000100, /* CGTT_BCI_CLK_CTRL */
+	0x3c2c0, 0xffffffff, 0x00000100, /* CGTT_CP_CLK_CTRL */
+	0x3c2c8, 0xffffffff, 0x00000100, /* CGTT_CPC_CLK_CTRL */
+	0x3c2c4, 0xffffffff, 0x00000100, /* CGTT_CPF_CLK_CTRL */
+	0x55e4, 0xffffffff, 0x00600100, /* CGTT_DRM_CLK_CTRL0 */
+	0x3c280, 0xffffffff, 0x00000100, /* CGTT_GDS_CLK_CTRL */
+	0x3c214, 0xffffffff, 0x06000100, /* CGTT_IA_CLK_CTRL */
+	0x3c220, 0xffffffff, 0x00000100, /* CGTT_PA_CLK_CTRL */
+	0x3c218, 0xffffffff, 0x06000100, /* CGTT_WD_CLK_CTRL */
+	0x3c204, 0xffffffff, 0x00000100, /* CGTT_PC_CLK_CTRL */
+	0x3c2e0, 0xffffffff, 0x00000100, /* CGTT_RLC_CLK_CTRL */
+	0x3c224, 0xffffffff, 0x00000100, /* CGTT_SC_CLK_CTRL */
+	0x3c200, 0xffffffff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0x3c230, 0xffffffff, 0x00000100, /* CGTT_SQ_CLK_CTRL */
+	0x3c234, 0xffffffff, 0x00000100, /* CGTT_SQG_CLK_CTRL */
+	0x3c250, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL0 */
+	0x3c254, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL1 */
+	0x3c258, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL2 */
+	0x3c25c, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL3 */
+	0x3c260, 0xffffffff, 0x00000100, /* CGTT_SX_CLK_CTRL4 */
+	0x3c27c, 0xffffffff, 0x00000100, /* CGTT_TCI_CLK_CTRL */
+	0x3c278, 0xffffffff, 0x00000100, /* CGTT_TCP_CLK_CTRL */
+	0x3c210, 0xffffffff, 0x06000100, /* CGTT_VGT_CLK_CTRL */
+	0x3c290, 0xffffffff, 0x00000100, /* DB_CGTT_CLK_CTRL_0 */
+	0x3c274, 0xffffffff, 0x00000100, /* TA_CGTT_CTRL */
+	0x3c2b4, 0xffffffff, 0x00000100, /* TCA_CGTT_SCLK_CTRL */
+	0x3c2b0, 0xffffffff, 0x00000100, /* TCC_CGTT_SCLK_CTRL */
+	0x3c270, 0xffffffff, 0x00000100, /* TD_CGTT_CTRL */
+	0x30800, 0xffffffff, 0xe0000000, /* GRBM_GFX_INDEX */
+	0x3c020, 0xffffffff, 0x00010000, /* CGTS_CU0_SP0_CTRL_REG */
+	0x3c024, 0xffffffff, 0x00030002, /* CGTS_CU0_LDS_SQ_CTRL_REG */
+	0x3c028, 0xffffffff, 0x00040007, /* CGTS_CU0_TA_SQC_CTRL_REG */
+	0x3c02c, 0xffffffff, 0x00060005, /* CGTS_CU0_SP1_CTRL_REG */
+	0x3c030, 0xffffffff, 0x00090008, /* CGTS_CU0_TD_TCP_CTRL_REG */
+	0x3c034, 0xffffffff, 0x00010000, /* CGTS_CU1_SP0_CTRL_REG */
+	0x3c038, 0xffffffff, 0x00030002, /* CGTS_CU1_LDS_SQ_CTRL_REG */
+	0x3c03c, 0xffffffff, 0x00040007, /* CGTS_CU1_TA_CTRL_REG */
+	0x3c040, 0xffffffff, 0x00060005, /* CGTS_CU1_SP1_CTRL_REG */
+	0x3c044, 0xffffffff, 0x00090008, /* CGTS_CU1_TD_TCP_CTRL_REG */
+	0x3c048, 0xffffffff, 0x00010000, /* CGTS_CU2_SP0_CTRL_REG */
+	0x3c04c, 0xffffffff, 0x00030002, /* CGTS_CU2_LDS_SQ_CTRL_REG */
+	0x3c050, 0xffffffff, 0x00040007, /* CGTS_CU2_TA_CTRL_REG */
+	0x3c054, 0xffffffff, 0x00060005, /* CGTS_CU2_SP1_CTRL_REG */
+	0x3c058, 0xffffffff, 0x00090008, /* CGTS_CU2_TD_TCP_CTRL_REG */
+	0x3c05c, 0xffffffff, 0x00010000, /* CGTS_CU3_SP0_CTRL_REG */
+	0x3c060, 0xffffffff, 0x00030002, /* CGTS_CU3_LDS_SQ_CTRL_REG */
+	0x3c064, 0xffffffff, 0x00040007, /* CGTS_CU3_TA_SQC_CTRL_REG */
+	0x3c068, 0xffffffff, 0x00060005, /* CGTS_CU3_SP1_CTRL_REG */
+	0x3c06c, 0xffffffff, 0x00090008, /* CGTS_CU3_TD_TCP_CTRL_REG */
+	0x3c070, 0xffffffff, 0x00010000, /* CGTS_CU4_SP0_CTRL_REG */
+	0x3c074, 0xffffffff, 0x00030002, /* CGTS_CU4_LDS_SQ_CTRL_REG */
+	0x3c078, 0xffffffff, 0x00040007, /* CGTS_CU4_TA_CTRL_REG */
+	0x3c07c, 0xffffffff, 0x00060005, /* CGTS_CU4_SP1_CTRL_REG */
+	0x3c080, 0xffffffff, 0x00090008, /* CGTS_CU4_TD_TCP_CTRL_REG */
+	0x3c084, 0xffffffff, 0x00010000, /* CGTS_CU5_SP0_CTRL_REG */
+	0x3c088, 0xffffffff, 0x00030002, /* CGTS_CU5_LDS_SQ_CTRL_REG */
+	0x3c08c, 0xffffffff, 0x00040007, /* CGTS_CU5_TA_CTRL_REG */
+	0x3c090, 0xffffffff, 0x00060005, /* CGTS_CU5_SP1_CTRL_REG */
+	0x3c094, 0xffffffff, 0x00090008, /* CGTS_CU5_TD_TCP_CTRL_REG */
+	0x3c098, 0xffffffff, 0x00010000, /* CGTS_CU6_SP0_CTRL_REG */
+	0x3c09c, 0xffffffff, 0x00030002, /* CGTS_CU6_LDS_SQ_CTRL_REG */
+	0x3c0a0, 0xffffffff, 0x00040007, /* CGTS_CU6_TA_SQC_CTRL_REG */
+	0x3c0a4, 0xffffffff, 0x00060005, /* CGTS_CU6_SP1_CTRL_REG */
+	0x3c0a8, 0xffffffff, 0x00090008, /* CGTS_CU6_TD_TCP_CTRL_REG */
+	0x3c0ac, 0xffffffff, 0x00010000, /* CGTS_CU7_SP0_CTRL_REG */
+	0x3c0b0, 0xffffffff, 0x00030002, /* CGTS_CU7_LDS_SQ_CTRL_REG */
+	0x3c0b4, 0xffffffff, 0x00040007, /* CGTS_CU7_TA_SQC_CTRL_REG */
+	0x3c0b8, 0xffffffff, 0x00060005, /* CGTS_CU7_SP1_CTRL_REG */
+	0x3c0bc, 0xffffffff, 0x00090008, /* CGTS_CU7_TD_TCP_CTRL_REG */
+	0x3c0c0, 0xffffffff, 0x00010000, /* CGTS_CU8_SP0_CTRL_REG */
+	0x3c0c4, 0xffffffff, 0x00030002, /* CGTS_CU8_LDS_SQ_CTRL_REG */
+	0x3c0c8, 0xffffffff, 0x00040007, /* CGTS_CU8_TA_CTRL_REG */
+	0x3c0cc, 0xffffffff, 0x00060005, /* CGTS_CU8_SP1_CTRL_REG */
+	0x3c0d0, 0xffffffff, 0x00090008, /* CGTS_CU8_TD_TCP_CTRL_REG */
+	0x3c0d4, 0xffffffff, 0x00010000, /* CGTS_CU9_SP0_CTRL_REG */
+	0x3c0d8, 0xffffffff, 0x00030002, /* CGTS_CU9_LDS_SQ_CTRL_REG */
+	0x3c0dc, 0xffffffff, 0x00040007, /* CGTS_CU9_TA_CTRL_REG */
+	0x3c0e0, 0xffffffff, 0x00060005, /* CGTS_CU9_SP1_CTRL_REG */
+	0x3c0e4, 0xffffffff, 0x00090008, /* CGTS_CU9_TD_TCP_CTRL_REG */
+	0x3c000, 0xffffffff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0x8708, 0xffffffff, 0x00900100, /* CP_RB_WPTR_POLL_CNTL */
+	0xc424, 0xffffffff, 0x0020003f, /* RLC_CGCG_CGLS_CTRL */
+	0x9a10, 0x00210000, 0x00018208, /* CB_HW_CONTROL */
+	0x3c000, 0xffff1fff, 0x96940200, /* CGTS_SM_CTRL_REG */
+	0x3c00c, 0xffff0001, 0xff000000, /* CGTS_TCC_DISABLE */
+	0x3c010, 0xffff0000, 0xff000000, /* CGTS_USER_TCC_DISABLE */
+	0x55e4, 0xff607fff, 0xfc000100, /* CGTT_DRM_CLK_CTRL0 */
+	0x3c200, 0xfdfc0fff, 0x00000100, /* CGTT_SPI_CLK_CTRL */
+	0x6ed8, 0x00010000, 0x00010000, /* CRTC_DOUBLE_BUFFER_CONTROL */
+	0x9834, 0xf00fffff, 0x00004400, /* DB_DEBUG2 */
+	0x5bb0, 0x000000f0, 0x00000070, /* FBC_DEBUG_COMP */
+	0x98f8, 0x73773777, 0x12011002, /* GB_ADDR_CONFIG  0x12011003*/
+	0x2f48, 0x73773777, 0x12010001, /* HDP_ADDR_CONFIG */
+	0x8a14, 0xf000003f, 0x00000007, /* PA_CL_ENHANCE */
+	0x8bf0, 0x00000001, 0x00000001, /* PA_SC_ENHANCE */
+	0x8b24, 0xffffffff, 0x00ffffff, /* PA_SC_FORCE_EOV_MAX_CNTS */
+	0x30a04, 0x0000ff0f, 0x00000000, /* PA_SC_LINE_STIPPLE_STATE */
+	0x28a4c, 0x07ffffff, 0x06000000, /* PA_SC_MODE_CNTL_1 */
+	0xc37c, 0xffffffff, 0x00000b00, /* RLC_PG_DELAY_2 */
+	0x4d8, 0x00000fff, 0x00000100, /* SCLK_CGTT_BLK_CTRL_REG */
+	0x3e78, 0x00000001, 0x00000002, /* SEM_CHICKEN_BITS */
+	0xc768, 0x00000008, 0x00000008, /* SPI_RESET_DEBUG */
+	0x8c00, 0x000000ff, 0x00000001, /* SQ_CONFIG */
+	0x9508, 0x00010000, 0x00010000, /* TA_CNTL_AUX */
+	0xac0c, 0xffffffff, 0x76325410, /* TCP_CHAN_STEER_LO */
+	0xc770, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_0 */
+	0xc774, 0xffffffff, 0x00000800, /* SPI_RESOURCE_RESERVE_CU_1 */
+	0xc798, 0xffffffff, 0x00ffffbf, /* SPI_RESOURCE_RESERVE_EN_CU_0 */
+	0xc79c, 0xffffffff, 0x00ffffaf, /* SPI_RESOURCE_RESERVE_EN_CU_1  */
+	0xc7a0, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_2 */
+	0xc7a4, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_3 */
+	0xc7a8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_4 */
+	0xc7ac, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_5*/
+	0xc7b0, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_6 */
+	0xc7b4, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_7 */
+	0xc7b8, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_8 */
+	0xc7bc, 0xffffffff, 0x00fffffe, /* SPI_RESOURCE_RESERVE_EN_CU_9 */
+	0x28350, 0xffffffff, 0x2a00161a, /* PA_SC_RASTER_CONFIG */
+	0x28354, 0xffffffff, 0x00000000, /* PA_SC_RASTER_CONFIG_1 */
+	0x5004, 0x00002000, 0x00002000, /* GARLIC_FLUSH_CNTL */
+	/* SDMA */
+	0xd010, 0xffffffff, 0x08050400, /* SDMA0_CNTL */
+	0xd810, 0xffffffff, 0x08050400, /* SDMA1_CNTL */
+	0xda00, 0xffffffff, 0x00000018,	/*SDMA0_GFX_RB_CNTL */
+	0xd200, 0xffffffff, 0x00000018,	/*SDMA1_GFX_RB_CNTL */
+	0xd228, 0xffffffff, 0x00000100,	/*SDMA0_GFX_IB_CNTL */
+	0xda28, 0xffffffff, 0x00000100,	/*SDMA1_GFX_IB_CNTL */
+	0xd034, 0xffffffff, 0x00000000,	/*SDMA1_GFX_CONTEXT_STATUS */
+	0xd834, 0xffffffff, 0x00000000,	/*SDMA1_GFX_CONTEXT_STATUS */
+	0x14d4, 0xffffffff, 0x00000000, /* VM_CONTEXTS_DISABLE */
+};
+
 static const u32 spectre_golden_spm_registers[] =
 {
 	0x30800, 0xe0ffffff, 0xe0000000
@@ -1633,6 +2212,22 @@ static void cik_init_golden_registers(struct radeon_device *rdev)
 						 bonaire_golden_spm_registers,
 						 (const u32)ARRAY_SIZE(bonaire_golden_spm_registers));
 		break;
+	case CHIP_LIVERPOOL:
+		/*radeon_program_register_sequence(rdev,
+						 liverpool_mgcg_cgcg_init,
+						 (const u32)ARRAY_SIZE(liverpool_mgcg_cgcg_init));*/
+		radeon_program_register_sequence(rdev,
+						 liverpool_golden_registers,
+						 (const u32)ARRAY_SIZE(liverpool_golden_registers));
+
+		radeon_program_register_sequence(rdev,
+						 liverpool_golden_common_registers,
+						 (const u32)ARRAY_SIZE(liverpool_golden_common_registers));
+
+		/*radeon_program_register_sequence(rdev,
+						 liverpool_golden_spm_registers,
+						 (const u32)ARRAY_SIZE(liverpool_golden_spm_registers));*/
+		break;
 	case CHIP_KABINI:
 		radeon_program_register_sequence(rdev,
 						 kalindi_mgcg_cgcg_init,
@@ -2046,6 +2641,17 @@ static int cik_init_microcode(struct radeon_device *rdev)
 		sdma_req_size = CIK_SDMA_UCODE_SIZE * 4;
 		num_fw = 6;
 		break;
+	case CHIP_LIVERPOOL:
+		chip_name = "LIVERPOOL";
+		new_chip_name = "liverpool";
+		pfp_req_size = LIVERPOOL_PFP_UCODE_SIZE * 4;
+		me_req_size = LIVERPOOL_ME_UCODE_SIZE * 4;
+		ce_req_size = CIK_CE_UCODE_SIZE * 4;
+		mec_req_size = CIK_MEC_UCODE_SIZE * 4;
+		rlc_req_size = LIVERPOOL_RLC_UCODE_SIZE * 4;
+		sdma_req_size = CIK_SDMA_UCODE_SIZE * 4;
+		num_fw = 6;
+		break;
 	default: BUG();
 	}
 
@@ -3225,6 +3831,26 @@ static void cik_gpu_init(struct radeon_device *rdev)
 		rdev->config.cik.sc_earlyz_tile_fifo_size = 0x130;
 		gb_addr_config = BONAIRE_GB_ADDR_CONFIG_GOLDEN;
 		break;
+
+	case CHIP_LIVERPOOL:
+		rdev->config.cik.max_shader_engines = 2; // VERIFIED
+		rdev->config.cik.max_tile_pipes = 8; // VERIFIED
+		rdev->config.cik.max_cu_per_sh = 9; // VERIFIED
+		rdev->config.cik.max_sh_per_se = 1; // VERIFIED
+		rdev->config.cik.max_backends_per_se = 2; // PROBABLY OK, >1?
+		rdev->config.cik.max_texture_channel_caches = 4; // ??
+		rdev->config.cik.max_gprs = 256;
+		rdev->config.cik.max_gs_threads = 32; // ??
+		rdev->config.cik.max_hw_contexts = 8;
+
+		rdev->config.cik.sc_prim_fifo_size_frontend = 0x20;
+		rdev->config.cik.sc_prim_fifo_size_backend = 0x100;
+		rdev->config.cik.sc_hiz_tile_fifo_size = 0x30;
+		rdev->config.cik.sc_earlyz_tile_fifo_size = 0x130;
+
+		gb_addr_config = HAWAII_GB_ADDR_CONFIG_GOLDEN;
+		break;
+
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
 	default:
@@ -3904,6 +4530,9 @@ static int cik_cp_gfx_load_microcode(struct radeon_device *rdev)
 		radeon_ucode_print_gfx_hdr(&ce_hdr->header);
 		radeon_ucode_print_gfx_hdr(&me_hdr->header);
 
+		// TODO (ps4patches): This might be correct already
+		// + for (i = 0; i < rdev->pfp_fw->size/4; i++)
+
 		/* PFP */
 		fw_data = (const __le32 *)
 			(rdev->pfp_fw->data + le32_to_cpu(pfp_hdr->header.ucode_array_offset_bytes));
@@ -4936,6 +5565,22 @@ static void cik_gpu_soft_reset(struct radeon_device *rdev, u32 reset_mask)
 	dev_info(rdev->dev, "  VM_CONTEXT1_PROTECTION_FAULT_STATUS 0x%08X\n",
 		 RREG32(VM_CONTEXT1_PROTECTION_FAULT_STATUS));
 
+	dev_info(rdev->dev, "  VM_CONTEXT0_CNTL 0x%08X\n",
+		 RREG32(VM_CONTEXT0_CNTL));
+	dev_info(rdev->dev, "  VM_CONTEXT1_CNTL 0x%08X\n",
+		 RREG32(VM_CONTEXT1_CNTL));
+	dev_info(rdev->dev, "  VM_CONTEXT0_CNTL2	0x%08X\n",
+		 RREG32(VM_CONTEXT0_CNTL2));
+	dev_info(rdev->dev, "  VM_CONTEXT1_CNTL2	0x%08X\n",
+		 RREG32(VM_CONTEXT1_CNTL2));
+	dev_info(rdev->dev, "  VM_CONTEXT8_PAGE_TABLE_BASE_ADDR	0x%08X\n",
+		 RREG32(VM_CONTEXT8_PAGE_TABLE_BASE_ADDR));
+	dev_info(rdev->dev, "  VM_CONTEXT0_PAGE_TABLE_BASE_ADDR	0x%08X\n",
+		 RREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR));
+	dev_info(rdev->dev, "  VM_DEBUG	0x%08X\n",
+		 RREG32(0x15bc));
+	//VM_CONTEXT0_PAGE_TABLE_BASE_ADDR
+
 	/* disable CG/PG */
 	cik_fini_pg(rdev);
 	cik_fini_cg(rdev);
@@ -5443,9 +6088,18 @@ static int cik_pcie_gart_enable(struct radeon_device *rdev)
 	       EFFECTIVE_L2_QUEUE_SIZE(7) |
 	       CONTEXT1_IDENTITY_ACCESS_MODE(1));
 	WREG32(VM_L2_CNTL2, INVALIDATE_ALL_L1_TLBS | INVALIDATE_L2_CACHE);
-	WREG32(VM_L2_CNTL3, L2_CACHE_BIGK_ASSOCIATIVITY |
-	       BANK_SELECT(4) |
-	       L2_CACHE_BIGK_FRAGMENT_SIZE(4));
+
+	if(rdev->family == CHIP_LIVERPOOL)
+	{
+		WREG32(VM_L2_CNTL3, L2_CACHE_BIGK_ASSOCIATIVITY |
+					    BANK_SELECT(6) |
+					    L2_CACHE_BIGK_FRAGMENT_SIZE(6));
+	} else {
+		WREG32(VM_L2_CNTL3, L2_CACHE_BIGK_ASSOCIATIVITY |
+					    BANK_SELECT(4) |
+					    L2_CACHE_BIGK_FRAGMENT_SIZE(4));
+	}
+
 	/* setup context0 */
 	WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR, rdev->mc.gtt_start >> 12);
 	WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR, rdev->mc.gtt_end >> 12);
@@ -5461,7 +6115,6 @@ static int cik_pcie_gart_enable(struct radeon_device *rdev)
 	WREG32(0x15DC, 0);
 
 	/* restore context1-15 */
-	/* set vm size, must be a multiple of 4 */
 	WREG32(VM_CONTEXT1_PAGE_TABLE_START_ADDR, 0);
 	WREG32(VM_CONTEXT1_PAGE_TABLE_END_ADDR, rdev->vm_manager.max_pfn - 1);
 	for (i = 1; i < 16; i++) {
@@ -5473,6 +6126,36 @@ static int cik_pcie_gart_enable(struct radeon_device *rdev)
 			       rdev->vm_manager.saved_table_addr[i]);
 	}
 
+	if(rdev->family == CHIP_LIVERPOOL) {
+		/* empty context1-15 */
+		/* Assign the pt base to something valid for now; the pts used for
+	 	* the VMs are determined by the application and setup and assigned
+	 	* on the fly in the vm part of radeon_gart.c
+	 	*/
+		for (i = 1; i < 16; i++) {
+			if (i < 8) {
+				WREG32(VM_CONTEXT0_PAGE_TABLE_START_ADDR +
+					       (i << 2),
+				       0);
+				WREG32(VM_CONTEXT0_PAGE_TABLE_END_ADDR +
+					       (i << 2),
+				       rdev->vm_manager.max_pfn - 1);
+				WREG32(VM_CONTEXT0_PAGE_TABLE_BASE_ADDR +
+					       (i << 2),
+				       rdev->vm_manager.saved_table_addr[i]);
+			} else {
+				WREG32(VM_CONTEXT8_PAGE_TABLE_START_ADDR +
+					       ((i - 8) << 2),
+				       0);
+				/*WREG32(VM_CONTEXT8_PAGE_TABLE_END_ADDR + ((i - 8) << 2),
+ 			rdev->vm_manager.max_pfn - 1);*/
+				WREG32(VM_CONTEXT8_PAGE_TABLE_BASE_ADDR +
+					       ((i - 8) << 2),
+				       rdev->vm_manager.saved_table_addr[i]);
+			}
+		}
+	}
+
 	/* enable context1-15 */
 	WREG32(VM_CONTEXT1_PROTECTION_FAULT_DEFAULT_ADDR,
 	       (u32)(rdev->dummy_page.addr >> 12));
@@ -5967,6 +6650,9 @@ static int cik_rlc_resume(struct radeon_device *rdev)
 		case CHIP_MULLINS:
 			size = ML_RLC_UCODE_SIZE;
 			break;
+		case CHIP_LIVERPOOL:
+			size = LIVERPOOL_RLC_UCODE_SIZE;
+			break;
 		}
 
 		fw_data = (const __be32 *)rdev->rlc_fw->data;
@@ -6748,6 +7434,10 @@ void cik_get_csb_buffer(struct radeon_device *rdev, volatile u32 *buffer)
 		buffer[count++] = cpu_to_le32(0x3a00161a);
 		buffer[count++] = cpu_to_le32(0x0000002e);
 		break;
+	case CHIP_LIVERPOOL:
+		buffer[count++] = cpu_to_le32(0x2a00161a);
+		buffer[count++] = cpu_to_le32(0x00000000);
+		break;
 	default:
 		buffer[count++] = cpu_to_le32(0x00000000);
 		buffer[count++] = cpu_to_le32(0x00000000);
@@ -7923,6 +8613,7 @@ int cik_irq_process(struct radeon_device *rdev)
 			break;
 		case 176: /* GFX RB CP_INT */
 		case 177: /* GFX IB CP_INT */
+			DRM_ERROR("radeon_fence_process 176 177\n"); // eeply
 			radeon_fence_process(rdev, RADEON_RING_TYPE_GFX_INDEX);
 			break;
 		case 181: /* CP EOP event */
@@ -8310,6 +9001,10 @@ static int cik_startup(struct radeon_device *rdev)
 			rdev->rlc.reg_list = spectre_rlc_save_restore_register_list;
 			rdev->rlc.reg_list_size =
 				(u32)ARRAY_SIZE(spectre_rlc_save_restore_register_list);
+		} else if (rdev->family == CHIP_LIVERPOOL) {
+			rdev->rlc.reg_list = liverpool_rlc_save_restore_register_list;
+			rdev->rlc.reg_list_size =
+				(u32)ARRAY_SIZE(liverpool_rlc_save_restore_register_list);
 		} else {
 			rdev->rlc.reg_list = kalindi_rlc_save_restore_register_list;
 			rdev->rlc.reg_list_size =
@@ -8444,8 +9139,10 @@ static int cik_startup(struct radeon_device *rdev)
 	if (r)
 		return r;
 
-	cik_uvd_resume(rdev);
-	cik_vce_resume(rdev);
+ 	if (rdev->family != CHIP_LIVERPOOL) {
+		cik_uvd_resume(rdev);
+		cik_vce_resume(rdev);
+	}
 
 	r = radeon_ib_pool_init(rdev);
 	if (r) {
@@ -9368,6 +10065,11 @@ void dce8_bandwidth_update(struct radeon_device *rdev)
 	u32 num_heads = 0, lb_size;
 	int i;
 
+	if (rdev->family == CHIP_LIVERPOOL) {
+		// FIXME PS4 (ps4patches): this stuff is broken
+		return;
+	}
+
 	if (!rdev->mode_info.mode_config_initialized)
 		return;
 
diff --git a/drivers/gpu/drm/radeon/cik_sdma.c b/drivers/gpu/drm/radeon/cik_sdma.c
index 919b14845c3c..0840f96d0813 100644
--- a/drivers/gpu/drm/radeon/cik_sdma.c
+++ b/drivers/gpu/drm/radeon/cik_sdma.c
@@ -140,11 +140,23 @@ void cik_sdma_ring_ib_execute(struct radeon_device *rdev,
 		while ((next_rptr & 7) != 4)
 			next_rptr++;
 		next_rptr += 4;
-		radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
-		radeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);
-		radeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr));
-		radeon_ring_write(ring, 1); /* number of DWs to follow */
-		radeon_ring_write(ring, next_rptr);
+
+		if (rdev->family == CHIP_LIVERPOOL) {
+			/* SDMA_OPCODE_WRITE is broken on Liverpool when used
+			 * in the ring (works in IBs) */
+			radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0,
+							    SDMA_CONSTANT_FILL_EXTRA_SIZE(2)));
+			radeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);
+			radeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr));
+			radeon_ring_write(ring, next_rptr);
+			radeon_ring_write(ring, 4);
+		} else {
+			radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
+			radeon_ring_write(ring, ring->next_rptr_gpu_addr & 0xfffffffc);
+			radeon_ring_write(ring, upper_32_bits(ring->next_rptr_gpu_addr));
+			radeon_ring_write(ring, 1); /* number of DWs to follow */
+			radeon_ring_write(ring, next_rptr);
+		}
 	}
 
 	/* IB packet must end on a 8 DW boundary */
@@ -665,11 +677,24 @@ int cik_sdma_ring_test(struct radeon_device *rdev,
 		DRM_ERROR("radeon: dma failed to lock ring %d (%d).\n", ring->idx, r);
 		return r;
 	}
-	radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE, SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
-	radeon_ring_write(ring, lower_32_bits(gpu_addr));
-	radeon_ring_write(ring, upper_32_bits(gpu_addr));
-	radeon_ring_write(ring, 1); /* number of DWs to follow */
-	radeon_ring_write(ring, 0xDEADBEEF);
+
+	if (rdev->family == CHIP_LIVERPOOL) {
+		/* SDMA_OPCODE_WRITE is broken on Liverpool when used in the
+	 	 * ring (works in IBs) */
+		radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_CONSTANT_FILL, 0,
+						    SDMA_CONSTANT_FILL_EXTRA_SIZE(2)));
+		radeon_ring_write(ring, lower_32_bits(gpu_addr));
+		radeon_ring_write(ring, upper_32_bits(gpu_addr));
+		radeon_ring_write(ring, 0xDEADBEEF); /* Fill value */
+		radeon_ring_write(ring, 4); /* number of bytes */
+	} else {
+		radeon_ring_write(ring, SDMA_PACKET(SDMA_OPCODE_WRITE,
+						    SDMA_WRITE_SUB_OPCODE_LINEAR, 0));
+		radeon_ring_write(ring, lower_32_bits(gpu_addr));
+		radeon_ring_write(ring, upper_32_bits(gpu_addr));
+		radeon_ring_write(ring, 1); /* number of DWs to follow */
+		radeon_ring_write(ring, 0xDEADBEEF);
+	}
 	radeon_ring_unlock_commit(rdev, ring, false);
 
 	for (i = 0; i < rdev->usec_timeout; i++) {
@@ -684,7 +709,11 @@ int cik_sdma_ring_test(struct radeon_device *rdev,
 	} else {
 		DRM_ERROR("radeon: ring %d test failed (0x%08X)\n",
 			  ring->idx, tmp);
-		r = -EINVAL;
+
+		// TODO (ps4patches): rip errors i guess
+		if (rdev->family != CHIP_LIVERPOOL) {
+			r = -EINVAL;
+		}
 	}
 	return r;
 }
diff --git a/drivers/gpu/drm/radeon/cikd.h b/drivers/gpu/drm/radeon/cikd.h
index cda16fcd43bb..e4be5298496f 100644
--- a/drivers/gpu/drm/radeon/cikd.h
+++ b/drivers/gpu/drm/radeon/cikd.h
@@ -534,10 +534,27 @@
 #define	VM_CONTEXT13_PAGE_TABLE_BASE_ADDR		0x144c
 #define	VM_CONTEXT14_PAGE_TABLE_BASE_ADDR		0x1450
 #define	VM_CONTEXT15_PAGE_TABLE_BASE_ADDR		0x1454
+#define	VM_CONTEXT8_PAGE_TABLE_START_ADDR		0x1458
+#define	VM_CONTEXT9_PAGE_TABLE_START_ADDR		0x145c
+#define	VM_CONTEXT10_PAGE_TABLE_START_ADDR		0x1460
+#define	VM_CONTEXT11_PAGE_TABLE_START_ADDR		0x1464
+#define	VM_CONTEXT12_PAGE_TABLE_START_ADDR		0x1468
+#define	VM_CONTEXT13_PAGE_TABLE_START_ADDR		0x146c
+#define	VM_CONTEXT14_PAGE_TABLE_START_ADDR		0x1470
+#define	VM_CONTEXT15_PAGE_TABLE_START_ADDR		0x1474
 
 #define VM_INVALIDATE_REQUEST				0x1478
 #define VM_INVALIDATE_RESPONSE				0x147c
 
+#define	VM_CONTEXT8_PAGE_TABLE_END_ADDR		  	0x1480
+#define	VM_CONTEXT9_PAGE_TABLE_END_ADDR		 	0x1484
+#define	VM_CONTEXT10_PAGE_TABLE_END_ADDR		0x1488
+#define	VM_CONTEXT11_PAGE_TABLE_END_ADDR		0x148c
+#define	VM_CONTEXT12_PAGE_TABLE_END_ADDR		0x1490
+#define	VM_CONTEXT13_PAGE_TABLE_END_ADDR	  	0x1494
+#define	VM_CONTEXT14_PAGE_TABLE_END_ADDR		0x1498
+#define	VM_CONTEXT15_PAGE_TABLE_END_ADDR	  	0x149c
+
 #define	VM_CONTEXT1_PROTECTION_FAULT_STATUS		0x14DC
 #define		PROTECTIONS_MASK			(0xf << 0)
 #define		PROTECTIONS_SHIFT			0
@@ -573,6 +590,13 @@
 #define	VM_CONTEXT0_PAGE_TABLE_START_ADDR		0x155c
 #define	VM_CONTEXT1_PAGE_TABLE_START_ADDR		0x1560
 
+#define	VM_CONTEXT2_PAGE_TABLE_START_ADDR		0x1564
+#define	VM_CONTEXT3_PAGE_TABLE_START_ADDR		0x1568
+#define	VM_CONTEXT4_PAGE_TABLE_START_ADDR		0x156c
+#define	VM_CONTEXT5_PAGE_TABLE_START_ADDR		0x1570
+#define	VM_CONTEXT6_PAGE_TABLE_START_ADDR		0x1574
+#define	VM_CONTEXT7_PAGE_TABLE_START_ADDR		0x1578
+
 #define	VM_CONTEXT0_PAGE_TABLE_END_ADDR			0x157C
 #define	VM_CONTEXT1_PAGE_TABLE_END_ADDR			0x1580
 
diff --git a/drivers/gpu/drm/radeon/ps4_bridge.c b/drivers/gpu/drm/radeon/ps4_bridge.c
new file mode 100644
index 000000000000..1c1cb0b4dabb
--- /dev/null
+++ b/drivers/gpu/drm/radeon/ps4_bridge.c
@@ -0,0 +1,758 @@
+/*
+ * Panasonic MN86471A / MN864729 DP->HDMI bridge driver (via PS4 Aeolia ICC interface)
+ *
+ * This software is licensed under the terms of the GNU General Public
+ * License version 2, as published by the Free Software Foundation, and
+ * may be copied, distributed, and modified under those terms.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#include <asm/ps4.h>
+
+#include <drm/drm_crtc.h>
+#include <drm/drm_crtc_helper.h>
+#include <drm/drm_atomic_helper.h>
+#include <drm/drm_edid.h>
+#include <drm/drmP.h>
+
+#include "radeon_mode.h"
+#include "ObjectID.h"
+
+#define CMD_READ	1, 1
+#define CMD_WRITE	2, 2
+#define CMD_MASK	2, 3
+#define CMD_DELAY	3, 1
+#define CMD_WAIT_SET	3, 2
+#define CMD_WAIT_CLEAR	3, 3
+
+#define TSYSCTRL 0x7005
+# define TSYSCTRL_HDMI BIT(7)
+
+#define TSRST 0x7006
+# define TSRST_AVCSRST BIT(0)
+# define TSRST_ENCSRST BIT(1)
+# define TSRST_FIFOSRST BIT(2)
+# define TSRST_CCSRST BIT(3)
+# define TSRST_HDCPSRST BIT(4)
+# define TSRST_AUDSRST BIT(6)
+# define TSRST_VIFSRST BIT(7)
+
+#define TMONREG 0x7008
+# define TMONREG_HPD BIT(3)
+
+#define TDPCMODE 0x7009
+
+
+#define UPDCTRL 0x7011
+# define UPDCTRL_ALLUPD BIT(7)
+# define UPDCTRL_AVIIUPD BIT(6)
+# define UPDCTRL_AUDIUPD BIT(5)
+# define UPDCTRL_CLKUPD BIT(4)
+# define UPDCTRL_HVSIUPD BIT(3)
+# define UPDCTRL_VIFUPD BIT(2)
+# define UPDCTRL_AUDUPD BIT(1)
+# define UPDCTRL_CSCUPD BIT(0)
+
+
+#define VINCNT 0x7040
+# define VINCNT_VIF_FILEN BIT(6)
+
+#define VMUTECNT 0x705f
+# define VMUTECNT_CCVMUTE BIT(7)
+# define VMUTECNT_DUMON BIT(6)
+# define VMUTECNT_LINEWIDTH_80 (0<<4)
+# define VMUTECNT_LINEWIDTH_90 (1<<4)
+# define VMUTECNT_LINEWIDTH_180 (2<<4)
+# define VMUTECNT_LINEWIDTH_360 (3<<4)
+# define VMUTECNT_VMUTE_MUTE_ASYNC 1
+# define VMUTECNT_VMUTE_MUTE_NORMAL 2
+# define VMUTECNT_VMUTE_MUTE_RAMPA 4
+# define VMUTECNT_VMUTE_MUTE_RAMPB 8
+# define VMUTECNT_VMUTE_MUTE_COLORBAR_RGB 10
+# define VMUTECNT_VMUTE_MUTE_TOGGLE 12
+# define VMUTECNT_VMUTE_MUTE_COLORBAR_YCBCR 14
+
+#define CSCMOD 0x70c0
+#define C420SET 0x70c2
+#define OUTWSET 0x70c3
+
+#define PKTENA 0x7202
+
+#define INFENA 0x7203
+# define INFENA_AVIEN BIT(6)
+
+#define AKESTA 0x7a84
+# define AKESTA_BUSY BIT(0)
+
+#define AKESRST 0x7a88
+
+#define HDCPEN 0x7a8b
+# define HDCPEN_NONE 0x00
+# define HDCPEN_ENC_EN 0x03
+# define HDCPEN_ENC_DIS 0x05
+
+#define PCI_VENDOR_ID_AMD 0x1002
+#define PCI_DEVICE_ID_CUH_11XX 0x9920
+#define PCI_DEVICE_ID_CUH_12XX 0x9922
+#define PCI_DEVICE_ID_CUH_2XXX 0x9923
+#define PCI_DEVICE_ID_CUH_7XXX 0x9924
+
+struct i2c_cmd_hdr {
+	u8 major;
+	u8 length;
+	u8 minor;
+	u8 count;
+} __packed;
+
+struct i2c_cmdqueue {
+	struct {
+		u8 code;
+		u16 length;
+		u8 count;
+		u8 cmdbuf[0x7ec];
+	} __packed req;
+	struct {
+		u8 res1, res2;
+		u8 unk1, unk2;
+		u8 count;
+		u8 databuf[0x7eb];
+	} __packed reply;
+
+	u8 *p;
+	struct i2c_cmd_hdr *cmd;
+};
+
+struct radeon_ps4_bridge {
+	struct drm_connector *connector;
+	struct drm_encoder *encoder;
+	struct drm_bridge bridge;
+	struct i2c_cmdqueue cq;
+	struct mutex mutex;
+
+	int mode;
+};
+
+/* this should really be taken care of by the connector, but that is currently
+ * contained/owned by radeon_connector so just use a global for now */
+static struct radeon_ps4_bridge g_bridge = {
+	.mutex = __MUTEX_INITIALIZER(g_bridge.mutex)
+};
+
+static void cq_init(struct i2c_cmdqueue *q, u8 code)
+{
+	q->req.code = code;
+	q->req.count = 0;
+	q->p = q->req.cmdbuf;
+	q->cmd = NULL;
+}
+
+static void cq_cmd(struct i2c_cmdqueue *q, u8 major, u8 minor)
+{
+	if (!q->cmd || q->cmd->major != major || q->cmd->minor != minor) {
+		if (q->cmd)
+			q->cmd->length = q->p - (u8 *)q->cmd;
+		q->cmd = (struct i2c_cmd_hdr *)q->p;
+		q->cmd->major = major;
+		q->cmd->minor = minor;
+		q->cmd->length = 0;
+		q->cmd->count = 1;
+		q->req.count += 1;
+		q->p += sizeof(*q->cmd);
+	} else {
+		q->cmd->count += 1;
+	}
+}
+
+static int cq_exec(struct i2c_cmdqueue *q)
+{
+	int res;
+
+	if (!q->cmd)
+		return 0;
+
+	q->cmd->length = q->p - (u8 *)q->cmd;
+	q->req.length = q->p - (u8 *)&q->req;
+
+	res = apcie_icc_cmd(0x10, 0, &q->req, q->req.length,
+		      &q->reply, sizeof(q->reply));
+
+	if (res < 5) {
+		DRM_ERROR("icc i2c commandqueue failed: %d\n", res);
+		return -EIO;
+	}
+	if (q->reply.res1 != 0 || q->reply.res2) {
+		DRM_ERROR("icc i2c commandqueue failed: %d, %d\n",
+			  q->reply.res1, q->reply.res2);
+		return -EIO;
+	}
+
+	return res;
+}
+
+static void cq_read(struct i2c_cmdqueue *q, u16 addr, u8 count)
+{
+	cq_cmd(q, CMD_READ);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = 0;
+}
+
+static void cq_writereg(struct i2c_cmdqueue *q, u16 addr, u8 data)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = data;
+}
+
+#if 0
+static void cq_write(struct i2c_cmdqueue *q, u16 addr, u8 *data, u8 count)
+{
+	cq_cmd(q, CMD_WRITE);
+	*q->p++ = count;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	while (count--)
+		*q->p++ = *data++;
+}
+#endif
+
+static void cq_mask(struct i2c_cmdqueue *q, u16 addr, u8 value, u8 mask)
+{
+	cq_cmd(q, CMD_MASK);
+	*q->p++ = 1;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = value;
+	*q->p++ = mask;
+}
+
+#if 0
+static void cq_delay(struct i2c_cmdqueue *q, u16 time)
+{
+	cq_cmd(q, CMD_DELAY);
+	*q->p++ = 0;
+	*q->p++ = time & 0xff;
+	*q->p++ = time>>8;
+	*q->p++ = 0;
+}
+#endif
+
+static void cq_wait_set(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_SET);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static void cq_wait_clear(struct i2c_cmdqueue *q, u16 addr, u8 mask)
+{
+	cq_cmd(q, CMD_WAIT_CLEAR);
+	*q->p++ = 0;
+	*q->p++ = addr >> 8;
+	*q->p++ = addr & 0xff;
+	*q->p++ = mask;
+}
+
+static inline struct radeon_ps4_bridge *
+		bridge_to_radeon_ps4_bridge(struct drm_bridge *bridge)
+{
+	return container_of(bridge, struct radeon_ps4_bridge, bridge);
+}
+
+static void radeon_ps4_bridge_mode_set(struct drm_bridge *bridge,
+			      struct drm_display_mode *mode,
+			      struct drm_display_mode *adjusted_mode)
+{
+	struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge);
+
+	/* This gets called before pre_enable/enable, so we just stash
+	 * the vic ID for later */
+	mn_bridge->mode = drm_match_cea_mode(adjusted_mode);
+	DRM_DEBUG_KMS("vic mode: %d\n", mn_bridge->mode);
+	if (!mn_bridge->mode) {
+		DRM_ERROR("attempted to set non-CEA mode\n");
+	}
+}
+
+static void radeon_ps4_bridge_pre_enable(struct drm_bridge *bridge)
+{
+	struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("radeon_ps4_bridge_pre_enable\n");
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+
+#if 0
+	/* No idea. DP stuff probably. This borks for some reason. Meh. */
+	cq_writereg(&mn_bridge->cq, 0x7657,0xff);
+	cq_writereg(&mn_bridge->cq, 0x76a5,0x80);
+	cq_writereg(&mn_bridge->cq, 0x76a6,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7601,0x0a);
+	cq_writereg(&mn_bridge->cq, 0x7602,0x84);
+	cq_writereg(&mn_bridge->cq, 0x7603,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76a8,0x09);
+	cq_writereg(&mn_bridge->cq, 0x76ae,0xd1);
+	cq_writereg(&mn_bridge->cq, 0x76af,0x50);
+	cq_writereg(&mn_bridge->cq, 0x76b0,0x70);
+	cq_writereg(&mn_bridge->cq, 0x76b1,0xb0);
+	cq_writereg(&mn_bridge->cq, 0x76b2,0xf0);
+	cq_writereg(&mn_bridge->cq, 0x76db,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76dc,0x64);
+	cq_writereg(&mn_bridge->cq, 0x76dd,0x22);
+	cq_writereg(&mn_bridge->cq, 0x76e4,0x00);
+	cq_writereg(&mn_bridge->cq, 0x76e6,0x1e); /* 0 for (DP?) scramble off */
+	cq_writereg(&mn_bridge->cq, 0x7670,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7671,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7672,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7673,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7668,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7669,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766a,0xff);
+	cq_writereg(&mn_bridge->cq, 0x766b,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7655,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7007,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7098,0xff);
+	cq_writereg(&mn_bridge->cq, 0x7099,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709a,0x0f);
+	cq_writereg(&mn_bridge->cq, 0x709b,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709c,0x50);
+	cq_writereg(&mn_bridge->cq, 0x709d,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709e,0x00);
+	cq_writereg(&mn_bridge->cq, 0x709f,0xd0);
+	cq_writereg(&mn_bridge->cq, 0x7a9c,0x2e);
+	cq_writereg(&mn_bridge->cq, 0x7021,0x04);
+	cq_writereg(&mn_bridge->cq, 0x7028,0x00);
+	cq_writereg(&mn_bridge->cq, 0x7030,0xa3);
+	cq_writereg(&mn_bridge->cq, 0x7016,0x04);
+#endif
+
+	/* Disable InfoFrames */
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	/* Reset HDCP */
+	cq_writereg(&mn_bridge->cq, TSRST, TSRST_ENCSRST | TSRST_HDCPSRST);
+	/* Disable HDCP flag */
+	cq_writereg(&mn_bridge->cq, TSRST, HDCPEN_ENC_DIS);
+	/* HDCP AKE reset */
+	cq_writereg(&mn_bridge->cq, AKESRST, 0xff);
+	/* Wait AKE busy */
+	cq_wait_clear(&mn_bridge->cq, AKESTA, AKESTA_BUSY);
+
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("failed to run pre-enable sequence");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void radeon_ps4_bridge_enable(struct drm_bridge *bridge)
+{
+	struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge);
+	struct drm_connector *connector = mn_bridge->connector;
+	struct drm_device *dev = connector->dev;
+	struct pci_dev *pdev = dev->pdev;
+	u8 dp[3];
+
+	if (!mn_bridge->mode) {
+		DRM_ERROR("mode not available\n");
+		return;
+	}
+
+	if(pdev->vendor != PCI_VENDOR_ID_AMD) {
+		DRM_ERROR("Invalid vendor: %04x", pdev->vendor);
+		return;
+	}
+
+	DRM_DEBUG_KMS("radeon_ps4_bridge_enable (mode: %d)\n", mn_bridge->mode);
+
+	/* Here come the dragons */
+
+	if(pdev->device == PCI_DEVICE_ID_CUH_11XX)
+	{
+		/* Panasonic MN86471A */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Read DisplayPort status (?) */
+		cq_read(&mn_bridge->cq, 0x76e1, 3);
+		if (cq_exec(&mn_bridge->cq) < 11) {
+			mutex_unlock(&mn_bridge->mutex);
+			DRM_ERROR("could not read DP status");
+		return;
+		}
+		memcpy(dp, &mn_bridge->cq.reply.databuf[3], 3);
+
+		cq_init(&mn_bridge->cq, 4);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x761e, 0x77);
+		cq_wait_set(&mn_bridge->cq, 0x761f, 0x77);
+		/* Wait for ?? */
+		cq_wait_set(&mn_bridge->cq, 0x7669, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x76d9, (dp[0] & 0x1f) | (dp[0] << 5));
+		cq_writereg(&mn_bridge->cq, 0x76da, (dp[1] & 0x7c) | ((dp[0] >> 3) & 3) | ((dp[1] << 5) & 0x80));
+		cq_writereg(&mn_bridge->cq, 0x76db, 0x80 | ((dp[1] >> 3) & 0xf));
+		cq_writereg(&mn_bridge->cq, 0x76e4, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, VINCNT, VINCNT_VIF_FILEN);
+		cq_writereg(&mn_bridge->cq, 0x7071, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x765a, 0);
+		cq_writereg(&mn_bridge->cq, 0x7062, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7215, 0x28); /* aspect */
+		cq_writereg(&mn_bridge->cq, 0x7217, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0);
+		cq_writereg(&mn_bridge->cq, CSCMOD, 0xdc);
+		cq_writereg(&mn_bridge->cq, C420SET, 0xaa);
+		cq_writereg(&mn_bridge->cq, TDPCMODE, 0x4a);
+		cq_writereg(&mn_bridge->cq, OUTWSET, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x08);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7027, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x700b, 0x01);
+		cq_writereg(&mn_bridge->cq, PKTENA, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, INFENA, INFENA_AVIEN);
+		cq_writereg(&mn_bridge->cq, UPDCTRL, UPDCTRL_ALLUPD | UPDCTRL_AVIIUPD |
+						     UPDCTRL_CLKUPD | UPDCTRL_VIFUPD |
+						     UPDCTRL_CSCUPD);
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_mask(&mn_bridge->cq, 0x7216, 0x00, 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7218, 0x00);
+
+		cq_writereg(&mn_bridge->cq, 0x7096, 0xff);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+		cq_writereg(&mn_bridge->cq, 0x7016, 0x04);
+		cq_writereg(&mn_bridge->cq, 0x7a88, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7a83, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+
+		cq_wait_set(&mn_bridge->cq, 0x7096, 0x80);
+
+		cq_writereg(&mn_bridge->cq, 0x7006, 0x02);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7020, 0x21);
+
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN86471A) mode\n");
+		}
+		#if 1
+		// preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b3, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70b7, 0x0b);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0x24);
+
+		cq_mask(&mn_bridge->cq,0x70b9, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x40, 0x70);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x20, 0xe0);
+		cq_mask(&mn_bridge->cq,0x7257, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ba, 0x00, 0x88);
+		cq_mask(&mn_bridge->cq,0x70b9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable MN86471A hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x7ed8, 0x01);
+
+		cq_mask(&mn_bridge->cq,0x70b4, 0x00, 0x3e);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x02, 0x3f);
+		cq_mask(&mn_bridge->cq,0x70b7, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70bd, 0x00, 0xff);
+
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+
+		cq_wait_set(&mn_bridge->cq,0x7096, 0x80);
+		cq_writereg(&mn_bridge->cq,0x7096, 0xff);
+
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70b1, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("failed to run enable hdmi MN86471A audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+	else
+	{
+		/* Panasonic MN864729 */
+		mutex_lock(&mn_bridge->mutex);
+		cq_init(&mn_bridge->cq, 4);
+		cq_mask(&mn_bridge->cq, 0x6005, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a03, 0x47);
+
+		/* Wait for DP lane status */
+		cq_wait_set(&mn_bridge->cq, 0x60f8, 0xff);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x01);
+		cq_writereg(&mn_bridge->cq, 0x6a01, 0x4d);
+		cq_wait_set(&mn_bridge->cq, 0x60f9, 0x1a);
+
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x00, 0x21);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x00, 0x70);
+
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7402, 0x1c);
+		cq_writereg(&mn_bridge->cq, 0x6020, 0x04);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+		cq_writereg(&mn_bridge->cq, 0x10c7, 0x38);
+		cq_writereg(&mn_bridge->cq, 0x1e02, 0x88);
+		cq_writereg(&mn_bridge->cq, 0x1e00, 0x66);
+		cq_writereg(&mn_bridge->cq, 0x100c, 0x01);
+		cq_writereg(&mn_bridge->cq, TSYSCTRL, TSYSCTRL_HDMI);
+
+		cq_writereg(&mn_bridge->cq, 0x7009, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7040, 0x42);
+		cq_writereg(&mn_bridge->cq, 0x7225, 0x28);
+		cq_writereg(&mn_bridge->cq, 0x7227, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7228, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7070, mn_bridge->mode);
+		cq_writereg(&mn_bridge->cq, 0x7071, mn_bridge->mode | 0x80);
+		cq_writereg(&mn_bridge->cq, 0x7072, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7073, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7074, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x7075, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70c4, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c5, 0x0a);
+		cq_writereg(&mn_bridge->cq, 0x70c2, 0x00);
+		cq_writereg(&mn_bridge->cq, 0x70fe, 0x12);
+		cq_writereg(&mn_bridge->cq, 0x70c3, 0x10);
+
+		if(pdev->device == PCI_DEVICE_ID_CUH_12XX) {
+			/* newer ps4 phats need here 0x03 idk why. */
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x03);
+		} else {
+			cq_writereg(&mn_bridge->cq, 0x10c5, 0x00);
+		}
+
+		cq_writereg(&mn_bridge->cq, 0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq, 0x7202, 0x20);
+		cq_writereg(&mn_bridge->cq, 0x7203, 0x60);
+		cq_writereg(&mn_bridge->cq, 0x7011, 0xd5);
+		//cq_writereg(&mn_bridge->cq, 0x7a00, 0x0e);
+
+		cq_wait_set(&mn_bridge->cq, 0x10f6, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7226, 0x00, 0x80);
+		cq_mask(&mn_bridge->cq, 0x7228, 0x00, 0xFF);
+		cq_writereg(&mn_bridge->cq, 0x7204, 0x40);
+		cq_wait_clear(&mn_bridge->cq, 0x7204, 0x40);
+		cq_writereg(&mn_bridge->cq, 0x7a8b, 0x05);
+		cq_mask(&mn_bridge->cq, 0x1e02, 0x70, 0x70);
+		cq_mask(&mn_bridge->cq, 0x1034, 0x02, 0x02);
+		cq_mask(&mn_bridge->cq, 0x1e00, 0x01, 0x01);
+		cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90);
+		cq_writereg(&mn_bridge->cq, HDCPEN, 0x00);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+			DRM_ERROR("Failed to configure ps4-bridge (MN864729) mode\n");
+		}
+		#if 1
+		// AUDIO preinit
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70aa, 0x00);
+		cq_writereg(&mn_bridge->cq,0x70af, 0x07);
+		cq_writereg(&mn_bridge->cq,0x70a9, 0x5a);
+
+		cq_mask(&mn_bridge->cq,0x70af, 0x06, 0x06);
+		cq_mask(&mn_bridge->cq,0x70af, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x80, 0xe0);
+		cq_mask(&mn_bridge->cq,0x70ae, 0x01, 0x07);
+		cq_mask(&mn_bridge->cq,0x70ac, 0x01, 0x21);
+		cq_mask(&mn_bridge->cq,0x70ab, 0x80, 0x88);
+		cq_mask(&mn_bridge->cq,0x70a9, 0x01, 0x01);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 0");
+		}
+
+		cq_init(&mn_bridge->cq, 4);
+		cq_writereg(&mn_bridge->cq,0x70b0, 0x01);
+		cq_mask(&mn_bridge->cq,0x70b0, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b1, 0x79, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b2, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b3, 0x02, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b4, 0x0b, 0x0f);
+		cq_mask(&mn_bridge->cq,0x70b5, 0x00, 0xff);
+		cq_mask(&mn_bridge->cq,0x70b6, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7011, 0xa2);
+		cq_wait_set(&mn_bridge->cq,0x10f6, 0xa2);
+		cq_mask(&mn_bridge->cq,0x7267, 0x00, 0xff);
+		cq_writereg(&mn_bridge->cq,0x7204, 0x10);
+		cq_wait_clear(&mn_bridge->cq,0x7204, 0x10);
+		cq_writereg(&mn_bridge->cq,0x10f6, 0xff);
+		cq_mask(&mn_bridge->cq,0x7203, 0x10, 0x10);
+		cq_writereg(&mn_bridge->cq,0x70a8, 0xc0);
+		if (cq_exec(&mn_bridge->cq) < 0) {
+				DRM_ERROR("failed to run enable hdmi audio seq. 1");
+		}
+		#endif
+		mutex_unlock(&mn_bridge->mutex);
+	}
+
+}
+
+static void radeon_ps4_bridge_disable(struct drm_bridge *bridge)
+{
+	struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge);
+	DRM_DEBUG_KMS("radeon_ps4_bridge_disable\n");
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_writereg(&mn_bridge->cq, VMUTECNT, VMUTECNT_LINEWIDTH_90 | VMUTECNT_VMUTE_MUTE_NORMAL);
+	cq_writereg(&mn_bridge->cq, INFENA, 0x00);
+	if (cq_exec(&mn_bridge->cq) < 0) {
+		DRM_ERROR("Failed to disable bridge\n");
+	}
+	mutex_unlock(&mn_bridge->mutex);
+}
+
+static void radeon_ps4_bridge_post_disable(struct drm_bridge *bridge)
+{
+	/* struct radeon_ps4_bridge *mn_bridge = bridge_to_mn864729(bridge); */
+	DRM_DEBUG_KMS("radeon_ps4_bridge_post_disable\n");
+}
+
+/* Hardcoded modes, since we don't really know how to do custom modes yet.
+ * Other CEA modes *should* work (and are allowed if externally added) */
+
+/* 1 - 640x480@60Hz */
+static const struct drm_display_mode mode_480p = {
+	DRM_MODE("640x480", DRM_MODE_TYPE_DRIVER, 25175, 640, 656,
+		 752, 800, 0, 480, 490, 492, 525, 0,
+		 DRM_MODE_FLAG_NHSYNC | DRM_MODE_FLAG_NVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_4_3
+};
+/* 4 - 1280x720@60Hz */
+static const struct drm_display_mode mode_720p = {
+	DRM_MODE("1280x720", DRM_MODE_TYPE_DRIVER, 74250, 1280, 1390,
+		 1430, 1650, 0, 720, 725, 730, 750, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+/* 16 - 1920x1080@60Hz */
+static const struct drm_display_mode mode_1080p = {
+	DRM_MODE("1920x1080", DRM_MODE_TYPE_DRIVER, 148500, 1920, 2008,
+		 2052, 2200, 0, 1080, 1084, 1089, 1125, 0,
+		 DRM_MODE_FLAG_PHSYNC | DRM_MODE_FLAG_PVSYNC),
+	.vrefresh = 60, .picture_aspect_ratio = HDMI_PICTURE_ASPECT_16_9
+};
+
+int radeon_ps4_bridge_get_modes(struct drm_connector *connector)
+{
+	struct drm_device *dev = connector->dev;
+	struct drm_display_mode *newmode;
+	DRM_DEBUG_KMS("radeon_ps4_bridge_get_modes\n");
+
+	newmode = drm_mode_duplicate(dev, &mode_1080p);
+	drm_mode_probed_add(connector, newmode);
+
+	//newmode = drm_mode_duplicate(dev, &mode_720p);
+	//drm_mode_probed_add(connector, newmode);
+	//newmode = drm_mode_duplicate(dev, &mode_480p);
+	//drm_mode_probed_add(connector, newmode);
+
+	drm_mode_connector_update_edid_property(connector, NULL);
+
+	return 0;
+}
+
+enum drm_connector_status radeon_ps4_bridge_detect(struct drm_connector *connector,
+		bool force)
+{
+	struct radeon_ps4_bridge *mn_bridge = &g_bridge;
+	u8 reg;
+
+	struct radeon_connector *radeon_connector = to_radeon_connector(connector);
+	struct radeon_connector_atom_dig *radeon_dig_connector = radeon_connector->con_priv;
+
+	radeon_dig_connector->dp_sink_type = CONNECTOR_OBJECT_ID_DISPLAYPORT;
+	radeon_dp_getdpcd(radeon_connector);
+
+	mutex_lock(&mn_bridge->mutex);
+	cq_init(&mn_bridge->cq, 4);
+	cq_read(&mn_bridge->cq, TMONREG, 1);
+	if (cq_exec(&mn_bridge->cq) < 9) {
+		mutex_unlock(&mn_bridge->mutex);
+		DRM_ERROR("could not read TMONREG");
+		return connector_status_disconnected;
+	}
+	reg = mn_bridge->cq.reply.databuf[3];
+	mutex_unlock(&mn_bridge->mutex);
+
+	DRM_DEBUG_KMS("TMONREG=0x%02x\n", reg);
+
+	if (reg & TMONREG_HPD)
+		return connector_status_connected;
+	else
+		return connector_status_disconnected;
+}
+
+int radeon_ps4_bridge_mode_valid(struct drm_connector *connector,
+				  struct drm_display_mode *mode)
+{
+	int vic = drm_match_cea_mode(mode);
+
+	/* Allow anything that we can match up to a VIC (CEA modes) */
+	if (!vic || (vic != 16 && vic != 4)) {
+		return MODE_BAD;
+	}
+
+	return MODE_OK;
+}
+
+static int radeon_ps4_bridge_attach(struct drm_bridge *bridge)
+{
+	/* struct radeon_ps4_bridge *mn_bridge = bridge_to_radeon_ps4_bridge(bridge); */
+
+	return 0;
+}
+
+static struct drm_bridge_funcs radeon_ps4_bridge_funcs = {
+	.pre_enable = radeon_ps4_bridge_pre_enable,
+	.enable = radeon_ps4_bridge_enable,
+	.disable = radeon_ps4_bridge_disable,
+	.post_disable = radeon_ps4_bridge_post_disable,
+	.attach = radeon_ps4_bridge_attach,
+	.mode_set = radeon_ps4_bridge_mode_set
+};
+
+int radeon_ps4_bridge_register(struct drm_connector *connector,
+			     struct drm_encoder *encoder)
+{
+	int ret;
+	struct radeon_ps4_bridge *mn_bridge = &g_bridge;
+	//struct drm_device *dev = connector->dev;
+
+	mn_bridge->encoder = encoder;
+	mn_bridge->connector = connector;
+	mn_bridge->bridge.funcs = &radeon_ps4_bridge_funcs;
+	ret = drm_bridge_attach(mn_bridge->encoder, &mn_bridge->bridge, NULL, 0);
+	if (ret) {
+		DRM_ERROR("Failed to initialize bridge with drm\n");
+		return -EINVAL;
+	}
+
+	//encoder->bridge = &mn_bridge->bridge;
+	// TODO (ps4patches): This seems to be the new way of adding bridges
+	drm_bridge_add(&mn_bridge->bridge);
+
+	return 0;
+}
diff --git a/drivers/gpu/drm/radeon/radeon.h b/drivers/gpu/drm/radeon/radeon.h
index 895776c421d4..314fd436f3c9 100644
--- a/drivers/gpu/drm/radeon/radeon.h
+++ b/drivers/gpu/drm/radeon/radeon.h
@@ -2679,7 +2679,8 @@ void r100_pll_errata_after_index(struct radeon_device *rdev);
 #define ASIC_IS_DCE81(rdev) ((rdev->family == CHIP_KAVERI))
 #define ASIC_IS_DCE82(rdev) ((rdev->family == CHIP_BONAIRE))
 #define ASIC_IS_DCE83(rdev) ((rdev->family == CHIP_KABINI) || \
-			     (rdev->family == CHIP_MULLINS))
+			     (rdev->family == CHIP_MULLINS || \
+			     (rdev->family == CHIP_LIVERPOOL))
 
 #define ASIC_IS_LOMBOK(rdev) ((rdev->pdev->device == 0x6849) || \
 			      (rdev->pdev->device == 0x6850) || \
diff --git a/drivers/gpu/drm/radeon/radeon_asic.c b/drivers/gpu/drm/radeon/radeon_asic.c
index bfacf8fe5cc1..8f6dfa22daed 100644
--- a/drivers/gpu/drm/radeon/radeon_asic.c
+++ b/drivers/gpu/drm/radeon/radeon_asic.c
@@ -2632,7 +2632,16 @@ int radeon_asic_init(struct radeon_device *rdev)
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
 	case CHIP_MULLINS:
+	case CHIP_LIVERPOOL:
+		if(rdev->family == CHIP_LIVERPOOL)
+		{
+			// TODO (ps4patches): Does this work?
+			kv_asic.copy.blit = &cik_copy_cpdma;
+			kv_asic.copy.blit_ring_index = R600_RING_TYPE_DMA_INDEX;
+		}
+
 		rdev->asic = &kv_asic;
+
 		/* set num crtcs */
 		if (rdev->family == CHIP_KAVERI) {
 			rdev->num_crtc = 4;
@@ -2689,8 +2698,14 @@ int radeon_asic_init(struct radeon_device *rdev)
 				RADEON_PG_SUPPORT_RLC_SMU_HS |
 				RADEON_PG_SUPPORT_SAMU;*/
 		}
-		rdev->has_uvd = true;
-		rdev->has_vce = true;
+
+		if(rdev->family == CHIP_LIVERPOOL) {
+			rdev->has_uvd = false;
+			rdev->has_vce = false;
+		} else {
+			rdev->has_uvd = true;
+			rdev->has_vce = true;
+		}
 		break;
 	default:
 		/* FIXME: not supported yet */
diff --git a/drivers/gpu/drm/radeon/radeon_audio.c b/drivers/gpu/drm/radeon/radeon_audio.c
index 7c5e80d03fc9..ba877d0b73fd 100644
--- a/drivers/gpu/drm/radeon/radeon_audio.c
+++ b/drivers/gpu/drm/radeon/radeon_audio.c
@@ -273,8 +273,14 @@ int radeon_audio_init(struct radeon_device *rdev)
 	radeon_audio_interface_init(rdev);
 
 	/* disable audio.  it will be set up later */
-	for (i = 0; i < rdev->audio.num_pins; i++)
-		radeon_audio_enable(rdev, &rdev->audio.pin[i], 0);
+	for (i = 0; i < rdev->audio.num_pins; i++) {
+		/* LVP has standalone S/PDIF on the third pin, always enable */
+		if (rdev->family == CHIP_LIVERPOOL) {
+			radeon_audio_enable(rdev, &rdev->audio.pin[i], 0xf);
+		} else {
+			radeon_audio_enable(rdev, &rdev->audio.pin[i], 0);
+		}
+	}
 
 	return 0;
 }
diff --git a/drivers/gpu/drm/radeon/radeon_connectors.c b/drivers/gpu/drm/radeon/radeon_connectors.c
index d157bb9072e8..984323a541ba 100644
--- a/drivers/gpu/drm/radeon/radeon_connectors.c
+++ b/drivers/gpu/drm/radeon/radeon_connectors.c
@@ -1480,6 +1480,30 @@ static void radeon_dvi_force(struct drm_connector *connector)
 		radeon_connector->use_digital = true;
 }
 
+#ifdef CONFIG_X86_PS4
+int radeon_ps4_bridge_get_modes(struct drm_connector *connector);
+enum drm_connector_status radeon_ps4_bridge_detect(struct drm_connector *connector,
+						   bool force);
+int radeon_ps4_bridge_mode_valid(struct drm_connector *connector,
+				 struct drm_display_mode *mode);
+
+static const struct drm_connector_helper_funcs radeon_ps4_dp_connector_helper_funcs = {
+	.get_modes = radeon_ps4_bridge_get_modes,
+	.mode_valid = radeon_ps4_bridge_mode_valid,
+	.best_encoder = radeon_dvi_encoder,
+};
+
+static const struct drm_connector_funcs radeon_ps4_dp_connector_funcs = {
+	.dpms = drm_helper_connector_dpms,
+	.detect = radeon_ps4_bridge_detect,
+	.fill_modes = drm_helper_probe_single_connector_modes,
+	//.set_property = radeon_connector_set_property,
+	.destroy = radeon_connector_destroy,
+	.force = radeon_dvi_force,
+};
+
+#endif
+
 static enum drm_mode_status radeon_dvi_mode_valid(struct drm_connector *connector,
 				  struct drm_display_mode *mode)
 {
@@ -1879,6 +1903,7 @@ radeon_add_atom_connector(struct drm_device *dev,
 	uint32_t subpixel_order = SubPixelNone;
 	bool shared_ddc = false;
 	bool is_dp_bridge = false;
+	bool is_ps4_bridge = false;
 	bool has_aux = false;
 
 	if (connector_type == DRM_MODE_CONNECTOR_Unknown)
@@ -1930,6 +1955,18 @@ radeon_add_atom_connector(struct drm_device *dev,
 	if (!radeon_connector)
 		return;
 
+	/* Liverpool (PS4) has an DP bridge which needs a special driver, and
+ 	 * a fake HDMI port that doesn't really exist. */
+	if (rdev->family == CHIP_LIVERPOOL) {
+		if (connector_type == DRM_MODE_CONNECTOR_DisplayPort) {
+			connector_type = DRM_MODE_CONNECTOR_HDMIA;
+			is_dp_bridge = true;
+			is_ps4_bridge = true;
+		} else {
+			return;
+		}
+	}
+
 	connector = &radeon_connector->base;
 
 	radeon_connector->connector_id = connector_id;
@@ -1989,12 +2026,20 @@ radeon_add_atom_connector(struct drm_device *dev,
 		case DRM_MODE_CONNECTOR_HDMIA:
 		case DRM_MODE_CONNECTOR_HDMIB:
 		case DRM_MODE_CONNECTOR_DisplayPort:
-			drm_connector_init_with_ddc(dev, &radeon_connector->base,
-						    &radeon_dp_connector_funcs,
-						    connector_type,
-						    ddc);
-			drm_connector_helper_add(&radeon_connector->base,
-						 &radeon_dp_connector_helper_funcs);
+			if (is_ps4_bridge) {
+				drm_connector_init(dev, &radeon_connector->base,
+						   &radeon_dp_connector_funcs, connector_type);
+				drm_connector_helper_add(&radeon_connector->base,
+							 &radeon_dp_connector_helper_funcs);
+			} else {
+				drm_connector_init_with_ddc(dev, &radeon_connector->base,
+							    &radeon_dp_connector_funcs,
+							    connector_type,
+							    ddc);
+				drm_connector_helper_add(&radeon_connector->base,
+							 &radeon_dp_connector_helper_funcs);
+			}
+
 			drm_object_attach_property(&radeon_connector->base.base,
 						      rdev->mode_info.underscan_property,
 						      UNDERSCAN_OFF);
diff --git a/drivers/gpu/drm/radeon/radeon_device.c b/drivers/gpu/drm/radeon/radeon_device.c
index 1c005e0ddd38..efa4c92762dd 100644
--- a/drivers/gpu/drm/radeon/radeon_device.c
+++ b/drivers/gpu/drm/radeon/radeon_device.c
@@ -107,6 +107,7 @@ static const char radeon_family_name[][16] = {
 	"BONAIRE",
 	"KAVERI",
 	"KABINI",
+	"LIVERPOOL",
 	"HAWAII",
 	"MULLINS",
 	"LAST",
diff --git a/drivers/gpu/drm/radeon/radeon_display.c b/drivers/gpu/drm/radeon/radeon_display.c
index 573154268d43..c10008fd1ac4 100644
--- a/drivers/gpu/drm/radeon/radeon_display.c
+++ b/drivers/gpu/drm/radeon/radeon_display.c
@@ -688,7 +688,7 @@ static void radeon_crtc_init(struct drm_device *dev, int index)
 	radeon_crtc->flip_queue = alloc_workqueue("radeon-crtc", WQ_HIGHPRI, 0);
 	rdev->mode_info.crtcs[index] = radeon_crtc;
 
-	if (rdev->family >= CHIP_BONAIRE) {
+	if (rdev->family >= CHIP_BONAIRE && rdev->family != CHIP_LIVERPOOL) {
 		radeon_crtc->max_cursor_width = CIK_CURSOR_WIDTH;
 		radeon_crtc->max_cursor_height = CIK_CURSOR_HEIGHT;
 	} else {
diff --git a/drivers/gpu/drm/radeon/radeon_drv.c b/drivers/gpu/drm/radeon/radeon_drv.c
index b74cebca1f89..3f72fc64df20 100644
--- a/drivers/gpu/drm/radeon/radeon_drv.c
+++ b/drivers/gpu/drm/radeon/radeon_drv.c
@@ -51,6 +51,11 @@
 #include <drm/radeon_drm.h>
 
 #include "radeon_drv.h"
+
+#ifdef CONFIG_X86_PS4
+#include <asm/ps4.h>
+#endif
+
 #include "radeon.h"
 #include "radeon_kms.h"
 #include "radeon_ttm.h"
@@ -334,6 +339,16 @@ static int radeon_pci_probe(struct pci_dev *pdev,
 	if (ret)
 		return ret;
 
+	#ifdef CONFIG_X86_PS4
+	/* On the PS4 (Liverpool graphics) we have a hard dependency on the
+	 * Aeolia driver to set up the HDMI encoder which is connected to it,
+	 * so defer probe until it is ready. This test passes if this isn't
+	 * a PS4 (returns -ENODEV).
+	 */
+	if (apcie_status() == 0)
+		return -EPROBE_DEFER;
+	#endif
+
 	dev = drm_dev_alloc(&kms_driver, &pdev->dev);
 	if (IS_ERR(dev))
 		return PTR_ERR(dev);
diff --git a/drivers/gpu/drm/radeon/radeon_encoders.c b/drivers/gpu/drm/radeon/radeon_encoders.c
index 46549d5179ee..abfc75d5d138 100644
--- a/drivers/gpu/drm/radeon/radeon_encoders.c
+++ b/drivers/gpu/drm/radeon/radeon_encoders.c
@@ -195,6 +195,22 @@ static void radeon_encoder_add_backlight(struct radeon_encoder *radeon_encoder,
 	}
 }
 
+#ifdef CONFIG_X86_PS4
+int radeon_ps4_bridge_register(struct drm_connector *connector,
+			       struct drm_encoder *encoder);
+
+static void radeon_maybe_add_bridge(struct drm_connector *connector,
+				    struct drm_encoder *encoder)
+{
+	struct drm_device *dev = connector->dev;
+	struct radeon_device *rdev = dev->dev_private;
+
+	if (rdev->family == CHIP_LIVERPOOL) {
+		radeon_ps4_bridge_register(connector, encoder);
+	}
+}
+#endif
+
 void
 radeon_link_encoder_connector(struct drm_device *dev)
 {
@@ -209,6 +225,9 @@ radeon_link_encoder_connector(struct drm_device *dev)
 		list_for_each_entry(encoder, &dev->mode_config.encoder_list, head) {
 			radeon_encoder = to_radeon_encoder(encoder);
 			if (radeon_encoder->devices & radeon_connector->devices) {
+				#ifdef CONFIG_X86_PS4
+				radeon_maybe_add_bridge(connector, encoder);
+				#endif
 				drm_connector_attach_encoder(connector, encoder);
 				if (radeon_encoder->devices & (ATOM_DEVICE_LCD_SUPPORT))
 					radeon_encoder_add_backlight(radeon_encoder, connector);
diff --git a/drivers/gpu/drm/radeon/radeon_family.h b/drivers/gpu/drm/radeon/radeon_family.h
index 4b7b87f71a63..ca1a89fccbeb 100644
--- a/drivers/gpu/drm/radeon/radeon_family.h
+++ b/drivers/gpu/drm/radeon/radeon_family.h
@@ -97,6 +97,7 @@ enum radeon_family {
 	CHIP_KAVERI,
 	CHIP_KABINI,
 	CHIP_HAWAII,
+	CHIP_LIVERPOOL,
 	CHIP_MULLINS,
 	CHIP_LAST,
 };
diff --git a/drivers/gpu/drm/radeon/radeon_ib.c b/drivers/gpu/drm/radeon/radeon_ib.c
index 62b116727b4f..a40e4f6b7b18 100644
--- a/drivers/gpu/drm/radeon/radeon_ib.c
+++ b/drivers/gpu/drm/radeon/radeon_ib.c
@@ -259,8 +259,15 @@ int radeon_ib_ring_tests(struct radeon_device *rdev)
 {
 	unsigned i;
 	int r;
+	int num_rings = 0;
 
-	for (i = 0; i < RADEON_NUM_RINGS; ++i) {
+	if(rdev->family == CHIP_LIVERPOOL) {
+		num_rings = 1;
+	} else {
+		num_rings = RADEON_NUM_RINGS;
+	}
+
+	for (i = 0; i < num_rings; ++i) {
 		struct radeon_ring *ring = &rdev->ring[i];
 
 		if (!ring->ready)
diff --git a/drivers/gpu/drm/radeon/radeon_pm.c b/drivers/gpu/drm/radeon/radeon_pm.c
index c67b6ddb29a4..2dfb2c72ca12 100644
--- a/drivers/gpu/drm/radeon/radeon_pm.c
+++ b/drivers/gpu/drm/radeon/radeon_pm.c
@@ -1555,6 +1555,7 @@ int radeon_pm_init(struct radeon_device *rdev)
 	case CHIP_BONAIRE:
 	case CHIP_KABINI:
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
 	case CHIP_HAWAII:
 	case CHIP_MULLINS:
 		/* DPM requires the RLC, RV770+ dGPU requires SMC */
diff --git a/drivers/gpu/drm/radeon/radeon_ucode.h b/drivers/gpu/drm/radeon/radeon_ucode.h
index dc4576e4d8ad..4896ea0d25a4 100644
--- a/drivers/gpu/drm/radeon/radeon_ucode.h
+++ b/drivers/gpu/drm/radeon/radeon_ucode.h
@@ -38,6 +38,8 @@
 #define CIK_PFP_UCODE_SIZE           2144
 #define CIK_ME_UCODE_SIZE            2144
 #define CIK_CE_UCODE_SIZE            2144
+#define LIVERPOOL_PFP_UCODE_SIZE     4192
+#define LIVERPOOL_ME_UCODE_SIZE      4192
 
 /* MEC */
 #define CIK_MEC_UCODE_SIZE           4192
@@ -53,6 +55,7 @@
 #define KB_RLC_UCODE_SIZE            2560
 #define KV_RLC_UCODE_SIZE            2560
 #define ML_RLC_UCODE_SIZE            2560
+#define LIVERPOOL_RLC_UCODE_SIZE     1536
 
 /* MC */
 #define BTC_MC_UCODE_SIZE            6024
diff --git a/drivers/gpu/drm/radeon/radeon_uvd.c b/drivers/gpu/drm/radeon/radeon_uvd.c
index 2ea86919d953..42d4918dbb2c 100644
--- a/drivers/gpu/drm/radeon/radeon_uvd.c
+++ b/drivers/gpu/drm/radeon/radeon_uvd.c
@@ -124,6 +124,7 @@ int radeon_uvd_init(struct radeon_device *rdev)
 	case CHIP_BONAIRE:
 	case CHIP_KABINI:
 	case CHIP_KAVERI:
+	case CHIP_LIVERPOOL:
 	case CHIP_HAWAII:
 	case CHIP_MULLINS:
 		legacy_fw_name = FIRMWARE_BONAIRE_LEGACY;
diff --git a/drivers/gpu/drm/radeon/radeon_vce.c b/drivers/gpu/drm/radeon/radeon_vce.c
index 511a942e851d..a5096b33cc5f 100644
--- a/drivers/gpu/drm/radeon/radeon_vce.c
+++ b/drivers/gpu/drm/radeon/radeon_vce.c
@@ -75,6 +75,7 @@ int radeon_vce_init(struct radeon_device *rdev)
 	case CHIP_BONAIRE:
 	case CHIP_KAVERI:
 	case CHIP_KABINI:
+	case CHIP_LIVERPOOL:
 	case CHIP_HAWAII:
 	case CHIP_MULLINS:
 		fw_name = FIRMWARE_BONAIRE;
-- 
2.45.1

